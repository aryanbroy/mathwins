
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model DailyTournament
 * 
 */
export type DailyTournament = $Result.DefaultSelection<Prisma.$DailyTournamentPayload>
/**
 * Model DailyTournamentSession
 * 
 */
export type DailyTournamentSession = $Result.DefaultSelection<Prisma.$DailyTournamentSessionPayload>
/**
 * Model MinuteSnapshot
 * 
 */
export type MinuteSnapshot = $Result.DefaultSelection<Prisma.$MinuteSnapshotPayload>
/**
 * Model SoloSession
 * 
 */
export type SoloSession = $Result.DefaultSelection<Prisma.$SoloSessionPayload>
/**
 * Model QuestionAttempt
 * 
 */
export type QuestionAttempt = $Result.DefaultSelection<Prisma.$QuestionAttemptPayload>
/**
 * Model InstantTournament
 * 
 */
export type InstantTournament = $Result.DefaultSelection<Prisma.$InstantTournamentPayload>
/**
 * Model InstantSession
 * 
 */
export type InstantSession = $Result.DefaultSelection<Prisma.$InstantSessionPayload>
/**
 * Model InstantParticipant
 * 
 */
export type InstantParticipant = $Result.DefaultSelection<Prisma.$InstantParticipantPayload>
/**
 * Model DailyLeaderboard
 * 
 */
export type DailyLeaderboard = $Result.DefaultSelection<Prisma.$DailyLeaderboardPayload>
/**
 * Model InstantLeaderboard
 * 
 */
export type InstantLeaderboard = $Result.DefaultSelection<Prisma.$InstantLeaderboardPayload>
/**
 * Model DailyUserLeaderboard
 * 
 */
export type DailyUserLeaderboard = $Result.DefaultSelection<Prisma.$DailyUserLeaderboardPayload>
/**
 * Model SoloLeaderboard
 * 
 */
export type SoloLeaderboard = $Result.DefaultSelection<Prisma.$SoloLeaderboardPayload>
/**
 * Model RewardClaim
 * 
 */
export type RewardClaim = $Result.DefaultSelection<Prisma.$RewardClaimPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model CoinLedger
 * 
 */
export type CoinLedger = $Result.DefaultSelection<Prisma.$CoinLedgerPayload>
/**
 * Model GameConfig
 * 
 */
export type GameConfig = $Result.DefaultSelection<Prisma.$GameConfigPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AvatarType: {
  DEFAULT: 'DEFAULT',
  UPLOADED: 'UPLOADED'
};

export type AvatarType = (typeof AvatarType)[keyof typeof AvatarType]


export const Theme: {
  LIGHT: 'LIGHT',
  DARK: 'DARK',
  SYSTEM: 'SYSTEM'
};

export type Theme = (typeof Theme)[keyof typeof Theme]


export const TransactionType: {
  INCREMENT: 'INCREMENT',
  DECREMENT: 'DECREMENT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionDescription: {
  SINGLE_PLAYER: 'SINGLE_PLAYER',
  DAILY_TOURNAMENT: 'DAILY_TOURNAMENT',
  INSTANT_TOURNAMENT: 'INSTANT_TOURNAMENT',
  REFERRAL_POINT: 'REFERRAL_POINT',
  REWARD_CLAIM: 'REWARD_CLAIM'
};

export type TransactionDescription = (typeof TransactionDescription)[keyof typeof TransactionDescription]


export const UserTournamentStatus: {
  NOT_OPENED: 'NOT_OPENED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type UserTournamentStatus = (typeof UserTournamentStatus)[keyof typeof UserTournamentStatus]


export const TournamentStatus: {
  NOT_OPENED: 'NOT_OPENED',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  FULL: 'FULL',
  CANCELLED: 'CANCELLED'
};

export type TournamentStatus = (typeof TournamentStatus)[keyof typeof TournamentStatus]


export const InstantTournamentSessionStatus: {
  ACTIVE: 'ACTIVE',
  SUBMITTED: 'SUBMITTED',
  EXPIRED: 'EXPIRED'
};

export type InstantTournamentSessionStatus = (typeof InstantTournamentSessionStatus)[keyof typeof InstantTournamentSessionStatus]


export const ClaimStatus: {
  PENDING: 'PENDING',
  FULFILLED: 'FULFILLED',
  REJECTED: 'REJECTED'
};

export type ClaimStatus = (typeof ClaimStatus)[keyof typeof ClaimStatus]


export const ReferralStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED'
};

export type ReferralStatus = (typeof ReferralStatus)[keyof typeof ReferralStatus]


export const CoinLedgerSource: {
  DAILY_PERFORMANCE: 'DAILY_PERFORMANCE',
  REFERRAL: 'REFERRAL',
  REWARD_LOCK: 'REWARD_LOCK',
  REWARD_UNLOCK: 'REWARD_UNLOCK',
  REDEMPTION: 'REDEMPTION',
  DAILY_LOGIN: 'DAILY_LOGIN'
};

export type CoinLedgerSource = (typeof CoinLedgerSource)[keyof typeof CoinLedgerSource]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AvatarType = $Enums.AvatarType

export const AvatarType: typeof $Enums.AvatarType

export type Theme = $Enums.Theme

export const Theme: typeof $Enums.Theme

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionDescription = $Enums.TransactionDescription

export const TransactionDescription: typeof $Enums.TransactionDescription

export type UserTournamentStatus = $Enums.UserTournamentStatus

export const UserTournamentStatus: typeof $Enums.UserTournamentStatus

export type TournamentStatus = $Enums.TournamentStatus

export const TournamentStatus: typeof $Enums.TournamentStatus

export type InstantTournamentSessionStatus = $Enums.InstantTournamentSessionStatus

export const InstantTournamentSessionStatus: typeof $Enums.InstantTournamentSessionStatus

export type ClaimStatus = $Enums.ClaimStatus

export const ClaimStatus: typeof $Enums.ClaimStatus

export type ReferralStatus = $Enums.ReferralStatus

export const ReferralStatus: typeof $Enums.ReferralStatus

export type CoinLedgerSource = $Enums.CoinLedgerSource

export const CoinLedgerSource: typeof $Enums.CoinLedgerSource

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyTournament`: Exposes CRUD operations for the **DailyTournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyTournaments
    * const dailyTournaments = await prisma.dailyTournament.findMany()
    * ```
    */
  get dailyTournament(): Prisma.DailyTournamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyTournamentSession`: Exposes CRUD operations for the **DailyTournamentSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyTournamentSessions
    * const dailyTournamentSessions = await prisma.dailyTournamentSession.findMany()
    * ```
    */
  get dailyTournamentSession(): Prisma.DailyTournamentSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.minuteSnapshot`: Exposes CRUD operations for the **MinuteSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MinuteSnapshots
    * const minuteSnapshots = await prisma.minuteSnapshot.findMany()
    * ```
    */
  get minuteSnapshot(): Prisma.MinuteSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.soloSession`: Exposes CRUD operations for the **SoloSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SoloSessions
    * const soloSessions = await prisma.soloSession.findMany()
    * ```
    */
  get soloSession(): Prisma.SoloSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionAttempt`: Exposes CRUD operations for the **QuestionAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionAttempts
    * const questionAttempts = await prisma.questionAttempt.findMany()
    * ```
    */
  get questionAttempt(): Prisma.QuestionAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instantTournament`: Exposes CRUD operations for the **InstantTournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstantTournaments
    * const instantTournaments = await prisma.instantTournament.findMany()
    * ```
    */
  get instantTournament(): Prisma.InstantTournamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instantSession`: Exposes CRUD operations for the **InstantSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstantSessions
    * const instantSessions = await prisma.instantSession.findMany()
    * ```
    */
  get instantSession(): Prisma.InstantSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instantParticipant`: Exposes CRUD operations for the **InstantParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstantParticipants
    * const instantParticipants = await prisma.instantParticipant.findMany()
    * ```
    */
  get instantParticipant(): Prisma.InstantParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyLeaderboard`: Exposes CRUD operations for the **DailyLeaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyLeaderboards
    * const dailyLeaderboards = await prisma.dailyLeaderboard.findMany()
    * ```
    */
  get dailyLeaderboard(): Prisma.DailyLeaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instantLeaderboard`: Exposes CRUD operations for the **InstantLeaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstantLeaderboards
    * const instantLeaderboards = await prisma.instantLeaderboard.findMany()
    * ```
    */
  get instantLeaderboard(): Prisma.InstantLeaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyUserLeaderboard`: Exposes CRUD operations for the **DailyUserLeaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyUserLeaderboards
    * const dailyUserLeaderboards = await prisma.dailyUserLeaderboard.findMany()
    * ```
    */
  get dailyUserLeaderboard(): Prisma.DailyUserLeaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.soloLeaderboard`: Exposes CRUD operations for the **SoloLeaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SoloLeaderboards
    * const soloLeaderboards = await prisma.soloLeaderboard.findMany()
    * ```
    */
  get soloLeaderboard(): Prisma.SoloLeaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardClaim`: Exposes CRUD operations for the **RewardClaim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardClaims
    * const rewardClaims = await prisma.rewardClaim.findMany()
    * ```
    */
  get rewardClaim(): Prisma.RewardClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coinLedger`: Exposes CRUD operations for the **CoinLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoinLedgers
    * const coinLedgers = await prisma.coinLedger.findMany()
    * ```
    */
  get coinLedger(): Prisma.CoinLedgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameConfig`: Exposes CRUD operations for the **GameConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameConfigs
    * const gameConfigs = await prisma.gameConfig.findMany()
    * ```
    */
  get gameConfig(): Prisma.GameConfigDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    DailyTournament: 'DailyTournament',
    DailyTournamentSession: 'DailyTournamentSession',
    MinuteSnapshot: 'MinuteSnapshot',
    SoloSession: 'SoloSession',
    QuestionAttempt: 'QuestionAttempt',
    InstantTournament: 'InstantTournament',
    InstantSession: 'InstantSession',
    InstantParticipant: 'InstantParticipant',
    DailyLeaderboard: 'DailyLeaderboard',
    InstantLeaderboard: 'InstantLeaderboard',
    DailyUserLeaderboard: 'DailyUserLeaderboard',
    SoloLeaderboard: 'SoloLeaderboard',
    RewardClaim: 'RewardClaim',
    Referral: 'Referral',
    CoinLedger: 'CoinLedger',
    GameConfig: 'GameConfig'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "dailyTournament" | "dailyTournamentSession" | "minuteSnapshot" | "soloSession" | "questionAttempt" | "instantTournament" | "instantSession" | "instantParticipant" | "dailyLeaderboard" | "instantLeaderboard" | "dailyUserLeaderboard" | "soloLeaderboard" | "rewardClaim" | "referral" | "coinLedger" | "gameConfig"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      DailyTournament: {
        payload: Prisma.$DailyTournamentPayload<ExtArgs>
        fields: Prisma.DailyTournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyTournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyTournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>
          }
          findFirst: {
            args: Prisma.DailyTournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyTournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>
          }
          findMany: {
            args: Prisma.DailyTournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>[]
          }
          create: {
            args: Prisma.DailyTournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>
          }
          createMany: {
            args: Prisma.DailyTournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyTournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>[]
          }
          delete: {
            args: Prisma.DailyTournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>
          }
          update: {
            args: Prisma.DailyTournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>
          }
          deleteMany: {
            args: Prisma.DailyTournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyTournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyTournamentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>[]
          }
          upsert: {
            args: Prisma.DailyTournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentPayload>
          }
          aggregate: {
            args: Prisma.DailyTournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyTournament>
          }
          groupBy: {
            args: Prisma.DailyTournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyTournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyTournamentCountArgs<ExtArgs>
            result: $Utils.Optional<DailyTournamentCountAggregateOutputType> | number
          }
        }
      }
      DailyTournamentSession: {
        payload: Prisma.$DailyTournamentSessionPayload<ExtArgs>
        fields: Prisma.DailyTournamentSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyTournamentSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyTournamentSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>
          }
          findFirst: {
            args: Prisma.DailyTournamentSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyTournamentSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>
          }
          findMany: {
            args: Prisma.DailyTournamentSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>[]
          }
          create: {
            args: Prisma.DailyTournamentSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>
          }
          createMany: {
            args: Prisma.DailyTournamentSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyTournamentSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>[]
          }
          delete: {
            args: Prisma.DailyTournamentSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>
          }
          update: {
            args: Prisma.DailyTournamentSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>
          }
          deleteMany: {
            args: Prisma.DailyTournamentSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyTournamentSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyTournamentSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>[]
          }
          upsert: {
            args: Prisma.DailyTournamentSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyTournamentSessionPayload>
          }
          aggregate: {
            args: Prisma.DailyTournamentSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyTournamentSession>
          }
          groupBy: {
            args: Prisma.DailyTournamentSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyTournamentSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyTournamentSessionCountArgs<ExtArgs>
            result: $Utils.Optional<DailyTournamentSessionCountAggregateOutputType> | number
          }
        }
      }
      MinuteSnapshot: {
        payload: Prisma.$MinuteSnapshotPayload<ExtArgs>
        fields: Prisma.MinuteSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MinuteSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MinuteSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>
          }
          findFirst: {
            args: Prisma.MinuteSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MinuteSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>
          }
          findMany: {
            args: Prisma.MinuteSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>[]
          }
          create: {
            args: Prisma.MinuteSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>
          }
          createMany: {
            args: Prisma.MinuteSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MinuteSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>[]
          }
          delete: {
            args: Prisma.MinuteSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>
          }
          update: {
            args: Prisma.MinuteSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.MinuteSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MinuteSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MinuteSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.MinuteSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinuteSnapshotPayload>
          }
          aggregate: {
            args: Prisma.MinuteSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMinuteSnapshot>
          }
          groupBy: {
            args: Prisma.MinuteSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<MinuteSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.MinuteSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<MinuteSnapshotCountAggregateOutputType> | number
          }
        }
      }
      SoloSession: {
        payload: Prisma.$SoloSessionPayload<ExtArgs>
        fields: Prisma.SoloSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoloSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoloSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>
          }
          findFirst: {
            args: Prisma.SoloSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoloSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>
          }
          findMany: {
            args: Prisma.SoloSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>[]
          }
          create: {
            args: Prisma.SoloSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>
          }
          createMany: {
            args: Prisma.SoloSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SoloSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>[]
          }
          delete: {
            args: Prisma.SoloSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>
          }
          update: {
            args: Prisma.SoloSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>
          }
          deleteMany: {
            args: Prisma.SoloSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SoloSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SoloSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>[]
          }
          upsert: {
            args: Prisma.SoloSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloSessionPayload>
          }
          aggregate: {
            args: Prisma.SoloSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoloSession>
          }
          groupBy: {
            args: Prisma.SoloSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoloSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoloSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SoloSessionCountAggregateOutputType> | number
          }
        }
      }
      QuestionAttempt: {
        payload: Prisma.$QuestionAttemptPayload<ExtArgs>
        fields: Prisma.QuestionAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuestionAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          findMany: {
            args: Prisma.QuestionAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>[]
          }
          create: {
            args: Prisma.QuestionAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          createMany: {
            args: Prisma.QuestionAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuestionAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          update: {
            args: Prisma.QuestionAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuestionAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>[]
          }
          upsert: {
            args: Prisma.QuestionAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuestionAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionAttempt>
          }
          groupBy: {
            args: Prisma.QuestionAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionAttemptCountAggregateOutputType> | number
          }
        }
      }
      InstantTournament: {
        payload: Prisma.$InstantTournamentPayload<ExtArgs>
        fields: Prisma.InstantTournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstantTournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstantTournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>
          }
          findFirst: {
            args: Prisma.InstantTournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstantTournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>
          }
          findMany: {
            args: Prisma.InstantTournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>[]
          }
          create: {
            args: Prisma.InstantTournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>
          }
          createMany: {
            args: Prisma.InstantTournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstantTournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>[]
          }
          delete: {
            args: Prisma.InstantTournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>
          }
          update: {
            args: Prisma.InstantTournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>
          }
          deleteMany: {
            args: Prisma.InstantTournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstantTournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstantTournamentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>[]
          }
          upsert: {
            args: Prisma.InstantTournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantTournamentPayload>
          }
          aggregate: {
            args: Prisma.InstantTournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstantTournament>
          }
          groupBy: {
            args: Prisma.InstantTournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstantTournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstantTournamentCountArgs<ExtArgs>
            result: $Utils.Optional<InstantTournamentCountAggregateOutputType> | number
          }
        }
      }
      InstantSession: {
        payload: Prisma.$InstantSessionPayload<ExtArgs>
        fields: Prisma.InstantSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstantSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstantSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>
          }
          findFirst: {
            args: Prisma.InstantSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstantSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>
          }
          findMany: {
            args: Prisma.InstantSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>[]
          }
          create: {
            args: Prisma.InstantSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>
          }
          createMany: {
            args: Prisma.InstantSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstantSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>[]
          }
          delete: {
            args: Prisma.InstantSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>
          }
          update: {
            args: Prisma.InstantSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>
          }
          deleteMany: {
            args: Prisma.InstantSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstantSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstantSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>[]
          }
          upsert: {
            args: Prisma.InstantSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantSessionPayload>
          }
          aggregate: {
            args: Prisma.InstantSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstantSession>
          }
          groupBy: {
            args: Prisma.InstantSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstantSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstantSessionCountArgs<ExtArgs>
            result: $Utils.Optional<InstantSessionCountAggregateOutputType> | number
          }
        }
      }
      InstantParticipant: {
        payload: Prisma.$InstantParticipantPayload<ExtArgs>
        fields: Prisma.InstantParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstantParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstantParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>
          }
          findFirst: {
            args: Prisma.InstantParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstantParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>
          }
          findMany: {
            args: Prisma.InstantParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>[]
          }
          create: {
            args: Prisma.InstantParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>
          }
          createMany: {
            args: Prisma.InstantParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstantParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>[]
          }
          delete: {
            args: Prisma.InstantParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>
          }
          update: {
            args: Prisma.InstantParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>
          }
          deleteMany: {
            args: Prisma.InstantParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstantParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstantParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>[]
          }
          upsert: {
            args: Prisma.InstantParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantParticipantPayload>
          }
          aggregate: {
            args: Prisma.InstantParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstantParticipant>
          }
          groupBy: {
            args: Prisma.InstantParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstantParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstantParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<InstantParticipantCountAggregateOutputType> | number
          }
        }
      }
      DailyLeaderboard: {
        payload: Prisma.$DailyLeaderboardPayload<ExtArgs>
        fields: Prisma.DailyLeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyLeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyLeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>
          }
          findFirst: {
            args: Prisma.DailyLeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyLeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>
          }
          findMany: {
            args: Prisma.DailyLeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>[]
          }
          create: {
            args: Prisma.DailyLeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>
          }
          createMany: {
            args: Prisma.DailyLeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyLeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>[]
          }
          delete: {
            args: Prisma.DailyLeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>
          }
          update: {
            args: Prisma.DailyLeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.DailyLeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyLeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyLeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.DailyLeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyLeaderboardPayload>
          }
          aggregate: {
            args: Prisma.DailyLeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyLeaderboard>
          }
          groupBy: {
            args: Prisma.DailyLeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyLeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyLeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<DailyLeaderboardCountAggregateOutputType> | number
          }
        }
      }
      InstantLeaderboard: {
        payload: Prisma.$InstantLeaderboardPayload<ExtArgs>
        fields: Prisma.InstantLeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstantLeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstantLeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>
          }
          findFirst: {
            args: Prisma.InstantLeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstantLeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>
          }
          findMany: {
            args: Prisma.InstantLeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>[]
          }
          create: {
            args: Prisma.InstantLeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>
          }
          createMany: {
            args: Prisma.InstantLeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstantLeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>[]
          }
          delete: {
            args: Prisma.InstantLeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>
          }
          update: {
            args: Prisma.InstantLeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.InstantLeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstantLeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstantLeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.InstantLeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstantLeaderboardPayload>
          }
          aggregate: {
            args: Prisma.InstantLeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstantLeaderboard>
          }
          groupBy: {
            args: Prisma.InstantLeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstantLeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstantLeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<InstantLeaderboardCountAggregateOutputType> | number
          }
        }
      }
      DailyUserLeaderboard: {
        payload: Prisma.$DailyUserLeaderboardPayload<ExtArgs>
        fields: Prisma.DailyUserLeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyUserLeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyUserLeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>
          }
          findFirst: {
            args: Prisma.DailyUserLeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyUserLeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>
          }
          findMany: {
            args: Prisma.DailyUserLeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>[]
          }
          create: {
            args: Prisma.DailyUserLeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>
          }
          createMany: {
            args: Prisma.DailyUserLeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyUserLeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>[]
          }
          delete: {
            args: Prisma.DailyUserLeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>
          }
          update: {
            args: Prisma.DailyUserLeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.DailyUserLeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyUserLeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyUserLeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.DailyUserLeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyUserLeaderboardPayload>
          }
          aggregate: {
            args: Prisma.DailyUserLeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyUserLeaderboard>
          }
          groupBy: {
            args: Prisma.DailyUserLeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyUserLeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyUserLeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<DailyUserLeaderboardCountAggregateOutputType> | number
          }
        }
      }
      SoloLeaderboard: {
        payload: Prisma.$SoloLeaderboardPayload<ExtArgs>
        fields: Prisma.SoloLeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SoloLeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SoloLeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>
          }
          findFirst: {
            args: Prisma.SoloLeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SoloLeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>
          }
          findMany: {
            args: Prisma.SoloLeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>[]
          }
          create: {
            args: Prisma.SoloLeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>
          }
          createMany: {
            args: Prisma.SoloLeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SoloLeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>[]
          }
          delete: {
            args: Prisma.SoloLeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>
          }
          update: {
            args: Prisma.SoloLeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.SoloLeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SoloLeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SoloLeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.SoloLeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SoloLeaderboardPayload>
          }
          aggregate: {
            args: Prisma.SoloLeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoloLeaderboard>
          }
          groupBy: {
            args: Prisma.SoloLeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoloLeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.SoloLeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<SoloLeaderboardCountAggregateOutputType> | number
          }
        }
      }
      RewardClaim: {
        payload: Prisma.$RewardClaimPayload<ExtArgs>
        fields: Prisma.RewardClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>
          }
          findFirst: {
            args: Prisma.RewardClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>
          }
          findMany: {
            args: Prisma.RewardClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>[]
          }
          create: {
            args: Prisma.RewardClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>
          }
          createMany: {
            args: Prisma.RewardClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>[]
          }
          delete: {
            args: Prisma.RewardClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>
          }
          update: {
            args: Prisma.RewardClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>
          }
          deleteMany: {
            args: Prisma.RewardClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>[]
          }
          upsert: {
            args: Prisma.RewardClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimPayload>
          }
          aggregate: {
            args: Prisma.RewardClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardClaim>
          }
          groupBy: {
            args: Prisma.RewardClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardClaimCountArgs<ExtArgs>
            result: $Utils.Optional<RewardClaimCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      CoinLedger: {
        payload: Prisma.$CoinLedgerPayload<ExtArgs>
        fields: Prisma.CoinLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoinLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoinLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>
          }
          findFirst: {
            args: Prisma.CoinLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoinLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>
          }
          findMany: {
            args: Prisma.CoinLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>[]
          }
          create: {
            args: Prisma.CoinLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>
          }
          createMany: {
            args: Prisma.CoinLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoinLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>[]
          }
          delete: {
            args: Prisma.CoinLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>
          }
          update: {
            args: Prisma.CoinLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>
          }
          deleteMany: {
            args: Prisma.CoinLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoinLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoinLedgerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>[]
          }
          upsert: {
            args: Prisma.CoinLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinLedgerPayload>
          }
          aggregate: {
            args: Prisma.CoinLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoinLedger>
          }
          groupBy: {
            args: Prisma.CoinLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoinLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoinLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<CoinLedgerCountAggregateOutputType> | number
          }
        }
      }
      GameConfig: {
        payload: Prisma.$GameConfigPayload<ExtArgs>
        fields: Prisma.GameConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          findFirst: {
            args: Prisma.GameConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          findMany: {
            args: Prisma.GameConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>[]
          }
          create: {
            args: Prisma.GameConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          createMany: {
            args: Prisma.GameConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>[]
          }
          delete: {
            args: Prisma.GameConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          update: {
            args: Prisma.GameConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          deleteMany: {
            args: Prisma.GameConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>[]
          }
          upsert: {
            args: Prisma.GameConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameConfigPayload>
          }
          aggregate: {
            args: Prisma.GameConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameConfig>
          }
          groupBy: {
            args: Prisma.GameConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameConfigCountArgs<ExtArgs>
            result: $Utils.Optional<GameConfigCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    dailyTournament?: DailyTournamentOmit
    dailyTournamentSession?: DailyTournamentSessionOmit
    minuteSnapshot?: MinuteSnapshotOmit
    soloSession?: SoloSessionOmit
    questionAttempt?: QuestionAttemptOmit
    instantTournament?: InstantTournamentOmit
    instantSession?: InstantSessionOmit
    instantParticipant?: InstantParticipantOmit
    dailyLeaderboard?: DailyLeaderboardOmit
    instantLeaderboard?: InstantLeaderboardOmit
    dailyUserLeaderboard?: DailyUserLeaderboardOmit
    soloLeaderboard?: SoloLeaderboardOmit
    rewardClaim?: RewardClaimOmit
    referral?: ReferralOmit
    coinLedger?: CoinLedgerOmit
    gameConfig?: GameConfigOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    referrals: number
    dailySessions: number
    soloSessions: number
    instantSessions: number
    instantParticipant: number
    dailyLeaderBoards: number
    instantLeaderboard: number
    rewardClaim: number
    referralsGiven: number
    referralsReceived: number
    coinLedger: number
    dailyUserLeaderboard: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    dailySessions?: boolean | UserCountOutputTypeCountDailySessionsArgs
    soloSessions?: boolean | UserCountOutputTypeCountSoloSessionsArgs
    instantSessions?: boolean | UserCountOutputTypeCountInstantSessionsArgs
    instantParticipant?: boolean | UserCountOutputTypeCountInstantParticipantArgs
    dailyLeaderBoards?: boolean | UserCountOutputTypeCountDailyLeaderBoardsArgs
    instantLeaderboard?: boolean | UserCountOutputTypeCountInstantLeaderboardArgs
    rewardClaim?: boolean | UserCountOutputTypeCountRewardClaimArgs
    referralsGiven?: boolean | UserCountOutputTypeCountReferralsGivenArgs
    referralsReceived?: boolean | UserCountOutputTypeCountReferralsReceivedArgs
    coinLedger?: boolean | UserCountOutputTypeCountCoinLedgerArgs
    dailyUserLeaderboard?: boolean | UserCountOutputTypeCountDailyUserLeaderboardArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyTournamentSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSoloSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoloSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstantSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstantParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyLeaderBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyLeaderboardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstantLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantLeaderboardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRewardClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardClaimWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoinLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoinLedgerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyUserLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyUserLeaderboardWhereInput
  }


  /**
   * Count Type DailyTournamentCountOutputType
   */

  export type DailyTournamentCountOutputType = {
    minuteSnapshot: number
    sessions: number
  }

  export type DailyTournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    minuteSnapshot?: boolean | DailyTournamentCountOutputTypeCountMinuteSnapshotArgs
    sessions?: boolean | DailyTournamentCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * DailyTournamentCountOutputType without action
   */
  export type DailyTournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentCountOutputType
     */
    select?: DailyTournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DailyTournamentCountOutputType without action
   */
  export type DailyTournamentCountOutputTypeCountMinuteSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinuteSnapshotWhereInput
  }

  /**
   * DailyTournamentCountOutputType without action
   */
  export type DailyTournamentCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyTournamentSessionWhereInput
  }


  /**
   * Count Type DailyTournamentSessionCountOutputType
   */

  export type DailyTournamentSessionCountOutputType = {
    questions: number
  }

  export type DailyTournamentSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | DailyTournamentSessionCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * DailyTournamentSessionCountOutputType without action
   */
  export type DailyTournamentSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSessionCountOutputType
     */
    select?: DailyTournamentSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DailyTournamentSessionCountOutputType without action
   */
  export type DailyTournamentSessionCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAttemptWhereInput
  }


  /**
   * Count Type SoloSessionCountOutputType
   */

  export type SoloSessionCountOutputType = {
    questions: number
  }

  export type SoloSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | SoloSessionCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * SoloSessionCountOutputType without action
   */
  export type SoloSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSessionCountOutputType
     */
    select?: SoloSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SoloSessionCountOutputType without action
   */
  export type SoloSessionCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAttemptWhereInput
  }


  /**
   * Count Type InstantTournamentCountOutputType
   */

  export type InstantTournamentCountOutputType = {
    sessions: number
    instantParticipant: number
  }

  export type InstantTournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | InstantTournamentCountOutputTypeCountSessionsArgs
    instantParticipant?: boolean | InstantTournamentCountOutputTypeCountInstantParticipantArgs
  }

  // Custom InputTypes
  /**
   * InstantTournamentCountOutputType without action
   */
  export type InstantTournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournamentCountOutputType
     */
    select?: InstantTournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstantTournamentCountOutputType without action
   */
  export type InstantTournamentCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantSessionWhereInput
  }

  /**
   * InstantTournamentCountOutputType without action
   */
  export type InstantTournamentCountOutputTypeCountInstantParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantParticipantWhereInput
  }


  /**
   * Count Type InstantSessionCountOutputType
   */

  export type InstantSessionCountOutputType = {
    questions: number
  }

  export type InstantSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | InstantSessionCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * InstantSessionCountOutputType without action
   */
  export type InstantSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSessionCountOutputType
     */
    select?: InstantSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstantSessionCountOutputType without action
   */
  export type InstantSessionCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAttemptWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    coins: number | null
    lifetimeCoins: number | null
    lifetimeCoinPoints: number | null
    level: number | null
    soloAttemptCount: number | null
    instantAttemptCount: number | null
    dailyAttemptCount: number | null
    currentLoginStreak: number | null
    longestLoginStreak: number | null
    totalLoginDays: number | null
  }

  export type UserSumAggregateOutputType = {
    coins: number | null
    lifetimeCoins: number | null
    lifetimeCoinPoints: number | null
    level: number | null
    soloAttemptCount: number | null
    instantAttemptCount: number | null
    dailyAttemptCount: number | null
    currentLoginStreak: number | null
    longestLoginStreak: number | null
    totalLoginDays: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phoneNumber: string | null
    googleId: string | null
    email: string | null
    deviceHash: string | null
    username: string | null
    usernameReservedAt: Date | null
    avatarType: $Enums.AvatarType | null
    profilePictureUrl: string | null
    coins: number | null
    lifetimeCoins: number | null
    lifetimeCoinPoints: number | null
    level: number | null
    theme: $Enums.Theme | null
    soundEnabled: boolean | null
    hapticsEnabled: boolean | null
    language: string | null
    referralCode: string | null
    referredById: string | null
    referralRewarded: boolean | null
    role: $Enums.Role | null
    soloAttemptCount: number | null
    instantAttemptCount: number | null
    dailyAttemptCount: number | null
    currentLoginStreak: number | null
    longestLoginStreak: number | null
    lastLoginRewardDate: Date | null
    totalLoginDays: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    phoneNumber: string | null
    googleId: string | null
    email: string | null
    deviceHash: string | null
    username: string | null
    usernameReservedAt: Date | null
    avatarType: $Enums.AvatarType | null
    profilePictureUrl: string | null
    coins: number | null
    lifetimeCoins: number | null
    lifetimeCoinPoints: number | null
    level: number | null
    theme: $Enums.Theme | null
    soundEnabled: boolean | null
    hapticsEnabled: boolean | null
    language: string | null
    referralCode: string | null
    referredById: string | null
    referralRewarded: boolean | null
    role: $Enums.Role | null
    soloAttemptCount: number | null
    instantAttemptCount: number | null
    dailyAttemptCount: number | null
    currentLoginStreak: number | null
    longestLoginStreak: number | null
    lastLoginRewardDate: Date | null
    totalLoginDays: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    phoneNumber: number
    googleId: number
    email: number
    deviceHash: number
    username: number
    usernameReservedAt: number
    avatarType: number
    profilePictureUrl: number
    coins: number
    lifetimeCoins: number
    lifetimeCoinPoints: number
    level: number
    theme: number
    soundEnabled: number
    hapticsEnabled: number
    language: number
    referralCode: number
    referredById: number
    referralRewarded: number
    role: number
    soloAttemptCount: number
    instantAttemptCount: number
    dailyAttemptCount: number
    currentLoginStreak: number
    longestLoginStreak: number
    lastLoginRewardDate: number
    totalLoginDays: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    coins?: true
    lifetimeCoins?: true
    lifetimeCoinPoints?: true
    level?: true
    soloAttemptCount?: true
    instantAttemptCount?: true
    dailyAttemptCount?: true
    currentLoginStreak?: true
    longestLoginStreak?: true
    totalLoginDays?: true
  }

  export type UserSumAggregateInputType = {
    coins?: true
    lifetimeCoins?: true
    lifetimeCoinPoints?: true
    level?: true
    soloAttemptCount?: true
    instantAttemptCount?: true
    dailyAttemptCount?: true
    currentLoginStreak?: true
    longestLoginStreak?: true
    totalLoginDays?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    googleId?: true
    email?: true
    deviceHash?: true
    username?: true
    usernameReservedAt?: true
    avatarType?: true
    profilePictureUrl?: true
    coins?: true
    lifetimeCoins?: true
    lifetimeCoinPoints?: true
    level?: true
    theme?: true
    soundEnabled?: true
    hapticsEnabled?: true
    language?: true
    referralCode?: true
    referredById?: true
    referralRewarded?: true
    role?: true
    soloAttemptCount?: true
    instantAttemptCount?: true
    dailyAttemptCount?: true
    currentLoginStreak?: true
    longestLoginStreak?: true
    lastLoginRewardDate?: true
    totalLoginDays?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    googleId?: true
    email?: true
    deviceHash?: true
    username?: true
    usernameReservedAt?: true
    avatarType?: true
    profilePictureUrl?: true
    coins?: true
    lifetimeCoins?: true
    lifetimeCoinPoints?: true
    level?: true
    theme?: true
    soundEnabled?: true
    hapticsEnabled?: true
    language?: true
    referralCode?: true
    referredById?: true
    referralRewarded?: true
    role?: true
    soloAttemptCount?: true
    instantAttemptCount?: true
    dailyAttemptCount?: true
    currentLoginStreak?: true
    longestLoginStreak?: true
    lastLoginRewardDate?: true
    totalLoginDays?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    phoneNumber?: true
    googleId?: true
    email?: true
    deviceHash?: true
    username?: true
    usernameReservedAt?: true
    avatarType?: true
    profilePictureUrl?: true
    coins?: true
    lifetimeCoins?: true
    lifetimeCoinPoints?: true
    level?: true
    theme?: true
    soundEnabled?: true
    hapticsEnabled?: true
    language?: true
    referralCode?: true
    referredById?: true
    referralRewarded?: true
    role?: true
    soloAttemptCount?: true
    instantAttemptCount?: true
    dailyAttemptCount?: true
    currentLoginStreak?: true
    longestLoginStreak?: true
    lastLoginRewardDate?: true
    totalLoginDays?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    phoneNumber: string | null
    googleId: string | null
    email: string | null
    deviceHash: string | null
    username: string
    usernameReservedAt: Date | null
    avatarType: $Enums.AvatarType
    profilePictureUrl: string | null
    coins: number
    lifetimeCoins: number
    lifetimeCoinPoints: number
    level: number
    theme: $Enums.Theme
    soundEnabled: boolean
    hapticsEnabled: boolean
    language: string
    referralCode: string | null
    referredById: string | null
    referralRewarded: boolean
    role: $Enums.Role
    soloAttemptCount: number
    instantAttemptCount: number
    dailyAttemptCount: number
    currentLoginStreak: number
    longestLoginStreak: number
    lastLoginRewardDate: Date | null
    totalLoginDays: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    googleId?: boolean
    email?: boolean
    deviceHash?: boolean
    username?: boolean
    usernameReservedAt?: boolean
    avatarType?: boolean
    profilePictureUrl?: boolean
    coins?: boolean
    lifetimeCoins?: boolean
    lifetimeCoinPoints?: boolean
    level?: boolean
    theme?: boolean
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: boolean
    referralCode?: boolean
    referredById?: boolean
    referralRewarded?: boolean
    role?: boolean
    soloAttemptCount?: boolean
    instantAttemptCount?: boolean
    dailyAttemptCount?: boolean
    currentLoginStreak?: boolean
    longestLoginStreak?: boolean
    lastLoginRewardDate?: boolean
    totalLoginDays?: boolean
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    dailySessions?: boolean | User$dailySessionsArgs<ExtArgs>
    soloSessions?: boolean | User$soloSessionsArgs<ExtArgs>
    instantSessions?: boolean | User$instantSessionsArgs<ExtArgs>
    instantParticipant?: boolean | User$instantParticipantArgs<ExtArgs>
    dailyLeaderBoards?: boolean | User$dailyLeaderBoardsArgs<ExtArgs>
    instantLeaderboard?: boolean | User$instantLeaderboardArgs<ExtArgs>
    rewardClaim?: boolean | User$rewardClaimArgs<ExtArgs>
    referralsGiven?: boolean | User$referralsGivenArgs<ExtArgs>
    referralsReceived?: boolean | User$referralsReceivedArgs<ExtArgs>
    coinLedger?: boolean | User$coinLedgerArgs<ExtArgs>
    dailyUserLeaderboard?: boolean | User$dailyUserLeaderboardArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    googleId?: boolean
    email?: boolean
    deviceHash?: boolean
    username?: boolean
    usernameReservedAt?: boolean
    avatarType?: boolean
    profilePictureUrl?: boolean
    coins?: boolean
    lifetimeCoins?: boolean
    lifetimeCoinPoints?: boolean
    level?: boolean
    theme?: boolean
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: boolean
    referralCode?: boolean
    referredById?: boolean
    referralRewarded?: boolean
    role?: boolean
    soloAttemptCount?: boolean
    instantAttemptCount?: boolean
    dailyAttemptCount?: boolean
    currentLoginStreak?: boolean
    longestLoginStreak?: boolean
    lastLoginRewardDate?: boolean
    totalLoginDays?: boolean
    referredBy?: boolean | User$referredByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    googleId?: boolean
    email?: boolean
    deviceHash?: boolean
    username?: boolean
    usernameReservedAt?: boolean
    avatarType?: boolean
    profilePictureUrl?: boolean
    coins?: boolean
    lifetimeCoins?: boolean
    lifetimeCoinPoints?: boolean
    level?: boolean
    theme?: boolean
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: boolean
    referralCode?: boolean
    referredById?: boolean
    referralRewarded?: boolean
    role?: boolean
    soloAttemptCount?: boolean
    instantAttemptCount?: boolean
    dailyAttemptCount?: boolean
    currentLoginStreak?: boolean
    longestLoginStreak?: boolean
    lastLoginRewardDate?: boolean
    totalLoginDays?: boolean
    referredBy?: boolean | User$referredByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phoneNumber?: boolean
    googleId?: boolean
    email?: boolean
    deviceHash?: boolean
    username?: boolean
    usernameReservedAt?: boolean
    avatarType?: boolean
    profilePictureUrl?: boolean
    coins?: boolean
    lifetimeCoins?: boolean
    lifetimeCoinPoints?: boolean
    level?: boolean
    theme?: boolean
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: boolean
    referralCode?: boolean
    referredById?: boolean
    referralRewarded?: boolean
    role?: boolean
    soloAttemptCount?: boolean
    instantAttemptCount?: boolean
    dailyAttemptCount?: boolean
    currentLoginStreak?: boolean
    longestLoginStreak?: boolean
    lastLoginRewardDate?: boolean
    totalLoginDays?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "phoneNumber" | "googleId" | "email" | "deviceHash" | "username" | "usernameReservedAt" | "avatarType" | "profilePictureUrl" | "coins" | "lifetimeCoins" | "lifetimeCoinPoints" | "level" | "theme" | "soundEnabled" | "hapticsEnabled" | "language" | "referralCode" | "referredById" | "referralRewarded" | "role" | "soloAttemptCount" | "instantAttemptCount" | "dailyAttemptCount" | "currentLoginStreak" | "longestLoginStreak" | "lastLoginRewardDate" | "totalLoginDays", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    dailySessions?: boolean | User$dailySessionsArgs<ExtArgs>
    soloSessions?: boolean | User$soloSessionsArgs<ExtArgs>
    instantSessions?: boolean | User$instantSessionsArgs<ExtArgs>
    instantParticipant?: boolean | User$instantParticipantArgs<ExtArgs>
    dailyLeaderBoards?: boolean | User$dailyLeaderBoardsArgs<ExtArgs>
    instantLeaderboard?: boolean | User$instantLeaderboardArgs<ExtArgs>
    rewardClaim?: boolean | User$rewardClaimArgs<ExtArgs>
    referralsGiven?: boolean | User$referralsGivenArgs<ExtArgs>
    referralsReceived?: boolean | User$referralsReceivedArgs<ExtArgs>
    coinLedger?: boolean | User$coinLedgerArgs<ExtArgs>
    dailyUserLeaderboard?: boolean | User$dailyUserLeaderboardArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referredBy?: boolean | User$referredByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referredBy?: boolean | User$referredByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      referredBy: Prisma.$UserPayload<ExtArgs> | null
      referrals: Prisma.$UserPayload<ExtArgs>[]
      dailySessions: Prisma.$DailyTournamentSessionPayload<ExtArgs>[]
      soloSessions: Prisma.$SoloSessionPayload<ExtArgs>[]
      instantSessions: Prisma.$InstantSessionPayload<ExtArgs>[]
      instantParticipant: Prisma.$InstantParticipantPayload<ExtArgs>[]
      dailyLeaderBoards: Prisma.$DailyLeaderboardPayload<ExtArgs>[]
      instantLeaderboard: Prisma.$InstantLeaderboardPayload<ExtArgs>[]
      rewardClaim: Prisma.$RewardClaimPayload<ExtArgs>[]
      referralsGiven: Prisma.$ReferralPayload<ExtArgs>[]
      referralsReceived: Prisma.$ReferralPayload<ExtArgs>[]
      coinLedger: Prisma.$CoinLedgerPayload<ExtArgs>[]
      dailyUserLeaderboard: Prisma.$DailyUserLeaderboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      phoneNumber: string | null
      googleId: string | null
      email: string | null
      deviceHash: string | null
      username: string
      usernameReservedAt: Date | null
      avatarType: $Enums.AvatarType
      profilePictureUrl: string | null
      coins: number
      lifetimeCoins: number
      lifetimeCoinPoints: number
      level: number
      theme: $Enums.Theme
      soundEnabled: boolean
      hapticsEnabled: boolean
      language: string
      referralCode: string | null
      referredById: string | null
      referralRewarded: boolean
      role: $Enums.Role
      soloAttemptCount: number
      instantAttemptCount: number
      dailyAttemptCount: number
      currentLoginStreak: number
      longestLoginStreak: number
      lastLoginRewardDate: Date | null
      totalLoginDays: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referredBy<T extends User$referredByArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailySessions<T extends User$dailySessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailySessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soloSessions<T extends User$soloSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$soloSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instantSessions<T extends User$instantSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$instantSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instantParticipant<T extends User$instantParticipantArgs<ExtArgs> = {}>(args?: Subset<T, User$instantParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyLeaderBoards<T extends User$dailyLeaderBoardsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyLeaderBoardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instantLeaderboard<T extends User$instantLeaderboardArgs<ExtArgs> = {}>(args?: Subset<T, User$instantLeaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewardClaim<T extends User$rewardClaimArgs<ExtArgs> = {}>(args?: Subset<T, User$rewardClaimArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsGiven<T extends User$referralsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsReceived<T extends User$referralsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coinLedger<T extends User$coinLedgerArgs<ExtArgs> = {}>(args?: Subset<T, User$coinLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dailyUserLeaderboard<T extends User$dailyUserLeaderboardArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyUserLeaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly deviceHash: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly usernameReservedAt: FieldRef<"User", 'DateTime'>
    readonly avatarType: FieldRef<"User", 'AvatarType'>
    readonly profilePictureUrl: FieldRef<"User", 'String'>
    readonly coins: FieldRef<"User", 'Int'>
    readonly lifetimeCoins: FieldRef<"User", 'Int'>
    readonly lifetimeCoinPoints: FieldRef<"User", 'Int'>
    readonly level: FieldRef<"User", 'Int'>
    readonly theme: FieldRef<"User", 'Theme'>
    readonly soundEnabled: FieldRef<"User", 'Boolean'>
    readonly hapticsEnabled: FieldRef<"User", 'Boolean'>
    readonly language: FieldRef<"User", 'String'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly referredById: FieldRef<"User", 'String'>
    readonly referralRewarded: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'Role'>
    readonly soloAttemptCount: FieldRef<"User", 'Int'>
    readonly instantAttemptCount: FieldRef<"User", 'Int'>
    readonly dailyAttemptCount: FieldRef<"User", 'Int'>
    readonly currentLoginStreak: FieldRef<"User", 'Int'>
    readonly longestLoginStreak: FieldRef<"User", 'Int'>
    readonly lastLoginRewardDate: FieldRef<"User", 'DateTime'>
    readonly totalLoginDays: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.referredBy
   */
  export type User$referredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.dailySessions
   */
  export type User$dailySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    where?: DailyTournamentSessionWhereInput
    orderBy?: DailyTournamentSessionOrderByWithRelationInput | DailyTournamentSessionOrderByWithRelationInput[]
    cursor?: DailyTournamentSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyTournamentSessionScalarFieldEnum | DailyTournamentSessionScalarFieldEnum[]
  }

  /**
   * User.soloSessions
   */
  export type User$soloSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    where?: SoloSessionWhereInput
    orderBy?: SoloSessionOrderByWithRelationInput | SoloSessionOrderByWithRelationInput[]
    cursor?: SoloSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SoloSessionScalarFieldEnum | SoloSessionScalarFieldEnum[]
  }

  /**
   * User.instantSessions
   */
  export type User$instantSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    where?: InstantSessionWhereInput
    orderBy?: InstantSessionOrderByWithRelationInput | InstantSessionOrderByWithRelationInput[]
    cursor?: InstantSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstantSessionScalarFieldEnum | InstantSessionScalarFieldEnum[]
  }

  /**
   * User.instantParticipant
   */
  export type User$instantParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    where?: InstantParticipantWhereInput
    orderBy?: InstantParticipantOrderByWithRelationInput | InstantParticipantOrderByWithRelationInput[]
    cursor?: InstantParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstantParticipantScalarFieldEnum | InstantParticipantScalarFieldEnum[]
  }

  /**
   * User.dailyLeaderBoards
   */
  export type User$dailyLeaderBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    where?: DailyLeaderboardWhereInput
    orderBy?: DailyLeaderboardOrderByWithRelationInput | DailyLeaderboardOrderByWithRelationInput[]
    cursor?: DailyLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyLeaderboardScalarFieldEnum | DailyLeaderboardScalarFieldEnum[]
  }

  /**
   * User.instantLeaderboard
   */
  export type User$instantLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    where?: InstantLeaderboardWhereInput
    orderBy?: InstantLeaderboardOrderByWithRelationInput | InstantLeaderboardOrderByWithRelationInput[]
    cursor?: InstantLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstantLeaderboardScalarFieldEnum | InstantLeaderboardScalarFieldEnum[]
  }

  /**
   * User.rewardClaim
   */
  export type User$rewardClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    where?: RewardClaimWhereInput
    orderBy?: RewardClaimOrderByWithRelationInput | RewardClaimOrderByWithRelationInput[]
    cursor?: RewardClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardClaimScalarFieldEnum | RewardClaimScalarFieldEnum[]
  }

  /**
   * User.referralsGiven
   */
  export type User$referralsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referralsReceived
   */
  export type User$referralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.coinLedger
   */
  export type User$coinLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    where?: CoinLedgerWhereInput
    orderBy?: CoinLedgerOrderByWithRelationInput | CoinLedgerOrderByWithRelationInput[]
    cursor?: CoinLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoinLedgerScalarFieldEnum | CoinLedgerScalarFieldEnum[]
  }

  /**
   * User.dailyUserLeaderboard
   */
  export type User$dailyUserLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    where?: DailyUserLeaderboardWhereInput
    orderBy?: DailyUserLeaderboardOrderByWithRelationInput | DailyUserLeaderboardOrderByWithRelationInput[]
    cursor?: DailyUserLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyUserLeaderboardScalarFieldEnum | DailyUserLeaderboardScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model DailyTournament
   */

  export type AggregateDailyTournament = {
    _count: DailyTournamentCountAggregateOutputType | null
    _min: DailyTournamentMinAggregateOutputType | null
    _max: DailyTournamentMaxAggregateOutputType | null
  }

  export type DailyTournamentMinAggregateOutputType = {
    id: string | null
    date: Date | null
    createdAt: Date | null
    status: $Enums.TournamentStatus | null
    configVersion: string | null
  }

  export type DailyTournamentMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    createdAt: Date | null
    status: $Enums.TournamentStatus | null
    configVersion: string | null
  }

  export type DailyTournamentCountAggregateOutputType = {
    id: number
    date: number
    createdAt: number
    status: number
    configVersion: number
    final: number
    _all: number
  }


  export type DailyTournamentMinAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    status?: true
    configVersion?: true
  }

  export type DailyTournamentMaxAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    status?: true
    configVersion?: true
  }

  export type DailyTournamentCountAggregateInputType = {
    id?: true
    date?: true
    createdAt?: true
    status?: true
    configVersion?: true
    final?: true
    _all?: true
  }

  export type DailyTournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyTournament to aggregate.
     */
    where?: DailyTournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTournaments to fetch.
     */
    orderBy?: DailyTournamentOrderByWithRelationInput | DailyTournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyTournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyTournaments
    **/
    _count?: true | DailyTournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyTournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyTournamentMaxAggregateInputType
  }

  export type GetDailyTournamentAggregateType<T extends DailyTournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyTournament[P]>
      : GetScalarType<T[P], AggregateDailyTournament[P]>
  }




  export type DailyTournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyTournamentWhereInput
    orderBy?: DailyTournamentOrderByWithAggregationInput | DailyTournamentOrderByWithAggregationInput[]
    by: DailyTournamentScalarFieldEnum[] | DailyTournamentScalarFieldEnum
    having?: DailyTournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyTournamentCountAggregateInputType | true
    _min?: DailyTournamentMinAggregateInputType
    _max?: DailyTournamentMaxAggregateInputType
  }

  export type DailyTournamentGroupByOutputType = {
    id: string
    date: Date
    createdAt: Date
    status: $Enums.TournamentStatus
    configVersion: string | null
    final: JsonValue
    _count: DailyTournamentCountAggregateOutputType | null
    _min: DailyTournamentMinAggregateOutputType | null
    _max: DailyTournamentMaxAggregateOutputType | null
  }

  type GetDailyTournamentGroupByPayload<T extends DailyTournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyTournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyTournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyTournamentGroupByOutputType[P]>
            : GetScalarType<T[P], DailyTournamentGroupByOutputType[P]>
        }
      >
    >


  export type DailyTournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    status?: boolean
    configVersion?: boolean
    final?: boolean
    minuteSnapshot?: boolean | DailyTournament$minuteSnapshotArgs<ExtArgs>
    sessions?: boolean | DailyTournament$sessionsArgs<ExtArgs>
    _count?: boolean | DailyTournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyTournament"]>

  export type DailyTournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    status?: boolean
    configVersion?: boolean
    final?: boolean
  }, ExtArgs["result"]["dailyTournament"]>

  export type DailyTournamentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    createdAt?: boolean
    status?: boolean
    configVersion?: boolean
    final?: boolean
  }, ExtArgs["result"]["dailyTournament"]>

  export type DailyTournamentSelectScalar = {
    id?: boolean
    date?: boolean
    createdAt?: boolean
    status?: boolean
    configVersion?: boolean
    final?: boolean
  }

  export type DailyTournamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "createdAt" | "status" | "configVersion" | "final", ExtArgs["result"]["dailyTournament"]>
  export type DailyTournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    minuteSnapshot?: boolean | DailyTournament$minuteSnapshotArgs<ExtArgs>
    sessions?: boolean | DailyTournament$sessionsArgs<ExtArgs>
    _count?: boolean | DailyTournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DailyTournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DailyTournamentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DailyTournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyTournament"
    objects: {
      minuteSnapshot: Prisma.$MinuteSnapshotPayload<ExtArgs>[]
      sessions: Prisma.$DailyTournamentSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      createdAt: Date
      status: $Enums.TournamentStatus
      configVersion: string | null
      final: Prisma.JsonValue
    }, ExtArgs["result"]["dailyTournament"]>
    composites: {}
  }

  type DailyTournamentGetPayload<S extends boolean | null | undefined | DailyTournamentDefaultArgs> = $Result.GetResult<Prisma.$DailyTournamentPayload, S>

  type DailyTournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyTournamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyTournamentCountAggregateInputType | true
    }

  export interface DailyTournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyTournament'], meta: { name: 'DailyTournament' } }
    /**
     * Find zero or one DailyTournament that matches the filter.
     * @param {DailyTournamentFindUniqueArgs} args - Arguments to find a DailyTournament
     * @example
     * // Get one DailyTournament
     * const dailyTournament = await prisma.dailyTournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyTournamentFindUniqueArgs>(args: SelectSubset<T, DailyTournamentFindUniqueArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyTournament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyTournamentFindUniqueOrThrowArgs} args - Arguments to find a DailyTournament
     * @example
     * // Get one DailyTournament
     * const dailyTournament = await prisma.dailyTournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyTournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyTournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyTournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentFindFirstArgs} args - Arguments to find a DailyTournament
     * @example
     * // Get one DailyTournament
     * const dailyTournament = await prisma.dailyTournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyTournamentFindFirstArgs>(args?: SelectSubset<T, DailyTournamentFindFirstArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyTournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentFindFirstOrThrowArgs} args - Arguments to find a DailyTournament
     * @example
     * // Get one DailyTournament
     * const dailyTournament = await prisma.dailyTournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyTournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyTournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyTournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyTournaments
     * const dailyTournaments = await prisma.dailyTournament.findMany()
     * 
     * // Get first 10 DailyTournaments
     * const dailyTournaments = await prisma.dailyTournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyTournamentWithIdOnly = await prisma.dailyTournament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyTournamentFindManyArgs>(args?: SelectSubset<T, DailyTournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyTournament.
     * @param {DailyTournamentCreateArgs} args - Arguments to create a DailyTournament.
     * @example
     * // Create one DailyTournament
     * const DailyTournament = await prisma.dailyTournament.create({
     *   data: {
     *     // ... data to create a DailyTournament
     *   }
     * })
     * 
     */
    create<T extends DailyTournamentCreateArgs>(args: SelectSubset<T, DailyTournamentCreateArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyTournaments.
     * @param {DailyTournamentCreateManyArgs} args - Arguments to create many DailyTournaments.
     * @example
     * // Create many DailyTournaments
     * const dailyTournament = await prisma.dailyTournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyTournamentCreateManyArgs>(args?: SelectSubset<T, DailyTournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyTournaments and returns the data saved in the database.
     * @param {DailyTournamentCreateManyAndReturnArgs} args - Arguments to create many DailyTournaments.
     * @example
     * // Create many DailyTournaments
     * const dailyTournament = await prisma.dailyTournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyTournaments and only return the `id`
     * const dailyTournamentWithIdOnly = await prisma.dailyTournament.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyTournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyTournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyTournament.
     * @param {DailyTournamentDeleteArgs} args - Arguments to delete one DailyTournament.
     * @example
     * // Delete one DailyTournament
     * const DailyTournament = await prisma.dailyTournament.delete({
     *   where: {
     *     // ... filter to delete one DailyTournament
     *   }
     * })
     * 
     */
    delete<T extends DailyTournamentDeleteArgs>(args: SelectSubset<T, DailyTournamentDeleteArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyTournament.
     * @param {DailyTournamentUpdateArgs} args - Arguments to update one DailyTournament.
     * @example
     * // Update one DailyTournament
     * const dailyTournament = await prisma.dailyTournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyTournamentUpdateArgs>(args: SelectSubset<T, DailyTournamentUpdateArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyTournaments.
     * @param {DailyTournamentDeleteManyArgs} args - Arguments to filter DailyTournaments to delete.
     * @example
     * // Delete a few DailyTournaments
     * const { count } = await prisma.dailyTournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyTournamentDeleteManyArgs>(args?: SelectSubset<T, DailyTournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyTournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyTournaments
     * const dailyTournament = await prisma.dailyTournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyTournamentUpdateManyArgs>(args: SelectSubset<T, DailyTournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyTournaments and returns the data updated in the database.
     * @param {DailyTournamentUpdateManyAndReturnArgs} args - Arguments to update many DailyTournaments.
     * @example
     * // Update many DailyTournaments
     * const dailyTournament = await prisma.dailyTournament.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyTournaments and only return the `id`
     * const dailyTournamentWithIdOnly = await prisma.dailyTournament.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyTournamentUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyTournamentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyTournament.
     * @param {DailyTournamentUpsertArgs} args - Arguments to update or create a DailyTournament.
     * @example
     * // Update or create a DailyTournament
     * const dailyTournament = await prisma.dailyTournament.upsert({
     *   create: {
     *     // ... data to create a DailyTournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyTournament we want to update
     *   }
     * })
     */
    upsert<T extends DailyTournamentUpsertArgs>(args: SelectSubset<T, DailyTournamentUpsertArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyTournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentCountArgs} args - Arguments to filter DailyTournaments to count.
     * @example
     * // Count the number of DailyTournaments
     * const count = await prisma.dailyTournament.count({
     *   where: {
     *     // ... the filter for the DailyTournaments we want to count
     *   }
     * })
    **/
    count<T extends DailyTournamentCountArgs>(
      args?: Subset<T, DailyTournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyTournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyTournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyTournamentAggregateArgs>(args: Subset<T, DailyTournamentAggregateArgs>): Prisma.PrismaPromise<GetDailyTournamentAggregateType<T>>

    /**
     * Group by DailyTournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyTournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyTournamentGroupByArgs['orderBy'] }
        : { orderBy?: DailyTournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyTournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyTournament model
   */
  readonly fields: DailyTournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyTournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyTournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    minuteSnapshot<T extends DailyTournament$minuteSnapshotArgs<ExtArgs> = {}>(args?: Subset<T, DailyTournament$minuteSnapshotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends DailyTournament$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, DailyTournament$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyTournament model
   */
  interface DailyTournamentFieldRefs {
    readonly id: FieldRef<"DailyTournament", 'String'>
    readonly date: FieldRef<"DailyTournament", 'DateTime'>
    readonly createdAt: FieldRef<"DailyTournament", 'DateTime'>
    readonly status: FieldRef<"DailyTournament", 'TournamentStatus'>
    readonly configVersion: FieldRef<"DailyTournament", 'String'>
    readonly final: FieldRef<"DailyTournament", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * DailyTournament findUnique
   */
  export type DailyTournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournament to fetch.
     */
    where: DailyTournamentWhereUniqueInput
  }

  /**
   * DailyTournament findUniqueOrThrow
   */
  export type DailyTournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournament to fetch.
     */
    where: DailyTournamentWhereUniqueInput
  }

  /**
   * DailyTournament findFirst
   */
  export type DailyTournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournament to fetch.
     */
    where?: DailyTournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTournaments to fetch.
     */
    orderBy?: DailyTournamentOrderByWithRelationInput | DailyTournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyTournaments.
     */
    cursor?: DailyTournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyTournaments.
     */
    distinct?: DailyTournamentScalarFieldEnum | DailyTournamentScalarFieldEnum[]
  }

  /**
   * DailyTournament findFirstOrThrow
   */
  export type DailyTournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournament to fetch.
     */
    where?: DailyTournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTournaments to fetch.
     */
    orderBy?: DailyTournamentOrderByWithRelationInput | DailyTournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyTournaments.
     */
    cursor?: DailyTournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyTournaments.
     */
    distinct?: DailyTournamentScalarFieldEnum | DailyTournamentScalarFieldEnum[]
  }

  /**
   * DailyTournament findMany
   */
  export type DailyTournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournaments to fetch.
     */
    where?: DailyTournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTournaments to fetch.
     */
    orderBy?: DailyTournamentOrderByWithRelationInput | DailyTournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyTournaments.
     */
    cursor?: DailyTournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTournaments.
     */
    skip?: number
    distinct?: DailyTournamentScalarFieldEnum | DailyTournamentScalarFieldEnum[]
  }

  /**
   * DailyTournament create
   */
  export type DailyTournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyTournament.
     */
    data: XOR<DailyTournamentCreateInput, DailyTournamentUncheckedCreateInput>
  }

  /**
   * DailyTournament createMany
   */
  export type DailyTournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyTournaments.
     */
    data: DailyTournamentCreateManyInput | DailyTournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyTournament createManyAndReturn
   */
  export type DailyTournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * The data used to create many DailyTournaments.
     */
    data: DailyTournamentCreateManyInput | DailyTournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyTournament update
   */
  export type DailyTournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyTournament.
     */
    data: XOR<DailyTournamentUpdateInput, DailyTournamentUncheckedUpdateInput>
    /**
     * Choose, which DailyTournament to update.
     */
    where: DailyTournamentWhereUniqueInput
  }

  /**
   * DailyTournament updateMany
   */
  export type DailyTournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyTournaments.
     */
    data: XOR<DailyTournamentUpdateManyMutationInput, DailyTournamentUncheckedUpdateManyInput>
    /**
     * Filter which DailyTournaments to update
     */
    where?: DailyTournamentWhereInput
    /**
     * Limit how many DailyTournaments to update.
     */
    limit?: number
  }

  /**
   * DailyTournament updateManyAndReturn
   */
  export type DailyTournamentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * The data used to update DailyTournaments.
     */
    data: XOR<DailyTournamentUpdateManyMutationInput, DailyTournamentUncheckedUpdateManyInput>
    /**
     * Filter which DailyTournaments to update
     */
    where?: DailyTournamentWhereInput
    /**
     * Limit how many DailyTournaments to update.
     */
    limit?: number
  }

  /**
   * DailyTournament upsert
   */
  export type DailyTournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyTournament to update in case it exists.
     */
    where: DailyTournamentWhereUniqueInput
    /**
     * In case the DailyTournament found by the `where` argument doesn't exist, create a new DailyTournament with this data.
     */
    create: XOR<DailyTournamentCreateInput, DailyTournamentUncheckedCreateInput>
    /**
     * In case the DailyTournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyTournamentUpdateInput, DailyTournamentUncheckedUpdateInput>
  }

  /**
   * DailyTournament delete
   */
  export type DailyTournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
    /**
     * Filter which DailyTournament to delete.
     */
    where: DailyTournamentWhereUniqueInput
  }

  /**
   * DailyTournament deleteMany
   */
  export type DailyTournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyTournaments to delete
     */
    where?: DailyTournamentWhereInput
    /**
     * Limit how many DailyTournaments to delete.
     */
    limit?: number
  }

  /**
   * DailyTournament.minuteSnapshot
   */
  export type DailyTournament$minuteSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    where?: MinuteSnapshotWhereInput
    orderBy?: MinuteSnapshotOrderByWithRelationInput | MinuteSnapshotOrderByWithRelationInput[]
    cursor?: MinuteSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinuteSnapshotScalarFieldEnum | MinuteSnapshotScalarFieldEnum[]
  }

  /**
   * DailyTournament.sessions
   */
  export type DailyTournament$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    where?: DailyTournamentSessionWhereInput
    orderBy?: DailyTournamentSessionOrderByWithRelationInput | DailyTournamentSessionOrderByWithRelationInput[]
    cursor?: DailyTournamentSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyTournamentSessionScalarFieldEnum | DailyTournamentSessionScalarFieldEnum[]
  }

  /**
   * DailyTournament without action
   */
  export type DailyTournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournament
     */
    select?: DailyTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournament
     */
    omit?: DailyTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentInclude<ExtArgs> | null
  }


  /**
   * Model DailyTournamentSession
   */

  export type AggregateDailyTournamentSession = {
    _count: DailyTournamentSessionCountAggregateOutputType | null
    _avg: DailyTournamentSessionAvgAggregateOutputType | null
    _sum: DailyTournamentSessionSumAggregateOutputType | null
    _min: DailyTournamentSessionMinAggregateOutputType | null
    _max: DailyTournamentSessionMaxAggregateOutputType | null
  }

  export type DailyTournamentSessionAvgAggregateOutputType = {
    currentScore: number | null
    finalScore: number | null
    minute1Score: number | null
    minute2Score: number | null
    minute3Score: number | null
    minute4Score: number | null
    currentLevel: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
  }

  export type DailyTournamentSessionSumAggregateOutputType = {
    currentScore: number | null
    finalScore: number | null
    minute1Score: number | null
    minute2Score: number | null
    minute3Score: number | null
    minute4Score: number | null
    currentLevel: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
  }

  export type DailyTournamentSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    tournamentId: string | null
    sessionSeed: string | null
    startedAt: Date | null
    endedAt: Date | null
    status: $Enums.UserTournamentStatus | null
    currentScore: number | null
    finalScore: number | null
    minute1Score: number | null
    minute2Score: number | null
    minute3Score: number | null
    minute4Score: number | null
    isFreeAttempt: boolean | null
    isRewardedAttempt: boolean | null
    currentLevel: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
    endsAt: Date | null
  }

  export type DailyTournamentSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    tournamentId: string | null
    sessionSeed: string | null
    startedAt: Date | null
    endedAt: Date | null
    status: $Enums.UserTournamentStatus | null
    currentScore: number | null
    finalScore: number | null
    minute1Score: number | null
    minute2Score: number | null
    minute3Score: number | null
    minute4Score: number | null
    isFreeAttempt: boolean | null
    isRewardedAttempt: boolean | null
    currentLevel: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
    endsAt: Date | null
  }

  export type DailyTournamentSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    tournamentId: number
    sessionSeed: number
    startedAt: number
    endedAt: number
    status: number
    currentScore: number
    finalScore: number
    minute1Score: number
    minute2Score: number
    minute3Score: number
    minute4Score: number
    isFreeAttempt: number
    isRewardedAttempt: number
    currentLevel: number
    questionsAnswered: number
    correctAnswers: number
    endsAt: number
    _all: number
  }


  export type DailyTournamentSessionAvgAggregateInputType = {
    currentScore?: true
    finalScore?: true
    minute1Score?: true
    minute2Score?: true
    minute3Score?: true
    minute4Score?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
  }

  export type DailyTournamentSessionSumAggregateInputType = {
    currentScore?: true
    finalScore?: true
    minute1Score?: true
    minute2Score?: true
    minute3Score?: true
    minute4Score?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
  }

  export type DailyTournamentSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    tournamentId?: true
    sessionSeed?: true
    startedAt?: true
    endedAt?: true
    status?: true
    currentScore?: true
    finalScore?: true
    minute1Score?: true
    minute2Score?: true
    minute3Score?: true
    minute4Score?: true
    isFreeAttempt?: true
    isRewardedAttempt?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
    endsAt?: true
  }

  export type DailyTournamentSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    tournamentId?: true
    sessionSeed?: true
    startedAt?: true
    endedAt?: true
    status?: true
    currentScore?: true
    finalScore?: true
    minute1Score?: true
    minute2Score?: true
    minute3Score?: true
    minute4Score?: true
    isFreeAttempt?: true
    isRewardedAttempt?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
    endsAt?: true
  }

  export type DailyTournamentSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    tournamentId?: true
    sessionSeed?: true
    startedAt?: true
    endedAt?: true
    status?: true
    currentScore?: true
    finalScore?: true
    minute1Score?: true
    minute2Score?: true
    minute3Score?: true
    minute4Score?: true
    isFreeAttempt?: true
    isRewardedAttempt?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
    endsAt?: true
    _all?: true
  }

  export type DailyTournamentSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyTournamentSession to aggregate.
     */
    where?: DailyTournamentSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTournamentSessions to fetch.
     */
    orderBy?: DailyTournamentSessionOrderByWithRelationInput | DailyTournamentSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyTournamentSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTournamentSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTournamentSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyTournamentSessions
    **/
    _count?: true | DailyTournamentSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyTournamentSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyTournamentSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyTournamentSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyTournamentSessionMaxAggregateInputType
  }

  export type GetDailyTournamentSessionAggregateType<T extends DailyTournamentSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyTournamentSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyTournamentSession[P]>
      : GetScalarType<T[P], AggregateDailyTournamentSession[P]>
  }




  export type DailyTournamentSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyTournamentSessionWhereInput
    orderBy?: DailyTournamentSessionOrderByWithAggregationInput | DailyTournamentSessionOrderByWithAggregationInput[]
    by: DailyTournamentSessionScalarFieldEnum[] | DailyTournamentSessionScalarFieldEnum
    having?: DailyTournamentSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyTournamentSessionCountAggregateInputType | true
    _avg?: DailyTournamentSessionAvgAggregateInputType
    _sum?: DailyTournamentSessionSumAggregateInputType
    _min?: DailyTournamentSessionMinAggregateInputType
    _max?: DailyTournamentSessionMaxAggregateInputType
  }

  export type DailyTournamentSessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    tournamentId: string
    sessionSeed: string
    startedAt: Date
    endedAt: Date | null
    status: $Enums.UserTournamentStatus
    currentScore: number
    finalScore: number | null
    minute1Score: number | null
    minute2Score: number | null
    minute3Score: number | null
    minute4Score: number | null
    isFreeAttempt: boolean
    isRewardedAttempt: boolean
    currentLevel: number
    questionsAnswered: number
    correctAnswers: number
    endsAt: Date
    _count: DailyTournamentSessionCountAggregateOutputType | null
    _avg: DailyTournamentSessionAvgAggregateOutputType | null
    _sum: DailyTournamentSessionSumAggregateOutputType | null
    _min: DailyTournamentSessionMinAggregateOutputType | null
    _max: DailyTournamentSessionMaxAggregateOutputType | null
  }

  type GetDailyTournamentSessionGroupByPayload<T extends DailyTournamentSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyTournamentSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyTournamentSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyTournamentSessionGroupByOutputType[P]>
            : GetScalarType<T[P], DailyTournamentSessionGroupByOutputType[P]>
        }
      >
    >


  export type DailyTournamentSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    sessionSeed?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    currentScore?: boolean
    finalScore?: boolean
    minute1Score?: boolean
    minute2Score?: boolean
    minute3Score?: boolean
    minute4Score?: boolean
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    endsAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
    questions?: boolean | DailyTournamentSession$questionsArgs<ExtArgs>
    _count?: boolean | DailyTournamentSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyTournamentSession"]>

  export type DailyTournamentSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    sessionSeed?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    currentScore?: boolean
    finalScore?: boolean
    minute1Score?: boolean
    minute2Score?: boolean
    minute3Score?: boolean
    minute4Score?: boolean
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    endsAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyTournamentSession"]>

  export type DailyTournamentSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    sessionSeed?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    currentScore?: boolean
    finalScore?: boolean
    minute1Score?: boolean
    minute2Score?: boolean
    minute3Score?: boolean
    minute4Score?: boolean
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    endsAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyTournamentSession"]>

  export type DailyTournamentSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    sessionSeed?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    currentScore?: boolean
    finalScore?: boolean
    minute1Score?: boolean
    minute2Score?: boolean
    minute3Score?: boolean
    minute4Score?: boolean
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    endsAt?: boolean
  }

  export type DailyTournamentSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "userId" | "tournamentId" | "sessionSeed" | "startedAt" | "endedAt" | "status" | "currentScore" | "finalScore" | "minute1Score" | "minute2Score" | "minute3Score" | "minute4Score" | "isFreeAttempt" | "isRewardedAttempt" | "currentLevel" | "questionsAnswered" | "correctAnswers" | "endsAt", ExtArgs["result"]["dailyTournamentSession"]>
  export type DailyTournamentSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
    questions?: boolean | DailyTournamentSession$questionsArgs<ExtArgs>
    _count?: boolean | DailyTournamentSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DailyTournamentSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }
  export type DailyTournamentSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }

  export type $DailyTournamentSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyTournamentSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tournament: Prisma.$DailyTournamentPayload<ExtArgs>
      questions: Prisma.$QuestionAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      tournamentId: string
      sessionSeed: string
      startedAt: Date
      endedAt: Date | null
      status: $Enums.UserTournamentStatus
      currentScore: number
      finalScore: number | null
      minute1Score: number | null
      minute2Score: number | null
      minute3Score: number | null
      minute4Score: number | null
      isFreeAttempt: boolean
      isRewardedAttempt: boolean
      currentLevel: number
      questionsAnswered: number
      correctAnswers: number
      endsAt: Date
    }, ExtArgs["result"]["dailyTournamentSession"]>
    composites: {}
  }

  type DailyTournamentSessionGetPayload<S extends boolean | null | undefined | DailyTournamentSessionDefaultArgs> = $Result.GetResult<Prisma.$DailyTournamentSessionPayload, S>

  type DailyTournamentSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyTournamentSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyTournamentSessionCountAggregateInputType | true
    }

  export interface DailyTournamentSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyTournamentSession'], meta: { name: 'DailyTournamentSession' } }
    /**
     * Find zero or one DailyTournamentSession that matches the filter.
     * @param {DailyTournamentSessionFindUniqueArgs} args - Arguments to find a DailyTournamentSession
     * @example
     * // Get one DailyTournamentSession
     * const dailyTournamentSession = await prisma.dailyTournamentSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyTournamentSessionFindUniqueArgs>(args: SelectSubset<T, DailyTournamentSessionFindUniqueArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyTournamentSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyTournamentSessionFindUniqueOrThrowArgs} args - Arguments to find a DailyTournamentSession
     * @example
     * // Get one DailyTournamentSession
     * const dailyTournamentSession = await prisma.dailyTournamentSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyTournamentSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyTournamentSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyTournamentSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentSessionFindFirstArgs} args - Arguments to find a DailyTournamentSession
     * @example
     * // Get one DailyTournamentSession
     * const dailyTournamentSession = await prisma.dailyTournamentSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyTournamentSessionFindFirstArgs>(args?: SelectSubset<T, DailyTournamentSessionFindFirstArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyTournamentSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentSessionFindFirstOrThrowArgs} args - Arguments to find a DailyTournamentSession
     * @example
     * // Get one DailyTournamentSession
     * const dailyTournamentSession = await prisma.dailyTournamentSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyTournamentSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyTournamentSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyTournamentSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyTournamentSessions
     * const dailyTournamentSessions = await prisma.dailyTournamentSession.findMany()
     * 
     * // Get first 10 DailyTournamentSessions
     * const dailyTournamentSessions = await prisma.dailyTournamentSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyTournamentSessionWithIdOnly = await prisma.dailyTournamentSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyTournamentSessionFindManyArgs>(args?: SelectSubset<T, DailyTournamentSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyTournamentSession.
     * @param {DailyTournamentSessionCreateArgs} args - Arguments to create a DailyTournamentSession.
     * @example
     * // Create one DailyTournamentSession
     * const DailyTournamentSession = await prisma.dailyTournamentSession.create({
     *   data: {
     *     // ... data to create a DailyTournamentSession
     *   }
     * })
     * 
     */
    create<T extends DailyTournamentSessionCreateArgs>(args: SelectSubset<T, DailyTournamentSessionCreateArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyTournamentSessions.
     * @param {DailyTournamentSessionCreateManyArgs} args - Arguments to create many DailyTournamentSessions.
     * @example
     * // Create many DailyTournamentSessions
     * const dailyTournamentSession = await prisma.dailyTournamentSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyTournamentSessionCreateManyArgs>(args?: SelectSubset<T, DailyTournamentSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyTournamentSessions and returns the data saved in the database.
     * @param {DailyTournamentSessionCreateManyAndReturnArgs} args - Arguments to create many DailyTournamentSessions.
     * @example
     * // Create many DailyTournamentSessions
     * const dailyTournamentSession = await prisma.dailyTournamentSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyTournamentSessions and only return the `id`
     * const dailyTournamentSessionWithIdOnly = await prisma.dailyTournamentSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyTournamentSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyTournamentSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyTournamentSession.
     * @param {DailyTournamentSessionDeleteArgs} args - Arguments to delete one DailyTournamentSession.
     * @example
     * // Delete one DailyTournamentSession
     * const DailyTournamentSession = await prisma.dailyTournamentSession.delete({
     *   where: {
     *     // ... filter to delete one DailyTournamentSession
     *   }
     * })
     * 
     */
    delete<T extends DailyTournamentSessionDeleteArgs>(args: SelectSubset<T, DailyTournamentSessionDeleteArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyTournamentSession.
     * @param {DailyTournamentSessionUpdateArgs} args - Arguments to update one DailyTournamentSession.
     * @example
     * // Update one DailyTournamentSession
     * const dailyTournamentSession = await prisma.dailyTournamentSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyTournamentSessionUpdateArgs>(args: SelectSubset<T, DailyTournamentSessionUpdateArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyTournamentSessions.
     * @param {DailyTournamentSessionDeleteManyArgs} args - Arguments to filter DailyTournamentSessions to delete.
     * @example
     * // Delete a few DailyTournamentSessions
     * const { count } = await prisma.dailyTournamentSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyTournamentSessionDeleteManyArgs>(args?: SelectSubset<T, DailyTournamentSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyTournamentSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyTournamentSessions
     * const dailyTournamentSession = await prisma.dailyTournamentSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyTournamentSessionUpdateManyArgs>(args: SelectSubset<T, DailyTournamentSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyTournamentSessions and returns the data updated in the database.
     * @param {DailyTournamentSessionUpdateManyAndReturnArgs} args - Arguments to update many DailyTournamentSessions.
     * @example
     * // Update many DailyTournamentSessions
     * const dailyTournamentSession = await prisma.dailyTournamentSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyTournamentSessions and only return the `id`
     * const dailyTournamentSessionWithIdOnly = await prisma.dailyTournamentSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyTournamentSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyTournamentSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyTournamentSession.
     * @param {DailyTournamentSessionUpsertArgs} args - Arguments to update or create a DailyTournamentSession.
     * @example
     * // Update or create a DailyTournamentSession
     * const dailyTournamentSession = await prisma.dailyTournamentSession.upsert({
     *   create: {
     *     // ... data to create a DailyTournamentSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyTournamentSession we want to update
     *   }
     * })
     */
    upsert<T extends DailyTournamentSessionUpsertArgs>(args: SelectSubset<T, DailyTournamentSessionUpsertArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyTournamentSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentSessionCountArgs} args - Arguments to filter DailyTournamentSessions to count.
     * @example
     * // Count the number of DailyTournamentSessions
     * const count = await prisma.dailyTournamentSession.count({
     *   where: {
     *     // ... the filter for the DailyTournamentSessions we want to count
     *   }
     * })
    **/
    count<T extends DailyTournamentSessionCountArgs>(
      args?: Subset<T, DailyTournamentSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyTournamentSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyTournamentSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyTournamentSessionAggregateArgs>(args: Subset<T, DailyTournamentSessionAggregateArgs>): Prisma.PrismaPromise<GetDailyTournamentSessionAggregateType<T>>

    /**
     * Group by DailyTournamentSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyTournamentSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyTournamentSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyTournamentSessionGroupByArgs['orderBy'] }
        : { orderBy?: DailyTournamentSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyTournamentSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyTournamentSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyTournamentSession model
   */
  readonly fields: DailyTournamentSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyTournamentSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyTournamentSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends DailyTournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailyTournamentDefaultArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends DailyTournamentSession$questionsArgs<ExtArgs> = {}>(args?: Subset<T, DailyTournamentSession$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyTournamentSession model
   */
  interface DailyTournamentSessionFieldRefs {
    readonly id: FieldRef<"DailyTournamentSession", 'String'>
    readonly createdAt: FieldRef<"DailyTournamentSession", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyTournamentSession", 'DateTime'>
    readonly userId: FieldRef<"DailyTournamentSession", 'String'>
    readonly tournamentId: FieldRef<"DailyTournamentSession", 'String'>
    readonly sessionSeed: FieldRef<"DailyTournamentSession", 'String'>
    readonly startedAt: FieldRef<"DailyTournamentSession", 'DateTime'>
    readonly endedAt: FieldRef<"DailyTournamentSession", 'DateTime'>
    readonly status: FieldRef<"DailyTournamentSession", 'UserTournamentStatus'>
    readonly currentScore: FieldRef<"DailyTournamentSession", 'Int'>
    readonly finalScore: FieldRef<"DailyTournamentSession", 'Int'>
    readonly minute1Score: FieldRef<"DailyTournamentSession", 'Int'>
    readonly minute2Score: FieldRef<"DailyTournamentSession", 'Int'>
    readonly minute3Score: FieldRef<"DailyTournamentSession", 'Int'>
    readonly minute4Score: FieldRef<"DailyTournamentSession", 'Int'>
    readonly isFreeAttempt: FieldRef<"DailyTournamentSession", 'Boolean'>
    readonly isRewardedAttempt: FieldRef<"DailyTournamentSession", 'Boolean'>
    readonly currentLevel: FieldRef<"DailyTournamentSession", 'Int'>
    readonly questionsAnswered: FieldRef<"DailyTournamentSession", 'Int'>
    readonly correctAnswers: FieldRef<"DailyTournamentSession", 'Int'>
    readonly endsAt: FieldRef<"DailyTournamentSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyTournamentSession findUnique
   */
  export type DailyTournamentSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournamentSession to fetch.
     */
    where: DailyTournamentSessionWhereUniqueInput
  }

  /**
   * DailyTournamentSession findUniqueOrThrow
   */
  export type DailyTournamentSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournamentSession to fetch.
     */
    where: DailyTournamentSessionWhereUniqueInput
  }

  /**
   * DailyTournamentSession findFirst
   */
  export type DailyTournamentSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournamentSession to fetch.
     */
    where?: DailyTournamentSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTournamentSessions to fetch.
     */
    orderBy?: DailyTournamentSessionOrderByWithRelationInput | DailyTournamentSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyTournamentSessions.
     */
    cursor?: DailyTournamentSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTournamentSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTournamentSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyTournamentSessions.
     */
    distinct?: DailyTournamentSessionScalarFieldEnum | DailyTournamentSessionScalarFieldEnum[]
  }

  /**
   * DailyTournamentSession findFirstOrThrow
   */
  export type DailyTournamentSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournamentSession to fetch.
     */
    where?: DailyTournamentSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTournamentSessions to fetch.
     */
    orderBy?: DailyTournamentSessionOrderByWithRelationInput | DailyTournamentSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyTournamentSessions.
     */
    cursor?: DailyTournamentSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTournamentSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTournamentSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyTournamentSessions.
     */
    distinct?: DailyTournamentSessionScalarFieldEnum | DailyTournamentSessionScalarFieldEnum[]
  }

  /**
   * DailyTournamentSession findMany
   */
  export type DailyTournamentSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * Filter, which DailyTournamentSessions to fetch.
     */
    where?: DailyTournamentSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyTournamentSessions to fetch.
     */
    orderBy?: DailyTournamentSessionOrderByWithRelationInput | DailyTournamentSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyTournamentSessions.
     */
    cursor?: DailyTournamentSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyTournamentSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyTournamentSessions.
     */
    skip?: number
    distinct?: DailyTournamentSessionScalarFieldEnum | DailyTournamentSessionScalarFieldEnum[]
  }

  /**
   * DailyTournamentSession create
   */
  export type DailyTournamentSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyTournamentSession.
     */
    data: XOR<DailyTournamentSessionCreateInput, DailyTournamentSessionUncheckedCreateInput>
  }

  /**
   * DailyTournamentSession createMany
   */
  export type DailyTournamentSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyTournamentSessions.
     */
    data: DailyTournamentSessionCreateManyInput | DailyTournamentSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyTournamentSession createManyAndReturn
   */
  export type DailyTournamentSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * The data used to create many DailyTournamentSessions.
     */
    data: DailyTournamentSessionCreateManyInput | DailyTournamentSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyTournamentSession update
   */
  export type DailyTournamentSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyTournamentSession.
     */
    data: XOR<DailyTournamentSessionUpdateInput, DailyTournamentSessionUncheckedUpdateInput>
    /**
     * Choose, which DailyTournamentSession to update.
     */
    where: DailyTournamentSessionWhereUniqueInput
  }

  /**
   * DailyTournamentSession updateMany
   */
  export type DailyTournamentSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyTournamentSessions.
     */
    data: XOR<DailyTournamentSessionUpdateManyMutationInput, DailyTournamentSessionUncheckedUpdateManyInput>
    /**
     * Filter which DailyTournamentSessions to update
     */
    where?: DailyTournamentSessionWhereInput
    /**
     * Limit how many DailyTournamentSessions to update.
     */
    limit?: number
  }

  /**
   * DailyTournamentSession updateManyAndReturn
   */
  export type DailyTournamentSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * The data used to update DailyTournamentSessions.
     */
    data: XOR<DailyTournamentSessionUpdateManyMutationInput, DailyTournamentSessionUncheckedUpdateManyInput>
    /**
     * Filter which DailyTournamentSessions to update
     */
    where?: DailyTournamentSessionWhereInput
    /**
     * Limit how many DailyTournamentSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyTournamentSession upsert
   */
  export type DailyTournamentSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyTournamentSession to update in case it exists.
     */
    where: DailyTournamentSessionWhereUniqueInput
    /**
     * In case the DailyTournamentSession found by the `where` argument doesn't exist, create a new DailyTournamentSession with this data.
     */
    create: XOR<DailyTournamentSessionCreateInput, DailyTournamentSessionUncheckedCreateInput>
    /**
     * In case the DailyTournamentSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyTournamentSessionUpdateInput, DailyTournamentSessionUncheckedUpdateInput>
  }

  /**
   * DailyTournamentSession delete
   */
  export type DailyTournamentSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    /**
     * Filter which DailyTournamentSession to delete.
     */
    where: DailyTournamentSessionWhereUniqueInput
  }

  /**
   * DailyTournamentSession deleteMany
   */
  export type DailyTournamentSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyTournamentSessions to delete
     */
    where?: DailyTournamentSessionWhereInput
    /**
     * Limit how many DailyTournamentSessions to delete.
     */
    limit?: number
  }

  /**
   * DailyTournamentSession.questions
   */
  export type DailyTournamentSession$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    where?: QuestionAttemptWhereInput
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    cursor?: QuestionAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * DailyTournamentSession without action
   */
  export type DailyTournamentSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
  }


  /**
   * Model MinuteSnapshot
   */

  export type AggregateMinuteSnapshot = {
    _count: MinuteSnapshotCountAggregateOutputType | null
    _avg: MinuteSnapshotAvgAggregateOutputType | null
    _sum: MinuteSnapshotSumAggregateOutputType | null
    _min: MinuteSnapshotMinAggregateOutputType | null
    _max: MinuteSnapshotMaxAggregateOutputType | null
  }

  export type MinuteSnapshotAvgAggregateOutputType = {
    minuteNumber: number | null
  }

  export type MinuteSnapshotSumAggregateOutputType = {
    minuteNumber: number | null
  }

  export type MinuteSnapshotMinAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    minuteNumber: number | null
    createdAt: Date | null
  }

  export type MinuteSnapshotMaxAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    minuteNumber: number | null
    createdAt: Date | null
  }

  export type MinuteSnapshotCountAggregateOutputType = {
    id: number
    tournamentId: number
    minuteNumber: number
    snapshot: number
    createdAt: number
    _all: number
  }


  export type MinuteSnapshotAvgAggregateInputType = {
    minuteNumber?: true
  }

  export type MinuteSnapshotSumAggregateInputType = {
    minuteNumber?: true
  }

  export type MinuteSnapshotMinAggregateInputType = {
    id?: true
    tournamentId?: true
    minuteNumber?: true
    createdAt?: true
  }

  export type MinuteSnapshotMaxAggregateInputType = {
    id?: true
    tournamentId?: true
    minuteNumber?: true
    createdAt?: true
  }

  export type MinuteSnapshotCountAggregateInputType = {
    id?: true
    tournamentId?: true
    minuteNumber?: true
    snapshot?: true
    createdAt?: true
    _all?: true
  }

  export type MinuteSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinuteSnapshot to aggregate.
     */
    where?: MinuteSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinuteSnapshots to fetch.
     */
    orderBy?: MinuteSnapshotOrderByWithRelationInput | MinuteSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MinuteSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinuteSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinuteSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MinuteSnapshots
    **/
    _count?: true | MinuteSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MinuteSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MinuteSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinuteSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinuteSnapshotMaxAggregateInputType
  }

  export type GetMinuteSnapshotAggregateType<T extends MinuteSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateMinuteSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinuteSnapshot[P]>
      : GetScalarType<T[P], AggregateMinuteSnapshot[P]>
  }




  export type MinuteSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinuteSnapshotWhereInput
    orderBy?: MinuteSnapshotOrderByWithAggregationInput | MinuteSnapshotOrderByWithAggregationInput[]
    by: MinuteSnapshotScalarFieldEnum[] | MinuteSnapshotScalarFieldEnum
    having?: MinuteSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinuteSnapshotCountAggregateInputType | true
    _avg?: MinuteSnapshotAvgAggregateInputType
    _sum?: MinuteSnapshotSumAggregateInputType
    _min?: MinuteSnapshotMinAggregateInputType
    _max?: MinuteSnapshotMaxAggregateInputType
  }

  export type MinuteSnapshotGroupByOutputType = {
    id: string
    tournamentId: string
    minuteNumber: number
    snapshot: JsonValue
    createdAt: Date
    _count: MinuteSnapshotCountAggregateOutputType | null
    _avg: MinuteSnapshotAvgAggregateOutputType | null
    _sum: MinuteSnapshotSumAggregateOutputType | null
    _min: MinuteSnapshotMinAggregateOutputType | null
    _max: MinuteSnapshotMaxAggregateOutputType | null
  }

  type GetMinuteSnapshotGroupByPayload<T extends MinuteSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinuteSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinuteSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinuteSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], MinuteSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type MinuteSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    minuteNumber?: boolean
    snapshot?: boolean
    createdAt?: boolean
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minuteSnapshot"]>

  export type MinuteSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    minuteNumber?: boolean
    snapshot?: boolean
    createdAt?: boolean
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minuteSnapshot"]>

  export type MinuteSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    minuteNumber?: boolean
    snapshot?: boolean
    createdAt?: boolean
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minuteSnapshot"]>

  export type MinuteSnapshotSelectScalar = {
    id?: boolean
    tournamentId?: boolean
    minuteNumber?: boolean
    snapshot?: boolean
    createdAt?: boolean
  }

  export type MinuteSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tournamentId" | "minuteNumber" | "snapshot" | "createdAt", ExtArgs["result"]["minuteSnapshot"]>
  export type MinuteSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }
  export type MinuteSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }
  export type MinuteSnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | DailyTournamentDefaultArgs<ExtArgs>
  }

  export type $MinuteSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MinuteSnapshot"
    objects: {
      tournament: Prisma.$DailyTournamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournamentId: string
      minuteNumber: number
      snapshot: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["minuteSnapshot"]>
    composites: {}
  }

  type MinuteSnapshotGetPayload<S extends boolean | null | undefined | MinuteSnapshotDefaultArgs> = $Result.GetResult<Prisma.$MinuteSnapshotPayload, S>

  type MinuteSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MinuteSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MinuteSnapshotCountAggregateInputType | true
    }

  export interface MinuteSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MinuteSnapshot'], meta: { name: 'MinuteSnapshot' } }
    /**
     * Find zero or one MinuteSnapshot that matches the filter.
     * @param {MinuteSnapshotFindUniqueArgs} args - Arguments to find a MinuteSnapshot
     * @example
     * // Get one MinuteSnapshot
     * const minuteSnapshot = await prisma.minuteSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MinuteSnapshotFindUniqueArgs>(args: SelectSubset<T, MinuteSnapshotFindUniqueArgs<ExtArgs>>): Prisma__MinuteSnapshotClient<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MinuteSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MinuteSnapshotFindUniqueOrThrowArgs} args - Arguments to find a MinuteSnapshot
     * @example
     * // Get one MinuteSnapshot
     * const minuteSnapshot = await prisma.minuteSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MinuteSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, MinuteSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MinuteSnapshotClient<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MinuteSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinuteSnapshotFindFirstArgs} args - Arguments to find a MinuteSnapshot
     * @example
     * // Get one MinuteSnapshot
     * const minuteSnapshot = await prisma.minuteSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MinuteSnapshotFindFirstArgs>(args?: SelectSubset<T, MinuteSnapshotFindFirstArgs<ExtArgs>>): Prisma__MinuteSnapshotClient<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MinuteSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinuteSnapshotFindFirstOrThrowArgs} args - Arguments to find a MinuteSnapshot
     * @example
     * // Get one MinuteSnapshot
     * const minuteSnapshot = await prisma.minuteSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MinuteSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, MinuteSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__MinuteSnapshotClient<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MinuteSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinuteSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MinuteSnapshots
     * const minuteSnapshots = await prisma.minuteSnapshot.findMany()
     * 
     * // Get first 10 MinuteSnapshots
     * const minuteSnapshots = await prisma.minuteSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const minuteSnapshotWithIdOnly = await prisma.minuteSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MinuteSnapshotFindManyArgs>(args?: SelectSubset<T, MinuteSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MinuteSnapshot.
     * @param {MinuteSnapshotCreateArgs} args - Arguments to create a MinuteSnapshot.
     * @example
     * // Create one MinuteSnapshot
     * const MinuteSnapshot = await prisma.minuteSnapshot.create({
     *   data: {
     *     // ... data to create a MinuteSnapshot
     *   }
     * })
     * 
     */
    create<T extends MinuteSnapshotCreateArgs>(args: SelectSubset<T, MinuteSnapshotCreateArgs<ExtArgs>>): Prisma__MinuteSnapshotClient<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MinuteSnapshots.
     * @param {MinuteSnapshotCreateManyArgs} args - Arguments to create many MinuteSnapshots.
     * @example
     * // Create many MinuteSnapshots
     * const minuteSnapshot = await prisma.minuteSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MinuteSnapshotCreateManyArgs>(args?: SelectSubset<T, MinuteSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MinuteSnapshots and returns the data saved in the database.
     * @param {MinuteSnapshotCreateManyAndReturnArgs} args - Arguments to create many MinuteSnapshots.
     * @example
     * // Create many MinuteSnapshots
     * const minuteSnapshot = await prisma.minuteSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MinuteSnapshots and only return the `id`
     * const minuteSnapshotWithIdOnly = await prisma.minuteSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MinuteSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, MinuteSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MinuteSnapshot.
     * @param {MinuteSnapshotDeleteArgs} args - Arguments to delete one MinuteSnapshot.
     * @example
     * // Delete one MinuteSnapshot
     * const MinuteSnapshot = await prisma.minuteSnapshot.delete({
     *   where: {
     *     // ... filter to delete one MinuteSnapshot
     *   }
     * })
     * 
     */
    delete<T extends MinuteSnapshotDeleteArgs>(args: SelectSubset<T, MinuteSnapshotDeleteArgs<ExtArgs>>): Prisma__MinuteSnapshotClient<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MinuteSnapshot.
     * @param {MinuteSnapshotUpdateArgs} args - Arguments to update one MinuteSnapshot.
     * @example
     * // Update one MinuteSnapshot
     * const minuteSnapshot = await prisma.minuteSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MinuteSnapshotUpdateArgs>(args: SelectSubset<T, MinuteSnapshotUpdateArgs<ExtArgs>>): Prisma__MinuteSnapshotClient<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MinuteSnapshots.
     * @param {MinuteSnapshotDeleteManyArgs} args - Arguments to filter MinuteSnapshots to delete.
     * @example
     * // Delete a few MinuteSnapshots
     * const { count } = await prisma.minuteSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MinuteSnapshotDeleteManyArgs>(args?: SelectSubset<T, MinuteSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MinuteSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinuteSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MinuteSnapshots
     * const minuteSnapshot = await prisma.minuteSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MinuteSnapshotUpdateManyArgs>(args: SelectSubset<T, MinuteSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MinuteSnapshots and returns the data updated in the database.
     * @param {MinuteSnapshotUpdateManyAndReturnArgs} args - Arguments to update many MinuteSnapshots.
     * @example
     * // Update many MinuteSnapshots
     * const minuteSnapshot = await prisma.minuteSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MinuteSnapshots and only return the `id`
     * const minuteSnapshotWithIdOnly = await prisma.minuteSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MinuteSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, MinuteSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MinuteSnapshot.
     * @param {MinuteSnapshotUpsertArgs} args - Arguments to update or create a MinuteSnapshot.
     * @example
     * // Update or create a MinuteSnapshot
     * const minuteSnapshot = await prisma.minuteSnapshot.upsert({
     *   create: {
     *     // ... data to create a MinuteSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MinuteSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends MinuteSnapshotUpsertArgs>(args: SelectSubset<T, MinuteSnapshotUpsertArgs<ExtArgs>>): Prisma__MinuteSnapshotClient<$Result.GetResult<Prisma.$MinuteSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MinuteSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinuteSnapshotCountArgs} args - Arguments to filter MinuteSnapshots to count.
     * @example
     * // Count the number of MinuteSnapshots
     * const count = await prisma.minuteSnapshot.count({
     *   where: {
     *     // ... the filter for the MinuteSnapshots we want to count
     *   }
     * })
    **/
    count<T extends MinuteSnapshotCountArgs>(
      args?: Subset<T, MinuteSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinuteSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MinuteSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinuteSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinuteSnapshotAggregateArgs>(args: Subset<T, MinuteSnapshotAggregateArgs>): Prisma.PrismaPromise<GetMinuteSnapshotAggregateType<T>>

    /**
     * Group by MinuteSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinuteSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MinuteSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinuteSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: MinuteSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MinuteSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinuteSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MinuteSnapshot model
   */
  readonly fields: MinuteSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MinuteSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinuteSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournament<T extends DailyTournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailyTournamentDefaultArgs<ExtArgs>>): Prisma__DailyTournamentClient<$Result.GetResult<Prisma.$DailyTournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MinuteSnapshot model
   */
  interface MinuteSnapshotFieldRefs {
    readonly id: FieldRef<"MinuteSnapshot", 'String'>
    readonly tournamentId: FieldRef<"MinuteSnapshot", 'String'>
    readonly minuteNumber: FieldRef<"MinuteSnapshot", 'Int'>
    readonly snapshot: FieldRef<"MinuteSnapshot", 'Json'>
    readonly createdAt: FieldRef<"MinuteSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MinuteSnapshot findUnique
   */
  export type MinuteSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MinuteSnapshot to fetch.
     */
    where: MinuteSnapshotWhereUniqueInput
  }

  /**
   * MinuteSnapshot findUniqueOrThrow
   */
  export type MinuteSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MinuteSnapshot to fetch.
     */
    where: MinuteSnapshotWhereUniqueInput
  }

  /**
   * MinuteSnapshot findFirst
   */
  export type MinuteSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MinuteSnapshot to fetch.
     */
    where?: MinuteSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinuteSnapshots to fetch.
     */
    orderBy?: MinuteSnapshotOrderByWithRelationInput | MinuteSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinuteSnapshots.
     */
    cursor?: MinuteSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinuteSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinuteSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinuteSnapshots.
     */
    distinct?: MinuteSnapshotScalarFieldEnum | MinuteSnapshotScalarFieldEnum[]
  }

  /**
   * MinuteSnapshot findFirstOrThrow
   */
  export type MinuteSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MinuteSnapshot to fetch.
     */
    where?: MinuteSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinuteSnapshots to fetch.
     */
    orderBy?: MinuteSnapshotOrderByWithRelationInput | MinuteSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MinuteSnapshots.
     */
    cursor?: MinuteSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinuteSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinuteSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MinuteSnapshots.
     */
    distinct?: MinuteSnapshotScalarFieldEnum | MinuteSnapshotScalarFieldEnum[]
  }

  /**
   * MinuteSnapshot findMany
   */
  export type MinuteSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MinuteSnapshots to fetch.
     */
    where?: MinuteSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MinuteSnapshots to fetch.
     */
    orderBy?: MinuteSnapshotOrderByWithRelationInput | MinuteSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MinuteSnapshots.
     */
    cursor?: MinuteSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MinuteSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MinuteSnapshots.
     */
    skip?: number
    distinct?: MinuteSnapshotScalarFieldEnum | MinuteSnapshotScalarFieldEnum[]
  }

  /**
   * MinuteSnapshot create
   */
  export type MinuteSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a MinuteSnapshot.
     */
    data: XOR<MinuteSnapshotCreateInput, MinuteSnapshotUncheckedCreateInput>
  }

  /**
   * MinuteSnapshot createMany
   */
  export type MinuteSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MinuteSnapshots.
     */
    data: MinuteSnapshotCreateManyInput | MinuteSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MinuteSnapshot createManyAndReturn
   */
  export type MinuteSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many MinuteSnapshots.
     */
    data: MinuteSnapshotCreateManyInput | MinuteSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MinuteSnapshot update
   */
  export type MinuteSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a MinuteSnapshot.
     */
    data: XOR<MinuteSnapshotUpdateInput, MinuteSnapshotUncheckedUpdateInput>
    /**
     * Choose, which MinuteSnapshot to update.
     */
    where: MinuteSnapshotWhereUniqueInput
  }

  /**
   * MinuteSnapshot updateMany
   */
  export type MinuteSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MinuteSnapshots.
     */
    data: XOR<MinuteSnapshotUpdateManyMutationInput, MinuteSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which MinuteSnapshots to update
     */
    where?: MinuteSnapshotWhereInput
    /**
     * Limit how many MinuteSnapshots to update.
     */
    limit?: number
  }

  /**
   * MinuteSnapshot updateManyAndReturn
   */
  export type MinuteSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update MinuteSnapshots.
     */
    data: XOR<MinuteSnapshotUpdateManyMutationInput, MinuteSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which MinuteSnapshots to update
     */
    where?: MinuteSnapshotWhereInput
    /**
     * Limit how many MinuteSnapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MinuteSnapshot upsert
   */
  export type MinuteSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the MinuteSnapshot to update in case it exists.
     */
    where: MinuteSnapshotWhereUniqueInput
    /**
     * In case the MinuteSnapshot found by the `where` argument doesn't exist, create a new MinuteSnapshot with this data.
     */
    create: XOR<MinuteSnapshotCreateInput, MinuteSnapshotUncheckedCreateInput>
    /**
     * In case the MinuteSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MinuteSnapshotUpdateInput, MinuteSnapshotUncheckedUpdateInput>
  }

  /**
   * MinuteSnapshot delete
   */
  export type MinuteSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
    /**
     * Filter which MinuteSnapshot to delete.
     */
    where: MinuteSnapshotWhereUniqueInput
  }

  /**
   * MinuteSnapshot deleteMany
   */
  export type MinuteSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MinuteSnapshots to delete
     */
    where?: MinuteSnapshotWhereInput
    /**
     * Limit how many MinuteSnapshots to delete.
     */
    limit?: number
  }

  /**
   * MinuteSnapshot without action
   */
  export type MinuteSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinuteSnapshot
     */
    select?: MinuteSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MinuteSnapshot
     */
    omit?: MinuteSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinuteSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model SoloSession
   */

  export type AggregateSoloSession = {
    _count: SoloSessionCountAggregateOutputType | null
    _avg: SoloSessionAvgAggregateOutputType | null
    _sum: SoloSessionSumAggregateOutputType | null
    _min: SoloSessionMinAggregateOutputType | null
    _max: SoloSessionMaxAggregateOutputType | null
  }

  export type SoloSessionAvgAggregateOutputType = {
    currentRound: number | null
    bankedPoints: number | null
    finalScore: number | null
    coinPointsEarned: number | null
    currentLevel: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
  }

  export type SoloSessionSumAggregateOutputType = {
    currentRound: number | null
    bankedPoints: number | null
    finalScore: number | null
    coinPointsEarned: number | null
    currentLevel: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
  }

  export type SoloSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    date: Date | null
    sessionSeed: string | null
    startedAt: Date | null
    endedAt: Date | null
    status: $Enums.UserTournamentStatus | null
    currentRound: number | null
    bankedPoints: number | null
    finalScore: number | null
    coinPointsEarned: number | null
    isFreeAttempt: boolean | null
    currentLevel: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
    madeMistake: boolean | null
    quitEarly: boolean | null
  }

  export type SoloSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    date: Date | null
    sessionSeed: string | null
    startedAt: Date | null
    endedAt: Date | null
    status: $Enums.UserTournamentStatus | null
    currentRound: number | null
    bankedPoints: number | null
    finalScore: number | null
    coinPointsEarned: number | null
    isFreeAttempt: boolean | null
    currentLevel: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
    madeMistake: boolean | null
    quitEarly: boolean | null
  }

  export type SoloSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    date: number
    sessionSeed: number
    startedAt: number
    endedAt: number
    status: number
    currentRound: number
    bankedPoints: number
    finalScore: number
    coinPointsEarned: number
    isFreeAttempt: number
    currentLevel: number
    questionsAnswered: number
    correctAnswers: number
    madeMistake: number
    quitEarly: number
    _all: number
  }


  export type SoloSessionAvgAggregateInputType = {
    currentRound?: true
    bankedPoints?: true
    finalScore?: true
    coinPointsEarned?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
  }

  export type SoloSessionSumAggregateInputType = {
    currentRound?: true
    bankedPoints?: true
    finalScore?: true
    coinPointsEarned?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
  }

  export type SoloSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    date?: true
    sessionSeed?: true
    startedAt?: true
    endedAt?: true
    status?: true
    currentRound?: true
    bankedPoints?: true
    finalScore?: true
    coinPointsEarned?: true
    isFreeAttempt?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
    madeMistake?: true
    quitEarly?: true
  }

  export type SoloSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    date?: true
    sessionSeed?: true
    startedAt?: true
    endedAt?: true
    status?: true
    currentRound?: true
    bankedPoints?: true
    finalScore?: true
    coinPointsEarned?: true
    isFreeAttempt?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
    madeMistake?: true
    quitEarly?: true
  }

  export type SoloSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    date?: true
    sessionSeed?: true
    startedAt?: true
    endedAt?: true
    status?: true
    currentRound?: true
    bankedPoints?: true
    finalScore?: true
    coinPointsEarned?: true
    isFreeAttempt?: true
    currentLevel?: true
    questionsAnswered?: true
    correctAnswers?: true
    madeMistake?: true
    quitEarly?: true
    _all?: true
  }

  export type SoloSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoloSession to aggregate.
     */
    where?: SoloSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoloSessions to fetch.
     */
    orderBy?: SoloSessionOrderByWithRelationInput | SoloSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoloSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoloSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoloSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SoloSessions
    **/
    _count?: true | SoloSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoloSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoloSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoloSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoloSessionMaxAggregateInputType
  }

  export type GetSoloSessionAggregateType<T extends SoloSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSoloSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoloSession[P]>
      : GetScalarType<T[P], AggregateSoloSession[P]>
  }




  export type SoloSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoloSessionWhereInput
    orderBy?: SoloSessionOrderByWithAggregationInput | SoloSessionOrderByWithAggregationInput[]
    by: SoloSessionScalarFieldEnum[] | SoloSessionScalarFieldEnum
    having?: SoloSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoloSessionCountAggregateInputType | true
    _avg?: SoloSessionAvgAggregateInputType
    _sum?: SoloSessionSumAggregateInputType
    _min?: SoloSessionMinAggregateInputType
    _max?: SoloSessionMaxAggregateInputType
  }

  export type SoloSessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    date: Date
    sessionSeed: string
    startedAt: Date
    endedAt: Date | null
    status: $Enums.UserTournamentStatus
    currentRound: number
    bankedPoints: number
    finalScore: number | null
    coinPointsEarned: number
    isFreeAttempt: boolean
    currentLevel: number
    questionsAnswered: number
    correctAnswers: number
    madeMistake: boolean
    quitEarly: boolean
    _count: SoloSessionCountAggregateOutputType | null
    _avg: SoloSessionAvgAggregateOutputType | null
    _sum: SoloSessionSumAggregateOutputType | null
    _min: SoloSessionMinAggregateOutputType | null
    _max: SoloSessionMaxAggregateOutputType | null
  }

  type GetSoloSessionGroupByPayload<T extends SoloSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoloSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoloSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoloSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SoloSessionGroupByOutputType[P]>
        }
      >
    >


  export type SoloSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    date?: boolean
    sessionSeed?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    currentRound?: boolean
    bankedPoints?: boolean
    finalScore?: boolean
    coinPointsEarned?: boolean
    isFreeAttempt?: boolean
    currentLevel?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    madeMistake?: boolean
    quitEarly?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    questions?: boolean | SoloSession$questionsArgs<ExtArgs>
    _count?: boolean | SoloSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soloSession"]>

  export type SoloSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    date?: boolean
    sessionSeed?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    currentRound?: boolean
    bankedPoints?: boolean
    finalScore?: boolean
    coinPointsEarned?: boolean
    isFreeAttempt?: boolean
    currentLevel?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    madeMistake?: boolean
    quitEarly?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soloSession"]>

  export type SoloSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    date?: boolean
    sessionSeed?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    currentRound?: boolean
    bankedPoints?: boolean
    finalScore?: boolean
    coinPointsEarned?: boolean
    isFreeAttempt?: boolean
    currentLevel?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    madeMistake?: boolean
    quitEarly?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["soloSession"]>

  export type SoloSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    date?: boolean
    sessionSeed?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    currentRound?: boolean
    bankedPoints?: boolean
    finalScore?: boolean
    coinPointsEarned?: boolean
    isFreeAttempt?: boolean
    currentLevel?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    madeMistake?: boolean
    quitEarly?: boolean
  }

  export type SoloSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "userId" | "date" | "sessionSeed" | "startedAt" | "endedAt" | "status" | "currentRound" | "bankedPoints" | "finalScore" | "coinPointsEarned" | "isFreeAttempt" | "currentLevel" | "questionsAnswered" | "correctAnswers" | "madeMistake" | "quitEarly", ExtArgs["result"]["soloSession"]>
  export type SoloSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    questions?: boolean | SoloSession$questionsArgs<ExtArgs>
    _count?: boolean | SoloSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SoloSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SoloSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SoloSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SoloSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      questions: Prisma.$QuestionAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      date: Date
      sessionSeed: string
      startedAt: Date
      endedAt: Date | null
      status: $Enums.UserTournamentStatus
      currentRound: number
      bankedPoints: number
      finalScore: number | null
      coinPointsEarned: number
      isFreeAttempt: boolean
      currentLevel: number
      questionsAnswered: number
      correctAnswers: number
      madeMistake: boolean
      quitEarly: boolean
    }, ExtArgs["result"]["soloSession"]>
    composites: {}
  }

  type SoloSessionGetPayload<S extends boolean | null | undefined | SoloSessionDefaultArgs> = $Result.GetResult<Prisma.$SoloSessionPayload, S>

  type SoloSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SoloSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SoloSessionCountAggregateInputType | true
    }

  export interface SoloSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SoloSession'], meta: { name: 'SoloSession' } }
    /**
     * Find zero or one SoloSession that matches the filter.
     * @param {SoloSessionFindUniqueArgs} args - Arguments to find a SoloSession
     * @example
     * // Get one SoloSession
     * const soloSession = await prisma.soloSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SoloSessionFindUniqueArgs>(args: SelectSubset<T, SoloSessionFindUniqueArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SoloSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SoloSessionFindUniqueOrThrowArgs} args - Arguments to find a SoloSession
     * @example
     * // Get one SoloSession
     * const soloSession = await prisma.soloSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SoloSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SoloSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SoloSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloSessionFindFirstArgs} args - Arguments to find a SoloSession
     * @example
     * // Get one SoloSession
     * const soloSession = await prisma.soloSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SoloSessionFindFirstArgs>(args?: SelectSubset<T, SoloSessionFindFirstArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SoloSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloSessionFindFirstOrThrowArgs} args - Arguments to find a SoloSession
     * @example
     * // Get one SoloSession
     * const soloSession = await prisma.soloSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SoloSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SoloSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SoloSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SoloSessions
     * const soloSessions = await prisma.soloSession.findMany()
     * 
     * // Get first 10 SoloSessions
     * const soloSessions = await prisma.soloSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const soloSessionWithIdOnly = await prisma.soloSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SoloSessionFindManyArgs>(args?: SelectSubset<T, SoloSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SoloSession.
     * @param {SoloSessionCreateArgs} args - Arguments to create a SoloSession.
     * @example
     * // Create one SoloSession
     * const SoloSession = await prisma.soloSession.create({
     *   data: {
     *     // ... data to create a SoloSession
     *   }
     * })
     * 
     */
    create<T extends SoloSessionCreateArgs>(args: SelectSubset<T, SoloSessionCreateArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SoloSessions.
     * @param {SoloSessionCreateManyArgs} args - Arguments to create many SoloSessions.
     * @example
     * // Create many SoloSessions
     * const soloSession = await prisma.soloSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SoloSessionCreateManyArgs>(args?: SelectSubset<T, SoloSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SoloSessions and returns the data saved in the database.
     * @param {SoloSessionCreateManyAndReturnArgs} args - Arguments to create many SoloSessions.
     * @example
     * // Create many SoloSessions
     * const soloSession = await prisma.soloSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SoloSessions and only return the `id`
     * const soloSessionWithIdOnly = await prisma.soloSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SoloSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SoloSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SoloSession.
     * @param {SoloSessionDeleteArgs} args - Arguments to delete one SoloSession.
     * @example
     * // Delete one SoloSession
     * const SoloSession = await prisma.soloSession.delete({
     *   where: {
     *     // ... filter to delete one SoloSession
     *   }
     * })
     * 
     */
    delete<T extends SoloSessionDeleteArgs>(args: SelectSubset<T, SoloSessionDeleteArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SoloSession.
     * @param {SoloSessionUpdateArgs} args - Arguments to update one SoloSession.
     * @example
     * // Update one SoloSession
     * const soloSession = await prisma.soloSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SoloSessionUpdateArgs>(args: SelectSubset<T, SoloSessionUpdateArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SoloSessions.
     * @param {SoloSessionDeleteManyArgs} args - Arguments to filter SoloSessions to delete.
     * @example
     * // Delete a few SoloSessions
     * const { count } = await prisma.soloSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SoloSessionDeleteManyArgs>(args?: SelectSubset<T, SoloSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoloSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SoloSessions
     * const soloSession = await prisma.soloSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SoloSessionUpdateManyArgs>(args: SelectSubset<T, SoloSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoloSessions and returns the data updated in the database.
     * @param {SoloSessionUpdateManyAndReturnArgs} args - Arguments to update many SoloSessions.
     * @example
     * // Update many SoloSessions
     * const soloSession = await prisma.soloSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SoloSessions and only return the `id`
     * const soloSessionWithIdOnly = await prisma.soloSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SoloSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SoloSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SoloSession.
     * @param {SoloSessionUpsertArgs} args - Arguments to update or create a SoloSession.
     * @example
     * // Update or create a SoloSession
     * const soloSession = await prisma.soloSession.upsert({
     *   create: {
     *     // ... data to create a SoloSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SoloSession we want to update
     *   }
     * })
     */
    upsert<T extends SoloSessionUpsertArgs>(args: SelectSubset<T, SoloSessionUpsertArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SoloSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloSessionCountArgs} args - Arguments to filter SoloSessions to count.
     * @example
     * // Count the number of SoloSessions
     * const count = await prisma.soloSession.count({
     *   where: {
     *     // ... the filter for the SoloSessions we want to count
     *   }
     * })
    **/
    count<T extends SoloSessionCountArgs>(
      args?: Subset<T, SoloSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoloSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SoloSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoloSessionAggregateArgs>(args: Subset<T, SoloSessionAggregateArgs>): Prisma.PrismaPromise<GetSoloSessionAggregateType<T>>

    /**
     * Group by SoloSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoloSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoloSessionGroupByArgs['orderBy'] }
        : { orderBy?: SoloSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoloSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoloSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SoloSession model
   */
  readonly fields: SoloSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SoloSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoloSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends SoloSession$questionsArgs<ExtArgs> = {}>(args?: Subset<T, SoloSession$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SoloSession model
   */
  interface SoloSessionFieldRefs {
    readonly id: FieldRef<"SoloSession", 'String'>
    readonly createdAt: FieldRef<"SoloSession", 'DateTime'>
    readonly updatedAt: FieldRef<"SoloSession", 'DateTime'>
    readonly userId: FieldRef<"SoloSession", 'String'>
    readonly date: FieldRef<"SoloSession", 'DateTime'>
    readonly sessionSeed: FieldRef<"SoloSession", 'String'>
    readonly startedAt: FieldRef<"SoloSession", 'DateTime'>
    readonly endedAt: FieldRef<"SoloSession", 'DateTime'>
    readonly status: FieldRef<"SoloSession", 'UserTournamentStatus'>
    readonly currentRound: FieldRef<"SoloSession", 'Int'>
    readonly bankedPoints: FieldRef<"SoloSession", 'Float'>
    readonly finalScore: FieldRef<"SoloSession", 'Float'>
    readonly coinPointsEarned: FieldRef<"SoloSession", 'Int'>
    readonly isFreeAttempt: FieldRef<"SoloSession", 'Boolean'>
    readonly currentLevel: FieldRef<"SoloSession", 'Int'>
    readonly questionsAnswered: FieldRef<"SoloSession", 'Int'>
    readonly correctAnswers: FieldRef<"SoloSession", 'Int'>
    readonly madeMistake: FieldRef<"SoloSession", 'Boolean'>
    readonly quitEarly: FieldRef<"SoloSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SoloSession findUnique
   */
  export type SoloSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * Filter, which SoloSession to fetch.
     */
    where: SoloSessionWhereUniqueInput
  }

  /**
   * SoloSession findUniqueOrThrow
   */
  export type SoloSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * Filter, which SoloSession to fetch.
     */
    where: SoloSessionWhereUniqueInput
  }

  /**
   * SoloSession findFirst
   */
  export type SoloSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * Filter, which SoloSession to fetch.
     */
    where?: SoloSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoloSessions to fetch.
     */
    orderBy?: SoloSessionOrderByWithRelationInput | SoloSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoloSessions.
     */
    cursor?: SoloSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoloSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoloSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoloSessions.
     */
    distinct?: SoloSessionScalarFieldEnum | SoloSessionScalarFieldEnum[]
  }

  /**
   * SoloSession findFirstOrThrow
   */
  export type SoloSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * Filter, which SoloSession to fetch.
     */
    where?: SoloSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoloSessions to fetch.
     */
    orderBy?: SoloSessionOrderByWithRelationInput | SoloSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoloSessions.
     */
    cursor?: SoloSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoloSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoloSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoloSessions.
     */
    distinct?: SoloSessionScalarFieldEnum | SoloSessionScalarFieldEnum[]
  }

  /**
   * SoloSession findMany
   */
  export type SoloSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * Filter, which SoloSessions to fetch.
     */
    where?: SoloSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoloSessions to fetch.
     */
    orderBy?: SoloSessionOrderByWithRelationInput | SoloSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SoloSessions.
     */
    cursor?: SoloSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoloSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoloSessions.
     */
    skip?: number
    distinct?: SoloSessionScalarFieldEnum | SoloSessionScalarFieldEnum[]
  }

  /**
   * SoloSession create
   */
  export type SoloSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SoloSession.
     */
    data: XOR<SoloSessionCreateInput, SoloSessionUncheckedCreateInput>
  }

  /**
   * SoloSession createMany
   */
  export type SoloSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SoloSessions.
     */
    data: SoloSessionCreateManyInput | SoloSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SoloSession createManyAndReturn
   */
  export type SoloSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SoloSessions.
     */
    data: SoloSessionCreateManyInput | SoloSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SoloSession update
   */
  export type SoloSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SoloSession.
     */
    data: XOR<SoloSessionUpdateInput, SoloSessionUncheckedUpdateInput>
    /**
     * Choose, which SoloSession to update.
     */
    where: SoloSessionWhereUniqueInput
  }

  /**
   * SoloSession updateMany
   */
  export type SoloSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SoloSessions.
     */
    data: XOR<SoloSessionUpdateManyMutationInput, SoloSessionUncheckedUpdateManyInput>
    /**
     * Filter which SoloSessions to update
     */
    where?: SoloSessionWhereInput
    /**
     * Limit how many SoloSessions to update.
     */
    limit?: number
  }

  /**
   * SoloSession updateManyAndReturn
   */
  export type SoloSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * The data used to update SoloSessions.
     */
    data: XOR<SoloSessionUpdateManyMutationInput, SoloSessionUncheckedUpdateManyInput>
    /**
     * Filter which SoloSessions to update
     */
    where?: SoloSessionWhereInput
    /**
     * Limit how many SoloSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SoloSession upsert
   */
  export type SoloSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SoloSession to update in case it exists.
     */
    where: SoloSessionWhereUniqueInput
    /**
     * In case the SoloSession found by the `where` argument doesn't exist, create a new SoloSession with this data.
     */
    create: XOR<SoloSessionCreateInput, SoloSessionUncheckedCreateInput>
    /**
     * In case the SoloSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoloSessionUpdateInput, SoloSessionUncheckedUpdateInput>
  }

  /**
   * SoloSession delete
   */
  export type SoloSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    /**
     * Filter which SoloSession to delete.
     */
    where: SoloSessionWhereUniqueInput
  }

  /**
   * SoloSession deleteMany
   */
  export type SoloSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoloSessions to delete
     */
    where?: SoloSessionWhereInput
    /**
     * Limit how many SoloSessions to delete.
     */
    limit?: number
  }

  /**
   * SoloSession.questions
   */
  export type SoloSession$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    where?: QuestionAttemptWhereInput
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    cursor?: QuestionAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * SoloSession without action
   */
  export type SoloSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
  }


  /**
   * Model QuestionAttempt
   */

  export type AggregateQuestionAttempt = {
    _count: QuestionAttemptCountAggregateOutputType | null
    _avg: QuestionAttemptAvgAggregateOutputType | null
    _sum: QuestionAttemptSumAggregateOutputType | null
    _min: QuestionAttemptMinAggregateOutputType | null
    _max: QuestionAttemptMaxAggregateOutputType | null
  }

  export type QuestionAttemptAvgAggregateOutputType = {
    questionIndex: number | null
    level: number | null
    kthDigit: number | null
    correctDigit: number | null
  }

  export type QuestionAttemptSumAggregateOutputType = {
    questionIndex: number | null
    level: number | null
    kthDigit: number | null
    correctDigit: number | null
  }

  export type QuestionAttemptMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    questionIndex: number | null
    level: number | null
    expression: string | null
    result: string | null
    side: string | null
    kthDigit: number | null
    correctDigit: number | null
    dailySessionId: string | null
    soloSessionId: string | null
    instantSessionId: string | null
  }

  export type QuestionAttemptMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    questionIndex: number | null
    level: number | null
    expression: string | null
    result: string | null
    side: string | null
    kthDigit: number | null
    correctDigit: number | null
    dailySessionId: string | null
    soloSessionId: string | null
    instantSessionId: string | null
  }

  export type QuestionAttemptCountAggregateOutputType = {
    id: number
    createdAt: number
    questionIndex: number
    level: number
    expression: number
    result: number
    side: number
    kthDigit: number
    correctDigit: number
    dailySessionId: number
    soloSessionId: number
    instantSessionId: number
    _all: number
  }


  export type QuestionAttemptAvgAggregateInputType = {
    questionIndex?: true
    level?: true
    kthDigit?: true
    correctDigit?: true
  }

  export type QuestionAttemptSumAggregateInputType = {
    questionIndex?: true
    level?: true
    kthDigit?: true
    correctDigit?: true
  }

  export type QuestionAttemptMinAggregateInputType = {
    id?: true
    createdAt?: true
    questionIndex?: true
    level?: true
    expression?: true
    result?: true
    side?: true
    kthDigit?: true
    correctDigit?: true
    dailySessionId?: true
    soloSessionId?: true
    instantSessionId?: true
  }

  export type QuestionAttemptMaxAggregateInputType = {
    id?: true
    createdAt?: true
    questionIndex?: true
    level?: true
    expression?: true
    result?: true
    side?: true
    kthDigit?: true
    correctDigit?: true
    dailySessionId?: true
    soloSessionId?: true
    instantSessionId?: true
  }

  export type QuestionAttemptCountAggregateInputType = {
    id?: true
    createdAt?: true
    questionIndex?: true
    level?: true
    expression?: true
    result?: true
    side?: true
    kthDigit?: true
    correctDigit?: true
    dailySessionId?: true
    soloSessionId?: true
    instantSessionId?: true
    _all?: true
  }

  export type QuestionAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAttempt to aggregate.
     */
    where?: QuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAttempts to fetch.
     */
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionAttempts
    **/
    _count?: true | QuestionAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionAttemptMaxAggregateInputType
  }

  export type GetQuestionAttemptAggregateType<T extends QuestionAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionAttempt[P]>
      : GetScalarType<T[P], AggregateQuestionAttempt[P]>
  }




  export type QuestionAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAttemptWhereInput
    orderBy?: QuestionAttemptOrderByWithAggregationInput | QuestionAttemptOrderByWithAggregationInput[]
    by: QuestionAttemptScalarFieldEnum[] | QuestionAttemptScalarFieldEnum
    having?: QuestionAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionAttemptCountAggregateInputType | true
    _avg?: QuestionAttemptAvgAggregateInputType
    _sum?: QuestionAttemptSumAggregateInputType
    _min?: QuestionAttemptMinAggregateInputType
    _max?: QuestionAttemptMaxAggregateInputType
  }

  export type QuestionAttemptGroupByOutputType = {
    id: string
    createdAt: Date
    questionIndex: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySessionId: string | null
    soloSessionId: string | null
    instantSessionId: string | null
    _count: QuestionAttemptCountAggregateOutputType | null
    _avg: QuestionAttemptAvgAggregateOutputType | null
    _sum: QuestionAttemptSumAggregateOutputType | null
    _min: QuestionAttemptMinAggregateOutputType | null
    _max: QuestionAttemptMaxAggregateOutputType | null
  }

  type GetQuestionAttemptGroupByPayload<T extends QuestionAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuestionAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    questionIndex?: boolean
    level?: boolean
    expression?: boolean
    result?: boolean
    side?: boolean
    kthDigit?: boolean
    correctDigit?: boolean
    dailySessionId?: boolean
    soloSessionId?: boolean
    instantSessionId?: boolean
    dailySession?: boolean | QuestionAttempt$dailySessionArgs<ExtArgs>
    soloSession?: boolean | QuestionAttempt$soloSessionArgs<ExtArgs>
    instantSession?: boolean | QuestionAttempt$instantSessionArgs<ExtArgs>
  }, ExtArgs["result"]["questionAttempt"]>

  export type QuestionAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    questionIndex?: boolean
    level?: boolean
    expression?: boolean
    result?: boolean
    side?: boolean
    kthDigit?: boolean
    correctDigit?: boolean
    dailySessionId?: boolean
    soloSessionId?: boolean
    instantSessionId?: boolean
    dailySession?: boolean | QuestionAttempt$dailySessionArgs<ExtArgs>
    soloSession?: boolean | QuestionAttempt$soloSessionArgs<ExtArgs>
    instantSession?: boolean | QuestionAttempt$instantSessionArgs<ExtArgs>
  }, ExtArgs["result"]["questionAttempt"]>

  export type QuestionAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    questionIndex?: boolean
    level?: boolean
    expression?: boolean
    result?: boolean
    side?: boolean
    kthDigit?: boolean
    correctDigit?: boolean
    dailySessionId?: boolean
    soloSessionId?: boolean
    instantSessionId?: boolean
    dailySession?: boolean | QuestionAttempt$dailySessionArgs<ExtArgs>
    soloSession?: boolean | QuestionAttempt$soloSessionArgs<ExtArgs>
    instantSession?: boolean | QuestionAttempt$instantSessionArgs<ExtArgs>
  }, ExtArgs["result"]["questionAttempt"]>

  export type QuestionAttemptSelectScalar = {
    id?: boolean
    createdAt?: boolean
    questionIndex?: boolean
    level?: boolean
    expression?: boolean
    result?: boolean
    side?: boolean
    kthDigit?: boolean
    correctDigit?: boolean
    dailySessionId?: boolean
    soloSessionId?: boolean
    instantSessionId?: boolean
  }

  export type QuestionAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "questionIndex" | "level" | "expression" | "result" | "side" | "kthDigit" | "correctDigit" | "dailySessionId" | "soloSessionId" | "instantSessionId", ExtArgs["result"]["questionAttempt"]>
  export type QuestionAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailySession?: boolean | QuestionAttempt$dailySessionArgs<ExtArgs>
    soloSession?: boolean | QuestionAttempt$soloSessionArgs<ExtArgs>
    instantSession?: boolean | QuestionAttempt$instantSessionArgs<ExtArgs>
  }
  export type QuestionAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailySession?: boolean | QuestionAttempt$dailySessionArgs<ExtArgs>
    soloSession?: boolean | QuestionAttempt$soloSessionArgs<ExtArgs>
    instantSession?: boolean | QuestionAttempt$instantSessionArgs<ExtArgs>
  }
  export type QuestionAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailySession?: boolean | QuestionAttempt$dailySessionArgs<ExtArgs>
    soloSession?: boolean | QuestionAttempt$soloSessionArgs<ExtArgs>
    instantSession?: boolean | QuestionAttempt$instantSessionArgs<ExtArgs>
  }

  export type $QuestionAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionAttempt"
    objects: {
      dailySession: Prisma.$DailyTournamentSessionPayload<ExtArgs> | null
      soloSession: Prisma.$SoloSessionPayload<ExtArgs> | null
      instantSession: Prisma.$InstantSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      questionIndex: number
      level: number
      expression: string
      result: string
      side: string
      kthDigit: number
      correctDigit: number
      dailySessionId: string | null
      soloSessionId: string | null
      instantSessionId: string | null
    }, ExtArgs["result"]["questionAttempt"]>
    composites: {}
  }

  type QuestionAttemptGetPayload<S extends boolean | null | undefined | QuestionAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuestionAttemptPayload, S>

  type QuestionAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionAttemptCountAggregateInputType | true
    }

  export interface QuestionAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionAttempt'], meta: { name: 'QuestionAttempt' } }
    /**
     * Find zero or one QuestionAttempt that matches the filter.
     * @param {QuestionAttemptFindUniqueArgs} args - Arguments to find a QuestionAttempt
     * @example
     * // Get one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionAttemptFindUniqueArgs>(args: SelectSubset<T, QuestionAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuestionAttempt
     * @example
     * // Get one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptFindFirstArgs} args - Arguments to find a QuestionAttempt
     * @example
     * // Get one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionAttemptFindFirstArgs>(args?: SelectSubset<T, QuestionAttemptFindFirstArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptFindFirstOrThrowArgs} args - Arguments to find a QuestionAttempt
     * @example
     * // Get one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionAttempts
     * const questionAttempts = await prisma.questionAttempt.findMany()
     * 
     * // Get first 10 QuestionAttempts
     * const questionAttempts = await prisma.questionAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionAttemptWithIdOnly = await prisma.questionAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionAttemptFindManyArgs>(args?: SelectSubset<T, QuestionAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionAttempt.
     * @param {QuestionAttemptCreateArgs} args - Arguments to create a QuestionAttempt.
     * @example
     * // Create one QuestionAttempt
     * const QuestionAttempt = await prisma.questionAttempt.create({
     *   data: {
     *     // ... data to create a QuestionAttempt
     *   }
     * })
     * 
     */
    create<T extends QuestionAttemptCreateArgs>(args: SelectSubset<T, QuestionAttemptCreateArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionAttempts.
     * @param {QuestionAttemptCreateManyArgs} args - Arguments to create many QuestionAttempts.
     * @example
     * // Create many QuestionAttempts
     * const questionAttempt = await prisma.questionAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionAttemptCreateManyArgs>(args?: SelectSubset<T, QuestionAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionAttempts and returns the data saved in the database.
     * @param {QuestionAttemptCreateManyAndReturnArgs} args - Arguments to create many QuestionAttempts.
     * @example
     * // Create many QuestionAttempts
     * const questionAttempt = await prisma.questionAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionAttempts and only return the `id`
     * const questionAttemptWithIdOnly = await prisma.questionAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionAttempt.
     * @param {QuestionAttemptDeleteArgs} args - Arguments to delete one QuestionAttempt.
     * @example
     * // Delete one QuestionAttempt
     * const QuestionAttempt = await prisma.questionAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuestionAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuestionAttemptDeleteArgs>(args: SelectSubset<T, QuestionAttemptDeleteArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionAttempt.
     * @param {QuestionAttemptUpdateArgs} args - Arguments to update one QuestionAttempt.
     * @example
     * // Update one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionAttemptUpdateArgs>(args: SelectSubset<T, QuestionAttemptUpdateArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionAttempts.
     * @param {QuestionAttemptDeleteManyArgs} args - Arguments to filter QuestionAttempts to delete.
     * @example
     * // Delete a few QuestionAttempts
     * const { count } = await prisma.questionAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionAttemptDeleteManyArgs>(args?: SelectSubset<T, QuestionAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionAttempts
     * const questionAttempt = await prisma.questionAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionAttemptUpdateManyArgs>(args: SelectSubset<T, QuestionAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAttempts and returns the data updated in the database.
     * @param {QuestionAttemptUpdateManyAndReturnArgs} args - Arguments to update many QuestionAttempts.
     * @example
     * // Update many QuestionAttempts
     * const questionAttempt = await prisma.questionAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionAttempts and only return the `id`
     * const questionAttemptWithIdOnly = await prisma.questionAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionAttempt.
     * @param {QuestionAttemptUpsertArgs} args - Arguments to update or create a QuestionAttempt.
     * @example
     * // Update or create a QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.upsert({
     *   create: {
     *     // ... data to create a QuestionAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuestionAttemptUpsertArgs>(args: SelectSubset<T, QuestionAttemptUpsertArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptCountArgs} args - Arguments to filter QuestionAttempts to count.
     * @example
     * // Count the number of QuestionAttempts
     * const count = await prisma.questionAttempt.count({
     *   where: {
     *     // ... the filter for the QuestionAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuestionAttemptCountArgs>(
      args?: Subset<T, QuestionAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAttemptAggregateArgs>(args: Subset<T, QuestionAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuestionAttemptAggregateType<T>>

    /**
     * Group by QuestionAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuestionAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionAttempt model
   */
  readonly fields: QuestionAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dailySession<T extends QuestionAttempt$dailySessionArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAttempt$dailySessionArgs<ExtArgs>>): Prisma__DailyTournamentSessionClient<$Result.GetResult<Prisma.$DailyTournamentSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    soloSession<T extends QuestionAttempt$soloSessionArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAttempt$soloSessionArgs<ExtArgs>>): Prisma__SoloSessionClient<$Result.GetResult<Prisma.$SoloSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    instantSession<T extends QuestionAttempt$instantSessionArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAttempt$instantSessionArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionAttempt model
   */
  interface QuestionAttemptFieldRefs {
    readonly id: FieldRef<"QuestionAttempt", 'String'>
    readonly createdAt: FieldRef<"QuestionAttempt", 'DateTime'>
    readonly questionIndex: FieldRef<"QuestionAttempt", 'Int'>
    readonly level: FieldRef<"QuestionAttempt", 'Int'>
    readonly expression: FieldRef<"QuestionAttempt", 'String'>
    readonly result: FieldRef<"QuestionAttempt", 'String'>
    readonly side: FieldRef<"QuestionAttempt", 'String'>
    readonly kthDigit: FieldRef<"QuestionAttempt", 'Int'>
    readonly correctDigit: FieldRef<"QuestionAttempt", 'Int'>
    readonly dailySessionId: FieldRef<"QuestionAttempt", 'String'>
    readonly soloSessionId: FieldRef<"QuestionAttempt", 'String'>
    readonly instantSessionId: FieldRef<"QuestionAttempt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuestionAttempt findUnique
   */
  export type QuestionAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempt to fetch.
     */
    where: QuestionAttemptWhereUniqueInput
  }

  /**
   * QuestionAttempt findUniqueOrThrow
   */
  export type QuestionAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempt to fetch.
     */
    where: QuestionAttemptWhereUniqueInput
  }

  /**
   * QuestionAttempt findFirst
   */
  export type QuestionAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempt to fetch.
     */
    where?: QuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAttempts to fetch.
     */
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAttempts.
     */
    cursor?: QuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAttempts.
     */
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * QuestionAttempt findFirstOrThrow
   */
  export type QuestionAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempt to fetch.
     */
    where?: QuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAttempts to fetch.
     */
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAttempts.
     */
    cursor?: QuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAttempts.
     */
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * QuestionAttempt findMany
   */
  export type QuestionAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempts to fetch.
     */
    where?: QuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAttempts to fetch.
     */
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionAttempts.
     */
    cursor?: QuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAttempts.
     */
    skip?: number
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * QuestionAttempt create
   */
  export type QuestionAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionAttempt.
     */
    data: XOR<QuestionAttemptCreateInput, QuestionAttemptUncheckedCreateInput>
  }

  /**
   * QuestionAttempt createMany
   */
  export type QuestionAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionAttempts.
     */
    data: QuestionAttemptCreateManyInput | QuestionAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionAttempt createManyAndReturn
   */
  export type QuestionAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionAttempts.
     */
    data: QuestionAttemptCreateManyInput | QuestionAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionAttempt update
   */
  export type QuestionAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionAttempt.
     */
    data: XOR<QuestionAttemptUpdateInput, QuestionAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuestionAttempt to update.
     */
    where: QuestionAttemptWhereUniqueInput
  }

  /**
   * QuestionAttempt updateMany
   */
  export type QuestionAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionAttempts.
     */
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAttempts to update
     */
    where?: QuestionAttemptWhereInput
    /**
     * Limit how many QuestionAttempts to update.
     */
    limit?: number
  }

  /**
   * QuestionAttempt updateManyAndReturn
   */
  export type QuestionAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * The data used to update QuestionAttempts.
     */
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAttempts to update
     */
    where?: QuestionAttemptWhereInput
    /**
     * Limit how many QuestionAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionAttempt upsert
   */
  export type QuestionAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionAttempt to update in case it exists.
     */
    where: QuestionAttemptWhereUniqueInput
    /**
     * In case the QuestionAttempt found by the `where` argument doesn't exist, create a new QuestionAttempt with this data.
     */
    create: XOR<QuestionAttemptCreateInput, QuestionAttemptUncheckedCreateInput>
    /**
     * In case the QuestionAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionAttemptUpdateInput, QuestionAttemptUncheckedUpdateInput>
  }

  /**
   * QuestionAttempt delete
   */
  export type QuestionAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuestionAttempt to delete.
     */
    where: QuestionAttemptWhereUniqueInput
  }

  /**
   * QuestionAttempt deleteMany
   */
  export type QuestionAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAttempts to delete
     */
    where?: QuestionAttemptWhereInput
    /**
     * Limit how many QuestionAttempts to delete.
     */
    limit?: number
  }

  /**
   * QuestionAttempt.dailySession
   */
  export type QuestionAttempt$dailySessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyTournamentSession
     */
    select?: DailyTournamentSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyTournamentSession
     */
    omit?: DailyTournamentSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyTournamentSessionInclude<ExtArgs> | null
    where?: DailyTournamentSessionWhereInput
  }

  /**
   * QuestionAttempt.soloSession
   */
  export type QuestionAttempt$soloSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloSession
     */
    select?: SoloSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloSession
     */
    omit?: SoloSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SoloSessionInclude<ExtArgs> | null
    where?: SoloSessionWhereInput
  }

  /**
   * QuestionAttempt.instantSession
   */
  export type QuestionAttempt$instantSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    where?: InstantSessionWhereInput
  }

  /**
   * QuestionAttempt without action
   */
  export type QuestionAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
  }


  /**
   * Model InstantTournament
   */

  export type AggregateInstantTournament = {
    _count: InstantTournamentCountAggregateOutputType | null
    _avg: InstantTournamentAvgAggregateOutputType | null
    _sum: InstantTournamentSumAggregateOutputType | null
    _min: InstantTournamentMinAggregateOutputType | null
    _max: InstantTournamentMaxAggregateOutputType | null
  }

  export type InstantTournamentAvgAggregateOutputType = {
    maxPlayers: number | null
    playersCount: number | null
  }

  export type InstantTournamentSumAggregateOutputType = {
    maxPlayers: number | null
    playersCount: number | null
  }

  export type InstantTournamentMinAggregateOutputType = {
    id: string | null
    status: $Enums.TournamentStatus | null
    maxPlayers: number | null
    playersCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type InstantTournamentMaxAggregateOutputType = {
    id: string | null
    status: $Enums.TournamentStatus | null
    maxPlayers: number | null
    playersCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
  }

  export type InstantTournamentCountAggregateOutputType = {
    id: number
    status: number
    maxPlayers: number
    playersCount: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    _all: number
  }


  export type InstantTournamentAvgAggregateInputType = {
    maxPlayers?: true
    playersCount?: true
  }

  export type InstantTournamentSumAggregateInputType = {
    maxPlayers?: true
    playersCount?: true
  }

  export type InstantTournamentMinAggregateInputType = {
    id?: true
    status?: true
    maxPlayers?: true
    playersCount?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type InstantTournamentMaxAggregateInputType = {
    id?: true
    status?: true
    maxPlayers?: true
    playersCount?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
  }

  export type InstantTournamentCountAggregateInputType = {
    id?: true
    status?: true
    maxPlayers?: true
    playersCount?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type InstantTournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstantTournament to aggregate.
     */
    where?: InstantTournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantTournaments to fetch.
     */
    orderBy?: InstantTournamentOrderByWithRelationInput | InstantTournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstantTournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantTournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantTournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstantTournaments
    **/
    _count?: true | InstantTournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstantTournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstantTournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstantTournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstantTournamentMaxAggregateInputType
  }

  export type GetInstantTournamentAggregateType<T extends InstantTournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstantTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstantTournament[P]>
      : GetScalarType<T[P], AggregateInstantTournament[P]>
  }




  export type InstantTournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantTournamentWhereInput
    orderBy?: InstantTournamentOrderByWithAggregationInput | InstantTournamentOrderByWithAggregationInput[]
    by: InstantTournamentScalarFieldEnum[] | InstantTournamentScalarFieldEnum
    having?: InstantTournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstantTournamentCountAggregateInputType | true
    _avg?: InstantTournamentAvgAggregateInputType
    _sum?: InstantTournamentSumAggregateInputType
    _min?: InstantTournamentMinAggregateInputType
    _max?: InstantTournamentMaxAggregateInputType
  }

  export type InstantTournamentGroupByOutputType = {
    id: string
    status: $Enums.TournamentStatus
    maxPlayers: number
    playersCount: number
    createdAt: Date
    updatedAt: Date
    expiresAt: Date
    _count: InstantTournamentCountAggregateOutputType | null
    _avg: InstantTournamentAvgAggregateOutputType | null
    _sum: InstantTournamentSumAggregateOutputType | null
    _min: InstantTournamentMinAggregateOutputType | null
    _max: InstantTournamentMaxAggregateOutputType | null
  }

  type GetInstantTournamentGroupByPayload<T extends InstantTournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstantTournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstantTournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstantTournamentGroupByOutputType[P]>
            : GetScalarType<T[P], InstantTournamentGroupByOutputType[P]>
        }
      >
    >


  export type InstantTournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    maxPlayers?: boolean
    playersCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    sessions?: boolean | InstantTournament$sessionsArgs<ExtArgs>
    instantParticipant?: boolean | InstantTournament$instantParticipantArgs<ExtArgs>
    _count?: boolean | InstantTournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantTournament"]>

  export type InstantTournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    maxPlayers?: boolean
    playersCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["instantTournament"]>

  export type InstantTournamentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    maxPlayers?: boolean
    playersCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["instantTournament"]>

  export type InstantTournamentSelectScalar = {
    id?: boolean
    status?: boolean
    maxPlayers?: boolean
    playersCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
  }

  export type InstantTournamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "maxPlayers" | "playersCount" | "createdAt" | "updatedAt" | "expiresAt", ExtArgs["result"]["instantTournament"]>
  export type InstantTournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | InstantTournament$sessionsArgs<ExtArgs>
    instantParticipant?: boolean | InstantTournament$instantParticipantArgs<ExtArgs>
    _count?: boolean | InstantTournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstantTournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InstantTournamentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InstantTournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstantTournament"
    objects: {
      sessions: Prisma.$InstantSessionPayload<ExtArgs>[]
      instantParticipant: Prisma.$InstantParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.TournamentStatus
      maxPlayers: number
      playersCount: number
      createdAt: Date
      updatedAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["instantTournament"]>
    composites: {}
  }

  type InstantTournamentGetPayload<S extends boolean | null | undefined | InstantTournamentDefaultArgs> = $Result.GetResult<Prisma.$InstantTournamentPayload, S>

  type InstantTournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstantTournamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstantTournamentCountAggregateInputType | true
    }

  export interface InstantTournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstantTournament'], meta: { name: 'InstantTournament' } }
    /**
     * Find zero or one InstantTournament that matches the filter.
     * @param {InstantTournamentFindUniqueArgs} args - Arguments to find a InstantTournament
     * @example
     * // Get one InstantTournament
     * const instantTournament = await prisma.instantTournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstantTournamentFindUniqueArgs>(args: SelectSubset<T, InstantTournamentFindUniqueArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstantTournament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstantTournamentFindUniqueOrThrowArgs} args - Arguments to find a InstantTournament
     * @example
     * // Get one InstantTournament
     * const instantTournament = await prisma.instantTournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstantTournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstantTournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstantTournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantTournamentFindFirstArgs} args - Arguments to find a InstantTournament
     * @example
     * // Get one InstantTournament
     * const instantTournament = await prisma.instantTournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstantTournamentFindFirstArgs>(args?: SelectSubset<T, InstantTournamentFindFirstArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstantTournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantTournamentFindFirstOrThrowArgs} args - Arguments to find a InstantTournament
     * @example
     * // Get one InstantTournament
     * const instantTournament = await prisma.instantTournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstantTournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstantTournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstantTournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantTournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstantTournaments
     * const instantTournaments = await prisma.instantTournament.findMany()
     * 
     * // Get first 10 InstantTournaments
     * const instantTournaments = await prisma.instantTournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instantTournamentWithIdOnly = await prisma.instantTournament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstantTournamentFindManyArgs>(args?: SelectSubset<T, InstantTournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstantTournament.
     * @param {InstantTournamentCreateArgs} args - Arguments to create a InstantTournament.
     * @example
     * // Create one InstantTournament
     * const InstantTournament = await prisma.instantTournament.create({
     *   data: {
     *     // ... data to create a InstantTournament
     *   }
     * })
     * 
     */
    create<T extends InstantTournamentCreateArgs>(args: SelectSubset<T, InstantTournamentCreateArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstantTournaments.
     * @param {InstantTournamentCreateManyArgs} args - Arguments to create many InstantTournaments.
     * @example
     * // Create many InstantTournaments
     * const instantTournament = await prisma.instantTournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstantTournamentCreateManyArgs>(args?: SelectSubset<T, InstantTournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstantTournaments and returns the data saved in the database.
     * @param {InstantTournamentCreateManyAndReturnArgs} args - Arguments to create many InstantTournaments.
     * @example
     * // Create many InstantTournaments
     * const instantTournament = await prisma.instantTournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstantTournaments and only return the `id`
     * const instantTournamentWithIdOnly = await prisma.instantTournament.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstantTournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstantTournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstantTournament.
     * @param {InstantTournamentDeleteArgs} args - Arguments to delete one InstantTournament.
     * @example
     * // Delete one InstantTournament
     * const InstantTournament = await prisma.instantTournament.delete({
     *   where: {
     *     // ... filter to delete one InstantTournament
     *   }
     * })
     * 
     */
    delete<T extends InstantTournamentDeleteArgs>(args: SelectSubset<T, InstantTournamentDeleteArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstantTournament.
     * @param {InstantTournamentUpdateArgs} args - Arguments to update one InstantTournament.
     * @example
     * // Update one InstantTournament
     * const instantTournament = await prisma.instantTournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstantTournamentUpdateArgs>(args: SelectSubset<T, InstantTournamentUpdateArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstantTournaments.
     * @param {InstantTournamentDeleteManyArgs} args - Arguments to filter InstantTournaments to delete.
     * @example
     * // Delete a few InstantTournaments
     * const { count } = await prisma.instantTournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstantTournamentDeleteManyArgs>(args?: SelectSubset<T, InstantTournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstantTournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantTournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstantTournaments
     * const instantTournament = await prisma.instantTournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstantTournamentUpdateManyArgs>(args: SelectSubset<T, InstantTournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstantTournaments and returns the data updated in the database.
     * @param {InstantTournamentUpdateManyAndReturnArgs} args - Arguments to update many InstantTournaments.
     * @example
     * // Update many InstantTournaments
     * const instantTournament = await prisma.instantTournament.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstantTournaments and only return the `id`
     * const instantTournamentWithIdOnly = await prisma.instantTournament.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstantTournamentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstantTournamentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstantTournament.
     * @param {InstantTournamentUpsertArgs} args - Arguments to update or create a InstantTournament.
     * @example
     * // Update or create a InstantTournament
     * const instantTournament = await prisma.instantTournament.upsert({
     *   create: {
     *     // ... data to create a InstantTournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstantTournament we want to update
     *   }
     * })
     */
    upsert<T extends InstantTournamentUpsertArgs>(args: SelectSubset<T, InstantTournamentUpsertArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstantTournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantTournamentCountArgs} args - Arguments to filter InstantTournaments to count.
     * @example
     * // Count the number of InstantTournaments
     * const count = await prisma.instantTournament.count({
     *   where: {
     *     // ... the filter for the InstantTournaments we want to count
     *   }
     * })
    **/
    count<T extends InstantTournamentCountArgs>(
      args?: Subset<T, InstantTournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstantTournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstantTournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantTournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstantTournamentAggregateArgs>(args: Subset<T, InstantTournamentAggregateArgs>): Prisma.PrismaPromise<GetInstantTournamentAggregateType<T>>

    /**
     * Group by InstantTournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantTournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstantTournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstantTournamentGroupByArgs['orderBy'] }
        : { orderBy?: InstantTournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstantTournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstantTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstantTournament model
   */
  readonly fields: InstantTournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstantTournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstantTournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends InstantTournament$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, InstantTournament$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instantParticipant<T extends InstantTournament$instantParticipantArgs<ExtArgs> = {}>(args?: Subset<T, InstantTournament$instantParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstantTournament model
   */
  interface InstantTournamentFieldRefs {
    readonly id: FieldRef<"InstantTournament", 'String'>
    readonly status: FieldRef<"InstantTournament", 'TournamentStatus'>
    readonly maxPlayers: FieldRef<"InstantTournament", 'Int'>
    readonly playersCount: FieldRef<"InstantTournament", 'Int'>
    readonly createdAt: FieldRef<"InstantTournament", 'DateTime'>
    readonly updatedAt: FieldRef<"InstantTournament", 'DateTime'>
    readonly expiresAt: FieldRef<"InstantTournament", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstantTournament findUnique
   */
  export type InstantTournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * Filter, which InstantTournament to fetch.
     */
    where: InstantTournamentWhereUniqueInput
  }

  /**
   * InstantTournament findUniqueOrThrow
   */
  export type InstantTournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * Filter, which InstantTournament to fetch.
     */
    where: InstantTournamentWhereUniqueInput
  }

  /**
   * InstantTournament findFirst
   */
  export type InstantTournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * Filter, which InstantTournament to fetch.
     */
    where?: InstantTournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantTournaments to fetch.
     */
    orderBy?: InstantTournamentOrderByWithRelationInput | InstantTournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstantTournaments.
     */
    cursor?: InstantTournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantTournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantTournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstantTournaments.
     */
    distinct?: InstantTournamentScalarFieldEnum | InstantTournamentScalarFieldEnum[]
  }

  /**
   * InstantTournament findFirstOrThrow
   */
  export type InstantTournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * Filter, which InstantTournament to fetch.
     */
    where?: InstantTournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantTournaments to fetch.
     */
    orderBy?: InstantTournamentOrderByWithRelationInput | InstantTournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstantTournaments.
     */
    cursor?: InstantTournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantTournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantTournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstantTournaments.
     */
    distinct?: InstantTournamentScalarFieldEnum | InstantTournamentScalarFieldEnum[]
  }

  /**
   * InstantTournament findMany
   */
  export type InstantTournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * Filter, which InstantTournaments to fetch.
     */
    where?: InstantTournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantTournaments to fetch.
     */
    orderBy?: InstantTournamentOrderByWithRelationInput | InstantTournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstantTournaments.
     */
    cursor?: InstantTournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantTournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantTournaments.
     */
    skip?: number
    distinct?: InstantTournamentScalarFieldEnum | InstantTournamentScalarFieldEnum[]
  }

  /**
   * InstantTournament create
   */
  export type InstantTournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a InstantTournament.
     */
    data: XOR<InstantTournamentCreateInput, InstantTournamentUncheckedCreateInput>
  }

  /**
   * InstantTournament createMany
   */
  export type InstantTournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstantTournaments.
     */
    data: InstantTournamentCreateManyInput | InstantTournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstantTournament createManyAndReturn
   */
  export type InstantTournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * The data used to create many InstantTournaments.
     */
    data: InstantTournamentCreateManyInput | InstantTournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstantTournament update
   */
  export type InstantTournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a InstantTournament.
     */
    data: XOR<InstantTournamentUpdateInput, InstantTournamentUncheckedUpdateInput>
    /**
     * Choose, which InstantTournament to update.
     */
    where: InstantTournamentWhereUniqueInput
  }

  /**
   * InstantTournament updateMany
   */
  export type InstantTournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstantTournaments.
     */
    data: XOR<InstantTournamentUpdateManyMutationInput, InstantTournamentUncheckedUpdateManyInput>
    /**
     * Filter which InstantTournaments to update
     */
    where?: InstantTournamentWhereInput
    /**
     * Limit how many InstantTournaments to update.
     */
    limit?: number
  }

  /**
   * InstantTournament updateManyAndReturn
   */
  export type InstantTournamentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * The data used to update InstantTournaments.
     */
    data: XOR<InstantTournamentUpdateManyMutationInput, InstantTournamentUncheckedUpdateManyInput>
    /**
     * Filter which InstantTournaments to update
     */
    where?: InstantTournamentWhereInput
    /**
     * Limit how many InstantTournaments to update.
     */
    limit?: number
  }

  /**
   * InstantTournament upsert
   */
  export type InstantTournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the InstantTournament to update in case it exists.
     */
    where: InstantTournamentWhereUniqueInput
    /**
     * In case the InstantTournament found by the `where` argument doesn't exist, create a new InstantTournament with this data.
     */
    create: XOR<InstantTournamentCreateInput, InstantTournamentUncheckedCreateInput>
    /**
     * In case the InstantTournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstantTournamentUpdateInput, InstantTournamentUncheckedUpdateInput>
  }

  /**
   * InstantTournament delete
   */
  export type InstantTournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
    /**
     * Filter which InstantTournament to delete.
     */
    where: InstantTournamentWhereUniqueInput
  }

  /**
   * InstantTournament deleteMany
   */
  export type InstantTournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstantTournaments to delete
     */
    where?: InstantTournamentWhereInput
    /**
     * Limit how many InstantTournaments to delete.
     */
    limit?: number
  }

  /**
   * InstantTournament.sessions
   */
  export type InstantTournament$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    where?: InstantSessionWhereInput
    orderBy?: InstantSessionOrderByWithRelationInput | InstantSessionOrderByWithRelationInput[]
    cursor?: InstantSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstantSessionScalarFieldEnum | InstantSessionScalarFieldEnum[]
  }

  /**
   * InstantTournament.instantParticipant
   */
  export type InstantTournament$instantParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    where?: InstantParticipantWhereInput
    orderBy?: InstantParticipantOrderByWithRelationInput | InstantParticipantOrderByWithRelationInput[]
    cursor?: InstantParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstantParticipantScalarFieldEnum | InstantParticipantScalarFieldEnum[]
  }

  /**
   * InstantTournament without action
   */
  export type InstantTournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantTournament
     */
    select?: InstantTournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantTournament
     */
    omit?: InstantTournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantTournamentInclude<ExtArgs> | null
  }


  /**
   * Model InstantSession
   */

  export type AggregateInstantSession = {
    _count: InstantSessionCountAggregateOutputType | null
    _avg: InstantSessionAvgAggregateOutputType | null
    _sum: InstantSessionSumAggregateOutputType | null
    _min: InstantSessionMinAggregateOutputType | null
    _max: InstantSessionMaxAggregateOutputType | null
  }

  export type InstantSessionAvgAggregateOutputType = {
    score: number | null
    finalScore: number | null
    bestScore: number | null
  }

  export type InstantSessionSumAggregateOutputType = {
    score: number | null
    finalScore: number | null
    bestScore: number | null
  }

  export type InstantSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.InstantTournamentSessionStatus | null
    tournamentId: string | null
    score: number | null
    finalScore: number | null
    bestScore: number | null
    startedAt: Date | null
    endsAt: Date | null
    submittedAt: Date | null
  }

  export type InstantSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.InstantTournamentSessionStatus | null
    tournamentId: string | null
    score: number | null
    finalScore: number | null
    bestScore: number | null
    startedAt: Date | null
    endsAt: Date | null
    submittedAt: Date | null
  }

  export type InstantSessionCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    tournamentId: number
    score: number
    finalScore: number
    bestScore: number
    startedAt: number
    endsAt: number
    submittedAt: number
    _all: number
  }


  export type InstantSessionAvgAggregateInputType = {
    score?: true
    finalScore?: true
    bestScore?: true
  }

  export type InstantSessionSumAggregateInputType = {
    score?: true
    finalScore?: true
    bestScore?: true
  }

  export type InstantSessionMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    tournamentId?: true
    score?: true
    finalScore?: true
    bestScore?: true
    startedAt?: true
    endsAt?: true
    submittedAt?: true
  }

  export type InstantSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    tournamentId?: true
    score?: true
    finalScore?: true
    bestScore?: true
    startedAt?: true
    endsAt?: true
    submittedAt?: true
  }

  export type InstantSessionCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    tournamentId?: true
    score?: true
    finalScore?: true
    bestScore?: true
    startedAt?: true
    endsAt?: true
    submittedAt?: true
    _all?: true
  }

  export type InstantSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstantSession to aggregate.
     */
    where?: InstantSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantSessions to fetch.
     */
    orderBy?: InstantSessionOrderByWithRelationInput | InstantSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstantSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstantSessions
    **/
    _count?: true | InstantSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstantSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstantSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstantSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstantSessionMaxAggregateInputType
  }

  export type GetInstantSessionAggregateType<T extends InstantSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstantSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstantSession[P]>
      : GetScalarType<T[P], AggregateInstantSession[P]>
  }




  export type InstantSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantSessionWhereInput
    orderBy?: InstantSessionOrderByWithAggregationInput | InstantSessionOrderByWithAggregationInput[]
    by: InstantSessionScalarFieldEnum[] | InstantSessionScalarFieldEnum
    having?: InstantSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstantSessionCountAggregateInputType | true
    _avg?: InstantSessionAvgAggregateInputType
    _sum?: InstantSessionSumAggregateInputType
    _min?: InstantSessionMinAggregateInputType
    _max?: InstantSessionMaxAggregateInputType
  }

  export type InstantSessionGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.InstantTournamentSessionStatus
    tournamentId: string
    score: number
    finalScore: number | null
    bestScore: number
    startedAt: Date
    endsAt: Date | null
    submittedAt: Date | null
    _count: InstantSessionCountAggregateOutputType | null
    _avg: InstantSessionAvgAggregateOutputType | null
    _sum: InstantSessionSumAggregateOutputType | null
    _min: InstantSessionMinAggregateOutputType | null
    _max: InstantSessionMaxAggregateOutputType | null
  }

  type GetInstantSessionGroupByPayload<T extends InstantSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstantSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstantSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstantSessionGroupByOutputType[P]>
            : GetScalarType<T[P], InstantSessionGroupByOutputType[P]>
        }
      >
    >


  export type InstantSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    tournamentId?: boolean
    score?: boolean
    finalScore?: boolean
    bestScore?: boolean
    startedAt?: boolean
    endsAt?: boolean
    submittedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
    questions?: boolean | InstantSession$questionsArgs<ExtArgs>
    _count?: boolean | InstantSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantSession"]>

  export type InstantSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    tournamentId?: boolean
    score?: boolean
    finalScore?: boolean
    bestScore?: boolean
    startedAt?: boolean
    endsAt?: boolean
    submittedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantSession"]>

  export type InstantSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    tournamentId?: boolean
    score?: boolean
    finalScore?: boolean
    bestScore?: boolean
    startedAt?: boolean
    endsAt?: boolean
    submittedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantSession"]>

  export type InstantSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    tournamentId?: boolean
    score?: boolean
    finalScore?: boolean
    bestScore?: boolean
    startedAt?: boolean
    endsAt?: boolean
    submittedAt?: boolean
  }

  export type InstantSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "tournamentId" | "score" | "finalScore" | "bestScore" | "startedAt" | "endsAt" | "submittedAt", ExtArgs["result"]["instantSession"]>
  export type InstantSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
    questions?: boolean | InstantSession$questionsArgs<ExtArgs>
    _count?: boolean | InstantSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstantSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
  }
  export type InstantSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
  }

  export type $InstantSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstantSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tournament: Prisma.$InstantTournamentPayload<ExtArgs>
      questions: Prisma.$QuestionAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.InstantTournamentSessionStatus
      tournamentId: string
      score: number
      finalScore: number | null
      bestScore: number
      startedAt: Date
      endsAt: Date | null
      submittedAt: Date | null
    }, ExtArgs["result"]["instantSession"]>
    composites: {}
  }

  type InstantSessionGetPayload<S extends boolean | null | undefined | InstantSessionDefaultArgs> = $Result.GetResult<Prisma.$InstantSessionPayload, S>

  type InstantSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstantSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstantSessionCountAggregateInputType | true
    }

  export interface InstantSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstantSession'], meta: { name: 'InstantSession' } }
    /**
     * Find zero or one InstantSession that matches the filter.
     * @param {InstantSessionFindUniqueArgs} args - Arguments to find a InstantSession
     * @example
     * // Get one InstantSession
     * const instantSession = await prisma.instantSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstantSessionFindUniqueArgs>(args: SelectSubset<T, InstantSessionFindUniqueArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstantSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstantSessionFindUniqueOrThrowArgs} args - Arguments to find a InstantSession
     * @example
     * // Get one InstantSession
     * const instantSession = await prisma.instantSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstantSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstantSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstantSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantSessionFindFirstArgs} args - Arguments to find a InstantSession
     * @example
     * // Get one InstantSession
     * const instantSession = await prisma.instantSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstantSessionFindFirstArgs>(args?: SelectSubset<T, InstantSessionFindFirstArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstantSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantSessionFindFirstOrThrowArgs} args - Arguments to find a InstantSession
     * @example
     * // Get one InstantSession
     * const instantSession = await prisma.instantSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstantSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstantSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstantSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstantSessions
     * const instantSessions = await prisma.instantSession.findMany()
     * 
     * // Get first 10 InstantSessions
     * const instantSessions = await prisma.instantSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instantSessionWithIdOnly = await prisma.instantSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstantSessionFindManyArgs>(args?: SelectSubset<T, InstantSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstantSession.
     * @param {InstantSessionCreateArgs} args - Arguments to create a InstantSession.
     * @example
     * // Create one InstantSession
     * const InstantSession = await prisma.instantSession.create({
     *   data: {
     *     // ... data to create a InstantSession
     *   }
     * })
     * 
     */
    create<T extends InstantSessionCreateArgs>(args: SelectSubset<T, InstantSessionCreateArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstantSessions.
     * @param {InstantSessionCreateManyArgs} args - Arguments to create many InstantSessions.
     * @example
     * // Create many InstantSessions
     * const instantSession = await prisma.instantSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstantSessionCreateManyArgs>(args?: SelectSubset<T, InstantSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstantSessions and returns the data saved in the database.
     * @param {InstantSessionCreateManyAndReturnArgs} args - Arguments to create many InstantSessions.
     * @example
     * // Create many InstantSessions
     * const instantSession = await prisma.instantSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstantSessions and only return the `id`
     * const instantSessionWithIdOnly = await prisma.instantSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstantSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, InstantSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstantSession.
     * @param {InstantSessionDeleteArgs} args - Arguments to delete one InstantSession.
     * @example
     * // Delete one InstantSession
     * const InstantSession = await prisma.instantSession.delete({
     *   where: {
     *     // ... filter to delete one InstantSession
     *   }
     * })
     * 
     */
    delete<T extends InstantSessionDeleteArgs>(args: SelectSubset<T, InstantSessionDeleteArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstantSession.
     * @param {InstantSessionUpdateArgs} args - Arguments to update one InstantSession.
     * @example
     * // Update one InstantSession
     * const instantSession = await prisma.instantSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstantSessionUpdateArgs>(args: SelectSubset<T, InstantSessionUpdateArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstantSessions.
     * @param {InstantSessionDeleteManyArgs} args - Arguments to filter InstantSessions to delete.
     * @example
     * // Delete a few InstantSessions
     * const { count } = await prisma.instantSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstantSessionDeleteManyArgs>(args?: SelectSubset<T, InstantSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstantSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstantSessions
     * const instantSession = await prisma.instantSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstantSessionUpdateManyArgs>(args: SelectSubset<T, InstantSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstantSessions and returns the data updated in the database.
     * @param {InstantSessionUpdateManyAndReturnArgs} args - Arguments to update many InstantSessions.
     * @example
     * // Update many InstantSessions
     * const instantSession = await prisma.instantSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstantSessions and only return the `id`
     * const instantSessionWithIdOnly = await prisma.instantSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstantSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, InstantSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstantSession.
     * @param {InstantSessionUpsertArgs} args - Arguments to update or create a InstantSession.
     * @example
     * // Update or create a InstantSession
     * const instantSession = await prisma.instantSession.upsert({
     *   create: {
     *     // ... data to create a InstantSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstantSession we want to update
     *   }
     * })
     */
    upsert<T extends InstantSessionUpsertArgs>(args: SelectSubset<T, InstantSessionUpsertArgs<ExtArgs>>): Prisma__InstantSessionClient<$Result.GetResult<Prisma.$InstantSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstantSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantSessionCountArgs} args - Arguments to filter InstantSessions to count.
     * @example
     * // Count the number of InstantSessions
     * const count = await prisma.instantSession.count({
     *   where: {
     *     // ... the filter for the InstantSessions we want to count
     *   }
     * })
    **/
    count<T extends InstantSessionCountArgs>(
      args?: Subset<T, InstantSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstantSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstantSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstantSessionAggregateArgs>(args: Subset<T, InstantSessionAggregateArgs>): Prisma.PrismaPromise<GetInstantSessionAggregateType<T>>

    /**
     * Group by InstantSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstantSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstantSessionGroupByArgs['orderBy'] }
        : { orderBy?: InstantSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstantSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstantSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstantSession model
   */
  readonly fields: InstantSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstantSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstantSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends InstantTournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstantTournamentDefaultArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends InstantSession$questionsArgs<ExtArgs> = {}>(args?: Subset<T, InstantSession$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstantSession model
   */
  interface InstantSessionFieldRefs {
    readonly id: FieldRef<"InstantSession", 'String'>
    readonly userId: FieldRef<"InstantSession", 'String'>
    readonly status: FieldRef<"InstantSession", 'InstantTournamentSessionStatus'>
    readonly tournamentId: FieldRef<"InstantSession", 'String'>
    readonly score: FieldRef<"InstantSession", 'Int'>
    readonly finalScore: FieldRef<"InstantSession", 'Int'>
    readonly bestScore: FieldRef<"InstantSession", 'Int'>
    readonly startedAt: FieldRef<"InstantSession", 'DateTime'>
    readonly endsAt: FieldRef<"InstantSession", 'DateTime'>
    readonly submittedAt: FieldRef<"InstantSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstantSession findUnique
   */
  export type InstantSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * Filter, which InstantSession to fetch.
     */
    where: InstantSessionWhereUniqueInput
  }

  /**
   * InstantSession findUniqueOrThrow
   */
  export type InstantSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * Filter, which InstantSession to fetch.
     */
    where: InstantSessionWhereUniqueInput
  }

  /**
   * InstantSession findFirst
   */
  export type InstantSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * Filter, which InstantSession to fetch.
     */
    where?: InstantSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantSessions to fetch.
     */
    orderBy?: InstantSessionOrderByWithRelationInput | InstantSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstantSessions.
     */
    cursor?: InstantSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstantSessions.
     */
    distinct?: InstantSessionScalarFieldEnum | InstantSessionScalarFieldEnum[]
  }

  /**
   * InstantSession findFirstOrThrow
   */
  export type InstantSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * Filter, which InstantSession to fetch.
     */
    where?: InstantSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantSessions to fetch.
     */
    orderBy?: InstantSessionOrderByWithRelationInput | InstantSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstantSessions.
     */
    cursor?: InstantSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstantSessions.
     */
    distinct?: InstantSessionScalarFieldEnum | InstantSessionScalarFieldEnum[]
  }

  /**
   * InstantSession findMany
   */
  export type InstantSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * Filter, which InstantSessions to fetch.
     */
    where?: InstantSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantSessions to fetch.
     */
    orderBy?: InstantSessionOrderByWithRelationInput | InstantSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstantSessions.
     */
    cursor?: InstantSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantSessions.
     */
    skip?: number
    distinct?: InstantSessionScalarFieldEnum | InstantSessionScalarFieldEnum[]
  }

  /**
   * InstantSession create
   */
  export type InstantSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a InstantSession.
     */
    data: XOR<InstantSessionCreateInput, InstantSessionUncheckedCreateInput>
  }

  /**
   * InstantSession createMany
   */
  export type InstantSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstantSessions.
     */
    data: InstantSessionCreateManyInput | InstantSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstantSession createManyAndReturn
   */
  export type InstantSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * The data used to create many InstantSessions.
     */
    data: InstantSessionCreateManyInput | InstantSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstantSession update
   */
  export type InstantSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a InstantSession.
     */
    data: XOR<InstantSessionUpdateInput, InstantSessionUncheckedUpdateInput>
    /**
     * Choose, which InstantSession to update.
     */
    where: InstantSessionWhereUniqueInput
  }

  /**
   * InstantSession updateMany
   */
  export type InstantSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstantSessions.
     */
    data: XOR<InstantSessionUpdateManyMutationInput, InstantSessionUncheckedUpdateManyInput>
    /**
     * Filter which InstantSessions to update
     */
    where?: InstantSessionWhereInput
    /**
     * Limit how many InstantSessions to update.
     */
    limit?: number
  }

  /**
   * InstantSession updateManyAndReturn
   */
  export type InstantSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * The data used to update InstantSessions.
     */
    data: XOR<InstantSessionUpdateManyMutationInput, InstantSessionUncheckedUpdateManyInput>
    /**
     * Filter which InstantSessions to update
     */
    where?: InstantSessionWhereInput
    /**
     * Limit how many InstantSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstantSession upsert
   */
  export type InstantSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the InstantSession to update in case it exists.
     */
    where: InstantSessionWhereUniqueInput
    /**
     * In case the InstantSession found by the `where` argument doesn't exist, create a new InstantSession with this data.
     */
    create: XOR<InstantSessionCreateInput, InstantSessionUncheckedCreateInput>
    /**
     * In case the InstantSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstantSessionUpdateInput, InstantSessionUncheckedUpdateInput>
  }

  /**
   * InstantSession delete
   */
  export type InstantSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
    /**
     * Filter which InstantSession to delete.
     */
    where: InstantSessionWhereUniqueInput
  }

  /**
   * InstantSession deleteMany
   */
  export type InstantSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstantSessions to delete
     */
    where?: InstantSessionWhereInput
    /**
     * Limit how many InstantSessions to delete.
     */
    limit?: number
  }

  /**
   * InstantSession.questions
   */
  export type InstantSession$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    where?: QuestionAttemptWhereInput
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    cursor?: QuestionAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * InstantSession without action
   */
  export type InstantSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantSession
     */
    select?: InstantSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantSession
     */
    omit?: InstantSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantSessionInclude<ExtArgs> | null
  }


  /**
   * Model InstantParticipant
   */

  export type AggregateInstantParticipant = {
    _count: InstantParticipantCountAggregateOutputType | null
    _avg: InstantParticipantAvgAggregateOutputType | null
    _sum: InstantParticipantSumAggregateOutputType | null
    _min: InstantParticipantMinAggregateOutputType | null
    _max: InstantParticipantMaxAggregateOutputType | null
  }

  export type InstantParticipantAvgAggregateOutputType = {
    joinOrder: number | null
    finalScore: number | null
    finalRank: number | null
  }

  export type InstantParticipantSumAggregateOutputType = {
    joinOrder: number | null
    finalScore: number | null
    finalRank: number | null
  }

  export type InstantParticipantMinAggregateOutputType = {
    tournamentId: string | null
    userId: string | null
    joinedAt: Date | null
    joinOrder: number | null
    sessionStarted: boolean | null
    finalScore: number | null
    submittedAt: Date | null
    finalRank: number | null
  }

  export type InstantParticipantMaxAggregateOutputType = {
    tournamentId: string | null
    userId: string | null
    joinedAt: Date | null
    joinOrder: number | null
    sessionStarted: boolean | null
    finalScore: number | null
    submittedAt: Date | null
    finalRank: number | null
  }

  export type InstantParticipantCountAggregateOutputType = {
    tournamentId: number
    userId: number
    joinedAt: number
    joinOrder: number
    sessionStarted: number
    finalScore: number
    submittedAt: number
    finalRank: number
    _all: number
  }


  export type InstantParticipantAvgAggregateInputType = {
    joinOrder?: true
    finalScore?: true
    finalRank?: true
  }

  export type InstantParticipantSumAggregateInputType = {
    joinOrder?: true
    finalScore?: true
    finalRank?: true
  }

  export type InstantParticipantMinAggregateInputType = {
    tournamentId?: true
    userId?: true
    joinedAt?: true
    joinOrder?: true
    sessionStarted?: true
    finalScore?: true
    submittedAt?: true
    finalRank?: true
  }

  export type InstantParticipantMaxAggregateInputType = {
    tournamentId?: true
    userId?: true
    joinedAt?: true
    joinOrder?: true
    sessionStarted?: true
    finalScore?: true
    submittedAt?: true
    finalRank?: true
  }

  export type InstantParticipantCountAggregateInputType = {
    tournamentId?: true
    userId?: true
    joinedAt?: true
    joinOrder?: true
    sessionStarted?: true
    finalScore?: true
    submittedAt?: true
    finalRank?: true
    _all?: true
  }

  export type InstantParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstantParticipant to aggregate.
     */
    where?: InstantParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantParticipants to fetch.
     */
    orderBy?: InstantParticipantOrderByWithRelationInput | InstantParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstantParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstantParticipants
    **/
    _count?: true | InstantParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstantParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstantParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstantParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstantParticipantMaxAggregateInputType
  }

  export type GetInstantParticipantAggregateType<T extends InstantParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateInstantParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstantParticipant[P]>
      : GetScalarType<T[P], AggregateInstantParticipant[P]>
  }




  export type InstantParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantParticipantWhereInput
    orderBy?: InstantParticipantOrderByWithAggregationInput | InstantParticipantOrderByWithAggregationInput[]
    by: InstantParticipantScalarFieldEnum[] | InstantParticipantScalarFieldEnum
    having?: InstantParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstantParticipantCountAggregateInputType | true
    _avg?: InstantParticipantAvgAggregateInputType
    _sum?: InstantParticipantSumAggregateInputType
    _min?: InstantParticipantMinAggregateInputType
    _max?: InstantParticipantMaxAggregateInputType
  }

  export type InstantParticipantGroupByOutputType = {
    tournamentId: string
    userId: string
    joinedAt: Date
    joinOrder: number
    sessionStarted: boolean
    finalScore: number | null
    submittedAt: Date | null
    finalRank: number | null
    _count: InstantParticipantCountAggregateOutputType | null
    _avg: InstantParticipantAvgAggregateOutputType | null
    _sum: InstantParticipantSumAggregateOutputType | null
    _min: InstantParticipantMinAggregateOutputType | null
    _max: InstantParticipantMaxAggregateOutputType | null
  }

  type GetInstantParticipantGroupByPayload<T extends InstantParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstantParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstantParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstantParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], InstantParticipantGroupByOutputType[P]>
        }
      >
    >


  export type InstantParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tournamentId?: boolean
    userId?: boolean
    joinedAt?: boolean
    joinOrder?: boolean
    sessionStarted?: boolean
    finalScore?: boolean
    submittedAt?: boolean
    finalRank?: boolean
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantParticipant"]>

  export type InstantParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tournamentId?: boolean
    userId?: boolean
    joinedAt?: boolean
    joinOrder?: boolean
    sessionStarted?: boolean
    finalScore?: boolean
    submittedAt?: boolean
    finalRank?: boolean
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantParticipant"]>

  export type InstantParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tournamentId?: boolean
    userId?: boolean
    joinedAt?: boolean
    joinOrder?: boolean
    sessionStarted?: boolean
    finalScore?: boolean
    submittedAt?: boolean
    finalRank?: boolean
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantParticipant"]>

  export type InstantParticipantSelectScalar = {
    tournamentId?: boolean
    userId?: boolean
    joinedAt?: boolean
    joinOrder?: boolean
    sessionStarted?: boolean
    finalScore?: boolean
    submittedAt?: boolean
    finalRank?: boolean
  }

  export type InstantParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tournamentId" | "userId" | "joinedAt" | "joinOrder" | "sessionStarted" | "finalScore" | "submittedAt" | "finalRank", ExtArgs["result"]["instantParticipant"]>
  export type InstantParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InstantParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InstantParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tournament?: boolean | InstantTournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InstantParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstantParticipant"
    objects: {
      tournament: Prisma.$InstantTournamentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tournamentId: string
      userId: string
      joinedAt: Date
      joinOrder: number
      sessionStarted: boolean
      finalScore: number | null
      submittedAt: Date | null
      finalRank: number | null
    }, ExtArgs["result"]["instantParticipant"]>
    composites: {}
  }

  type InstantParticipantGetPayload<S extends boolean | null | undefined | InstantParticipantDefaultArgs> = $Result.GetResult<Prisma.$InstantParticipantPayload, S>

  type InstantParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstantParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstantParticipantCountAggregateInputType | true
    }

  export interface InstantParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstantParticipant'], meta: { name: 'InstantParticipant' } }
    /**
     * Find zero or one InstantParticipant that matches the filter.
     * @param {InstantParticipantFindUniqueArgs} args - Arguments to find a InstantParticipant
     * @example
     * // Get one InstantParticipant
     * const instantParticipant = await prisma.instantParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstantParticipantFindUniqueArgs>(args: SelectSubset<T, InstantParticipantFindUniqueArgs<ExtArgs>>): Prisma__InstantParticipantClient<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstantParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstantParticipantFindUniqueOrThrowArgs} args - Arguments to find a InstantParticipant
     * @example
     * // Get one InstantParticipant
     * const instantParticipant = await prisma.instantParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstantParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, InstantParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstantParticipantClient<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstantParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantParticipantFindFirstArgs} args - Arguments to find a InstantParticipant
     * @example
     * // Get one InstantParticipant
     * const instantParticipant = await prisma.instantParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstantParticipantFindFirstArgs>(args?: SelectSubset<T, InstantParticipantFindFirstArgs<ExtArgs>>): Prisma__InstantParticipantClient<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstantParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantParticipantFindFirstOrThrowArgs} args - Arguments to find a InstantParticipant
     * @example
     * // Get one InstantParticipant
     * const instantParticipant = await prisma.instantParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstantParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, InstantParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstantParticipantClient<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstantParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstantParticipants
     * const instantParticipants = await prisma.instantParticipant.findMany()
     * 
     * // Get first 10 InstantParticipants
     * const instantParticipants = await prisma.instantParticipant.findMany({ take: 10 })
     * 
     * // Only select the `tournamentId`
     * const instantParticipantWithTournamentIdOnly = await prisma.instantParticipant.findMany({ select: { tournamentId: true } })
     * 
     */
    findMany<T extends InstantParticipantFindManyArgs>(args?: SelectSubset<T, InstantParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstantParticipant.
     * @param {InstantParticipantCreateArgs} args - Arguments to create a InstantParticipant.
     * @example
     * // Create one InstantParticipant
     * const InstantParticipant = await prisma.instantParticipant.create({
     *   data: {
     *     // ... data to create a InstantParticipant
     *   }
     * })
     * 
     */
    create<T extends InstantParticipantCreateArgs>(args: SelectSubset<T, InstantParticipantCreateArgs<ExtArgs>>): Prisma__InstantParticipantClient<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstantParticipants.
     * @param {InstantParticipantCreateManyArgs} args - Arguments to create many InstantParticipants.
     * @example
     * // Create many InstantParticipants
     * const instantParticipant = await prisma.instantParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstantParticipantCreateManyArgs>(args?: SelectSubset<T, InstantParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstantParticipants and returns the data saved in the database.
     * @param {InstantParticipantCreateManyAndReturnArgs} args - Arguments to create many InstantParticipants.
     * @example
     * // Create many InstantParticipants
     * const instantParticipant = await prisma.instantParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstantParticipants and only return the `tournamentId`
     * const instantParticipantWithTournamentIdOnly = await prisma.instantParticipant.createManyAndReturn({
     *   select: { tournamentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstantParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, InstantParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstantParticipant.
     * @param {InstantParticipantDeleteArgs} args - Arguments to delete one InstantParticipant.
     * @example
     * // Delete one InstantParticipant
     * const InstantParticipant = await prisma.instantParticipant.delete({
     *   where: {
     *     // ... filter to delete one InstantParticipant
     *   }
     * })
     * 
     */
    delete<T extends InstantParticipantDeleteArgs>(args: SelectSubset<T, InstantParticipantDeleteArgs<ExtArgs>>): Prisma__InstantParticipantClient<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstantParticipant.
     * @param {InstantParticipantUpdateArgs} args - Arguments to update one InstantParticipant.
     * @example
     * // Update one InstantParticipant
     * const instantParticipant = await prisma.instantParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstantParticipantUpdateArgs>(args: SelectSubset<T, InstantParticipantUpdateArgs<ExtArgs>>): Prisma__InstantParticipantClient<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstantParticipants.
     * @param {InstantParticipantDeleteManyArgs} args - Arguments to filter InstantParticipants to delete.
     * @example
     * // Delete a few InstantParticipants
     * const { count } = await prisma.instantParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstantParticipantDeleteManyArgs>(args?: SelectSubset<T, InstantParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstantParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstantParticipants
     * const instantParticipant = await prisma.instantParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstantParticipantUpdateManyArgs>(args: SelectSubset<T, InstantParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstantParticipants and returns the data updated in the database.
     * @param {InstantParticipantUpdateManyAndReturnArgs} args - Arguments to update many InstantParticipants.
     * @example
     * // Update many InstantParticipants
     * const instantParticipant = await prisma.instantParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstantParticipants and only return the `tournamentId`
     * const instantParticipantWithTournamentIdOnly = await prisma.instantParticipant.updateManyAndReturn({
     *   select: { tournamentId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstantParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, InstantParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstantParticipant.
     * @param {InstantParticipantUpsertArgs} args - Arguments to update or create a InstantParticipant.
     * @example
     * // Update or create a InstantParticipant
     * const instantParticipant = await prisma.instantParticipant.upsert({
     *   create: {
     *     // ... data to create a InstantParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstantParticipant we want to update
     *   }
     * })
     */
    upsert<T extends InstantParticipantUpsertArgs>(args: SelectSubset<T, InstantParticipantUpsertArgs<ExtArgs>>): Prisma__InstantParticipantClient<$Result.GetResult<Prisma.$InstantParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstantParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantParticipantCountArgs} args - Arguments to filter InstantParticipants to count.
     * @example
     * // Count the number of InstantParticipants
     * const count = await prisma.instantParticipant.count({
     *   where: {
     *     // ... the filter for the InstantParticipants we want to count
     *   }
     * })
    **/
    count<T extends InstantParticipantCountArgs>(
      args?: Subset<T, InstantParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstantParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstantParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstantParticipantAggregateArgs>(args: Subset<T, InstantParticipantAggregateArgs>): Prisma.PrismaPromise<GetInstantParticipantAggregateType<T>>

    /**
     * Group by InstantParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstantParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstantParticipantGroupByArgs['orderBy'] }
        : { orderBy?: InstantParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstantParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstantParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstantParticipant model
   */
  readonly fields: InstantParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstantParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstantParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tournament<T extends InstantTournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstantTournamentDefaultArgs<ExtArgs>>): Prisma__InstantTournamentClient<$Result.GetResult<Prisma.$InstantTournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstantParticipant model
   */
  interface InstantParticipantFieldRefs {
    readonly tournamentId: FieldRef<"InstantParticipant", 'String'>
    readonly userId: FieldRef<"InstantParticipant", 'String'>
    readonly joinedAt: FieldRef<"InstantParticipant", 'DateTime'>
    readonly joinOrder: FieldRef<"InstantParticipant", 'Int'>
    readonly sessionStarted: FieldRef<"InstantParticipant", 'Boolean'>
    readonly finalScore: FieldRef<"InstantParticipant", 'Int'>
    readonly submittedAt: FieldRef<"InstantParticipant", 'DateTime'>
    readonly finalRank: FieldRef<"InstantParticipant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InstantParticipant findUnique
   */
  export type InstantParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * Filter, which InstantParticipant to fetch.
     */
    where: InstantParticipantWhereUniqueInput
  }

  /**
   * InstantParticipant findUniqueOrThrow
   */
  export type InstantParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * Filter, which InstantParticipant to fetch.
     */
    where: InstantParticipantWhereUniqueInput
  }

  /**
   * InstantParticipant findFirst
   */
  export type InstantParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * Filter, which InstantParticipant to fetch.
     */
    where?: InstantParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantParticipants to fetch.
     */
    orderBy?: InstantParticipantOrderByWithRelationInput | InstantParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstantParticipants.
     */
    cursor?: InstantParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstantParticipants.
     */
    distinct?: InstantParticipantScalarFieldEnum | InstantParticipantScalarFieldEnum[]
  }

  /**
   * InstantParticipant findFirstOrThrow
   */
  export type InstantParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * Filter, which InstantParticipant to fetch.
     */
    where?: InstantParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantParticipants to fetch.
     */
    orderBy?: InstantParticipantOrderByWithRelationInput | InstantParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstantParticipants.
     */
    cursor?: InstantParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstantParticipants.
     */
    distinct?: InstantParticipantScalarFieldEnum | InstantParticipantScalarFieldEnum[]
  }

  /**
   * InstantParticipant findMany
   */
  export type InstantParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * Filter, which InstantParticipants to fetch.
     */
    where?: InstantParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantParticipants to fetch.
     */
    orderBy?: InstantParticipantOrderByWithRelationInput | InstantParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstantParticipants.
     */
    cursor?: InstantParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantParticipants.
     */
    skip?: number
    distinct?: InstantParticipantScalarFieldEnum | InstantParticipantScalarFieldEnum[]
  }

  /**
   * InstantParticipant create
   */
  export type InstantParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a InstantParticipant.
     */
    data: XOR<InstantParticipantCreateInput, InstantParticipantUncheckedCreateInput>
  }

  /**
   * InstantParticipant createMany
   */
  export type InstantParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstantParticipants.
     */
    data: InstantParticipantCreateManyInput | InstantParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstantParticipant createManyAndReturn
   */
  export type InstantParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many InstantParticipants.
     */
    data: InstantParticipantCreateManyInput | InstantParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstantParticipant update
   */
  export type InstantParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a InstantParticipant.
     */
    data: XOR<InstantParticipantUpdateInput, InstantParticipantUncheckedUpdateInput>
    /**
     * Choose, which InstantParticipant to update.
     */
    where: InstantParticipantWhereUniqueInput
  }

  /**
   * InstantParticipant updateMany
   */
  export type InstantParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstantParticipants.
     */
    data: XOR<InstantParticipantUpdateManyMutationInput, InstantParticipantUncheckedUpdateManyInput>
    /**
     * Filter which InstantParticipants to update
     */
    where?: InstantParticipantWhereInput
    /**
     * Limit how many InstantParticipants to update.
     */
    limit?: number
  }

  /**
   * InstantParticipant updateManyAndReturn
   */
  export type InstantParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * The data used to update InstantParticipants.
     */
    data: XOR<InstantParticipantUpdateManyMutationInput, InstantParticipantUncheckedUpdateManyInput>
    /**
     * Filter which InstantParticipants to update
     */
    where?: InstantParticipantWhereInput
    /**
     * Limit how many InstantParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstantParticipant upsert
   */
  export type InstantParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the InstantParticipant to update in case it exists.
     */
    where: InstantParticipantWhereUniqueInput
    /**
     * In case the InstantParticipant found by the `where` argument doesn't exist, create a new InstantParticipant with this data.
     */
    create: XOR<InstantParticipantCreateInput, InstantParticipantUncheckedCreateInput>
    /**
     * In case the InstantParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstantParticipantUpdateInput, InstantParticipantUncheckedUpdateInput>
  }

  /**
   * InstantParticipant delete
   */
  export type InstantParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
    /**
     * Filter which InstantParticipant to delete.
     */
    where: InstantParticipantWhereUniqueInput
  }

  /**
   * InstantParticipant deleteMany
   */
  export type InstantParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstantParticipants to delete
     */
    where?: InstantParticipantWhereInput
    /**
     * Limit how many InstantParticipants to delete.
     */
    limit?: number
  }

  /**
   * InstantParticipant without action
   */
  export type InstantParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantParticipant
     */
    select?: InstantParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantParticipant
     */
    omit?: InstantParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantParticipantInclude<ExtArgs> | null
  }


  /**
   * Model DailyLeaderboard
   */

  export type AggregateDailyLeaderboard = {
    _count: DailyLeaderboardCountAggregateOutputType | null
    _avg: DailyLeaderboardAvgAggregateOutputType | null
    _sum: DailyLeaderboardSumAggregateOutputType | null
    _min: DailyLeaderboardMinAggregateOutputType | null
    _max: DailyLeaderboardMaxAggregateOutputType | null
  }

  export type DailyLeaderboardAvgAggregateOutputType = {
    bestScore: number | null
    rank: number | null
    coinPoints: number | null
  }

  export type DailyLeaderboardSumAggregateOutputType = {
    bestScore: number | null
    rank: number | null
    coinPoints: number | null
  }

  export type DailyLeaderboardMinAggregateOutputType = {
    id: string | null
    date: Date | null
    userId: string | null
    bestScore: number | null
    rank: number | null
    coinPoints: number | null
    updatedAt: Date | null
  }

  export type DailyLeaderboardMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    userId: string | null
    bestScore: number | null
    rank: number | null
    coinPoints: number | null
    updatedAt: Date | null
  }

  export type DailyLeaderboardCountAggregateOutputType = {
    id: number
    date: number
    userId: number
    bestScore: number
    rank: number
    coinPoints: number
    updatedAt: number
    _all: number
  }


  export type DailyLeaderboardAvgAggregateInputType = {
    bestScore?: true
    rank?: true
    coinPoints?: true
  }

  export type DailyLeaderboardSumAggregateInputType = {
    bestScore?: true
    rank?: true
    coinPoints?: true
  }

  export type DailyLeaderboardMinAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    bestScore?: true
    rank?: true
    coinPoints?: true
    updatedAt?: true
  }

  export type DailyLeaderboardMaxAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    bestScore?: true
    rank?: true
    coinPoints?: true
    updatedAt?: true
  }

  export type DailyLeaderboardCountAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    bestScore?: true
    rank?: true
    coinPoints?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyLeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyLeaderboard to aggregate.
     */
    where?: DailyLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyLeaderboards to fetch.
     */
    orderBy?: DailyLeaderboardOrderByWithRelationInput | DailyLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyLeaderboards
    **/
    _count?: true | DailyLeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyLeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyLeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyLeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyLeaderboardMaxAggregateInputType
  }

  export type GetDailyLeaderboardAggregateType<T extends DailyLeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyLeaderboard[P]>
      : GetScalarType<T[P], AggregateDailyLeaderboard[P]>
  }




  export type DailyLeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyLeaderboardWhereInput
    orderBy?: DailyLeaderboardOrderByWithAggregationInput | DailyLeaderboardOrderByWithAggregationInput[]
    by: DailyLeaderboardScalarFieldEnum[] | DailyLeaderboardScalarFieldEnum
    having?: DailyLeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyLeaderboardCountAggregateInputType | true
    _avg?: DailyLeaderboardAvgAggregateInputType
    _sum?: DailyLeaderboardSumAggregateInputType
    _min?: DailyLeaderboardMinAggregateInputType
    _max?: DailyLeaderboardMaxAggregateInputType
  }

  export type DailyLeaderboardGroupByOutputType = {
    id: string
    date: Date
    userId: string
    bestScore: number
    rank: number
    coinPoints: number
    updatedAt: Date
    _count: DailyLeaderboardCountAggregateOutputType | null
    _avg: DailyLeaderboardAvgAggregateOutputType | null
    _sum: DailyLeaderboardSumAggregateOutputType | null
    _min: DailyLeaderboardMinAggregateOutputType | null
    _max: DailyLeaderboardMaxAggregateOutputType | null
  }

  type GetDailyLeaderboardGroupByPayload<T extends DailyLeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyLeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyLeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyLeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], DailyLeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type DailyLeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    bestScore?: boolean
    rank?: boolean
    coinPoints?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyLeaderboard"]>

  export type DailyLeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    bestScore?: boolean
    rank?: boolean
    coinPoints?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyLeaderboard"]>

  export type DailyLeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    bestScore?: boolean
    rank?: boolean
    coinPoints?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyLeaderboard"]>

  export type DailyLeaderboardSelectScalar = {
    id?: boolean
    date?: boolean
    userId?: boolean
    bestScore?: boolean
    rank?: boolean
    coinPoints?: boolean
    updatedAt?: boolean
  }

  export type DailyLeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "userId" | "bestScore" | "rank" | "coinPoints" | "updatedAt", ExtArgs["result"]["dailyLeaderboard"]>
  export type DailyLeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyLeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyLeaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyLeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyLeaderboard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      userId: string
      bestScore: number
      rank: number
      coinPoints: number
      updatedAt: Date
    }, ExtArgs["result"]["dailyLeaderboard"]>
    composites: {}
  }

  type DailyLeaderboardGetPayload<S extends boolean | null | undefined | DailyLeaderboardDefaultArgs> = $Result.GetResult<Prisma.$DailyLeaderboardPayload, S>

  type DailyLeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyLeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyLeaderboardCountAggregateInputType | true
    }

  export interface DailyLeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyLeaderboard'], meta: { name: 'DailyLeaderboard' } }
    /**
     * Find zero or one DailyLeaderboard that matches the filter.
     * @param {DailyLeaderboardFindUniqueArgs} args - Arguments to find a DailyLeaderboard
     * @example
     * // Get one DailyLeaderboard
     * const dailyLeaderboard = await prisma.dailyLeaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyLeaderboardFindUniqueArgs>(args: SelectSubset<T, DailyLeaderboardFindUniqueArgs<ExtArgs>>): Prisma__DailyLeaderboardClient<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyLeaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyLeaderboardFindUniqueOrThrowArgs} args - Arguments to find a DailyLeaderboard
     * @example
     * // Get one DailyLeaderboard
     * const dailyLeaderboard = await prisma.dailyLeaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyLeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyLeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyLeaderboardClient<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyLeaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyLeaderboardFindFirstArgs} args - Arguments to find a DailyLeaderboard
     * @example
     * // Get one DailyLeaderboard
     * const dailyLeaderboard = await prisma.dailyLeaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyLeaderboardFindFirstArgs>(args?: SelectSubset<T, DailyLeaderboardFindFirstArgs<ExtArgs>>): Prisma__DailyLeaderboardClient<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyLeaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyLeaderboardFindFirstOrThrowArgs} args - Arguments to find a DailyLeaderboard
     * @example
     * // Get one DailyLeaderboard
     * const dailyLeaderboard = await prisma.dailyLeaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyLeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyLeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyLeaderboardClient<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyLeaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyLeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyLeaderboards
     * const dailyLeaderboards = await prisma.dailyLeaderboard.findMany()
     * 
     * // Get first 10 DailyLeaderboards
     * const dailyLeaderboards = await prisma.dailyLeaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyLeaderboardWithIdOnly = await prisma.dailyLeaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyLeaderboardFindManyArgs>(args?: SelectSubset<T, DailyLeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyLeaderboard.
     * @param {DailyLeaderboardCreateArgs} args - Arguments to create a DailyLeaderboard.
     * @example
     * // Create one DailyLeaderboard
     * const DailyLeaderboard = await prisma.dailyLeaderboard.create({
     *   data: {
     *     // ... data to create a DailyLeaderboard
     *   }
     * })
     * 
     */
    create<T extends DailyLeaderboardCreateArgs>(args: SelectSubset<T, DailyLeaderboardCreateArgs<ExtArgs>>): Prisma__DailyLeaderboardClient<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyLeaderboards.
     * @param {DailyLeaderboardCreateManyArgs} args - Arguments to create many DailyLeaderboards.
     * @example
     * // Create many DailyLeaderboards
     * const dailyLeaderboard = await prisma.dailyLeaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyLeaderboardCreateManyArgs>(args?: SelectSubset<T, DailyLeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyLeaderboards and returns the data saved in the database.
     * @param {DailyLeaderboardCreateManyAndReturnArgs} args - Arguments to create many DailyLeaderboards.
     * @example
     * // Create many DailyLeaderboards
     * const dailyLeaderboard = await prisma.dailyLeaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyLeaderboards and only return the `id`
     * const dailyLeaderboardWithIdOnly = await prisma.dailyLeaderboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyLeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyLeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyLeaderboard.
     * @param {DailyLeaderboardDeleteArgs} args - Arguments to delete one DailyLeaderboard.
     * @example
     * // Delete one DailyLeaderboard
     * const DailyLeaderboard = await prisma.dailyLeaderboard.delete({
     *   where: {
     *     // ... filter to delete one DailyLeaderboard
     *   }
     * })
     * 
     */
    delete<T extends DailyLeaderboardDeleteArgs>(args: SelectSubset<T, DailyLeaderboardDeleteArgs<ExtArgs>>): Prisma__DailyLeaderboardClient<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyLeaderboard.
     * @param {DailyLeaderboardUpdateArgs} args - Arguments to update one DailyLeaderboard.
     * @example
     * // Update one DailyLeaderboard
     * const dailyLeaderboard = await prisma.dailyLeaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyLeaderboardUpdateArgs>(args: SelectSubset<T, DailyLeaderboardUpdateArgs<ExtArgs>>): Prisma__DailyLeaderboardClient<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyLeaderboards.
     * @param {DailyLeaderboardDeleteManyArgs} args - Arguments to filter DailyLeaderboards to delete.
     * @example
     * // Delete a few DailyLeaderboards
     * const { count } = await prisma.dailyLeaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyLeaderboardDeleteManyArgs>(args?: SelectSubset<T, DailyLeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyLeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyLeaderboards
     * const dailyLeaderboard = await prisma.dailyLeaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyLeaderboardUpdateManyArgs>(args: SelectSubset<T, DailyLeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyLeaderboards and returns the data updated in the database.
     * @param {DailyLeaderboardUpdateManyAndReturnArgs} args - Arguments to update many DailyLeaderboards.
     * @example
     * // Update many DailyLeaderboards
     * const dailyLeaderboard = await prisma.dailyLeaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyLeaderboards and only return the `id`
     * const dailyLeaderboardWithIdOnly = await prisma.dailyLeaderboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyLeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyLeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyLeaderboard.
     * @param {DailyLeaderboardUpsertArgs} args - Arguments to update or create a DailyLeaderboard.
     * @example
     * // Update or create a DailyLeaderboard
     * const dailyLeaderboard = await prisma.dailyLeaderboard.upsert({
     *   create: {
     *     // ... data to create a DailyLeaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyLeaderboard we want to update
     *   }
     * })
     */
    upsert<T extends DailyLeaderboardUpsertArgs>(args: SelectSubset<T, DailyLeaderboardUpsertArgs<ExtArgs>>): Prisma__DailyLeaderboardClient<$Result.GetResult<Prisma.$DailyLeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyLeaderboardCountArgs} args - Arguments to filter DailyLeaderboards to count.
     * @example
     * // Count the number of DailyLeaderboards
     * const count = await prisma.dailyLeaderboard.count({
     *   where: {
     *     // ... the filter for the DailyLeaderboards we want to count
     *   }
     * })
    **/
    count<T extends DailyLeaderboardCountArgs>(
      args?: Subset<T, DailyLeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyLeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyLeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyLeaderboardAggregateArgs>(args: Subset<T, DailyLeaderboardAggregateArgs>): Prisma.PrismaPromise<GetDailyLeaderboardAggregateType<T>>

    /**
     * Group by DailyLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyLeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyLeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyLeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: DailyLeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyLeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyLeaderboard model
   */
  readonly fields: DailyLeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyLeaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyLeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyLeaderboard model
   */
  interface DailyLeaderboardFieldRefs {
    readonly id: FieldRef<"DailyLeaderboard", 'String'>
    readonly date: FieldRef<"DailyLeaderboard", 'DateTime'>
    readonly userId: FieldRef<"DailyLeaderboard", 'String'>
    readonly bestScore: FieldRef<"DailyLeaderboard", 'Int'>
    readonly rank: FieldRef<"DailyLeaderboard", 'Int'>
    readonly coinPoints: FieldRef<"DailyLeaderboard", 'Int'>
    readonly updatedAt: FieldRef<"DailyLeaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyLeaderboard findUnique
   */
  export type DailyLeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyLeaderboard to fetch.
     */
    where: DailyLeaderboardWhereUniqueInput
  }

  /**
   * DailyLeaderboard findUniqueOrThrow
   */
  export type DailyLeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyLeaderboard to fetch.
     */
    where: DailyLeaderboardWhereUniqueInput
  }

  /**
   * DailyLeaderboard findFirst
   */
  export type DailyLeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyLeaderboard to fetch.
     */
    where?: DailyLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyLeaderboards to fetch.
     */
    orderBy?: DailyLeaderboardOrderByWithRelationInput | DailyLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyLeaderboards.
     */
    cursor?: DailyLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyLeaderboards.
     */
    distinct?: DailyLeaderboardScalarFieldEnum | DailyLeaderboardScalarFieldEnum[]
  }

  /**
   * DailyLeaderboard findFirstOrThrow
   */
  export type DailyLeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyLeaderboard to fetch.
     */
    where?: DailyLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyLeaderboards to fetch.
     */
    orderBy?: DailyLeaderboardOrderByWithRelationInput | DailyLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyLeaderboards.
     */
    cursor?: DailyLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyLeaderboards.
     */
    distinct?: DailyLeaderboardScalarFieldEnum | DailyLeaderboardScalarFieldEnum[]
  }

  /**
   * DailyLeaderboard findMany
   */
  export type DailyLeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyLeaderboards to fetch.
     */
    where?: DailyLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyLeaderboards to fetch.
     */
    orderBy?: DailyLeaderboardOrderByWithRelationInput | DailyLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyLeaderboards.
     */
    cursor?: DailyLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyLeaderboards.
     */
    skip?: number
    distinct?: DailyLeaderboardScalarFieldEnum | DailyLeaderboardScalarFieldEnum[]
  }

  /**
   * DailyLeaderboard create
   */
  export type DailyLeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyLeaderboard.
     */
    data: XOR<DailyLeaderboardCreateInput, DailyLeaderboardUncheckedCreateInput>
  }

  /**
   * DailyLeaderboard createMany
   */
  export type DailyLeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyLeaderboards.
     */
    data: DailyLeaderboardCreateManyInput | DailyLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyLeaderboard createManyAndReturn
   */
  export type DailyLeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many DailyLeaderboards.
     */
    data: DailyLeaderboardCreateManyInput | DailyLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyLeaderboard update
   */
  export type DailyLeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyLeaderboard.
     */
    data: XOR<DailyLeaderboardUpdateInput, DailyLeaderboardUncheckedUpdateInput>
    /**
     * Choose, which DailyLeaderboard to update.
     */
    where: DailyLeaderboardWhereUniqueInput
  }

  /**
   * DailyLeaderboard updateMany
   */
  export type DailyLeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyLeaderboards.
     */
    data: XOR<DailyLeaderboardUpdateManyMutationInput, DailyLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which DailyLeaderboards to update
     */
    where?: DailyLeaderboardWhereInput
    /**
     * Limit how many DailyLeaderboards to update.
     */
    limit?: number
  }

  /**
   * DailyLeaderboard updateManyAndReturn
   */
  export type DailyLeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update DailyLeaderboards.
     */
    data: XOR<DailyLeaderboardUpdateManyMutationInput, DailyLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which DailyLeaderboards to update
     */
    where?: DailyLeaderboardWhereInput
    /**
     * Limit how many DailyLeaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyLeaderboard upsert
   */
  export type DailyLeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyLeaderboard to update in case it exists.
     */
    where: DailyLeaderboardWhereUniqueInput
    /**
     * In case the DailyLeaderboard found by the `where` argument doesn't exist, create a new DailyLeaderboard with this data.
     */
    create: XOR<DailyLeaderboardCreateInput, DailyLeaderboardUncheckedCreateInput>
    /**
     * In case the DailyLeaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyLeaderboardUpdateInput, DailyLeaderboardUncheckedUpdateInput>
  }

  /**
   * DailyLeaderboard delete
   */
  export type DailyLeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
    /**
     * Filter which DailyLeaderboard to delete.
     */
    where: DailyLeaderboardWhereUniqueInput
  }

  /**
   * DailyLeaderboard deleteMany
   */
  export type DailyLeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyLeaderboards to delete
     */
    where?: DailyLeaderboardWhereInput
    /**
     * Limit how many DailyLeaderboards to delete.
     */
    limit?: number
  }

  /**
   * DailyLeaderboard without action
   */
  export type DailyLeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyLeaderboard
     */
    select?: DailyLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyLeaderboard
     */
    omit?: DailyLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyLeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model InstantLeaderboard
   */

  export type AggregateInstantLeaderboard = {
    _count: InstantLeaderboardCountAggregateOutputType | null
    _avg: InstantLeaderboardAvgAggregateOutputType | null
    _sum: InstantLeaderboardSumAggregateOutputType | null
    _min: InstantLeaderboardMinAggregateOutputType | null
    _max: InstantLeaderboardMaxAggregateOutputType | null
  }

  export type InstantLeaderboardAvgAggregateOutputType = {
    bestScore: number | null
    rank: number | null
    coinPoints: Decimal | null
  }

  export type InstantLeaderboardSumAggregateOutputType = {
    bestScore: number | null
    rank: number | null
    coinPoints: Decimal | null
  }

  export type InstantLeaderboardMinAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    userId: string | null
    bestScore: number | null
    rank: number | null
    coinPoints: Decimal | null
    submittedAt: Date | null
    updatedAt: Date | null
    date: Date | null
  }

  export type InstantLeaderboardMaxAggregateOutputType = {
    id: string | null
    tournamentId: string | null
    userId: string | null
    bestScore: number | null
    rank: number | null
    coinPoints: Decimal | null
    submittedAt: Date | null
    updatedAt: Date | null
    date: Date | null
  }

  export type InstantLeaderboardCountAggregateOutputType = {
    id: number
    tournamentId: number
    userId: number
    bestScore: number
    rank: number
    coinPoints: number
    submittedAt: number
    updatedAt: number
    date: number
    _all: number
  }


  export type InstantLeaderboardAvgAggregateInputType = {
    bestScore?: true
    rank?: true
    coinPoints?: true
  }

  export type InstantLeaderboardSumAggregateInputType = {
    bestScore?: true
    rank?: true
    coinPoints?: true
  }

  export type InstantLeaderboardMinAggregateInputType = {
    id?: true
    tournamentId?: true
    userId?: true
    bestScore?: true
    rank?: true
    coinPoints?: true
    submittedAt?: true
    updatedAt?: true
    date?: true
  }

  export type InstantLeaderboardMaxAggregateInputType = {
    id?: true
    tournamentId?: true
    userId?: true
    bestScore?: true
    rank?: true
    coinPoints?: true
    submittedAt?: true
    updatedAt?: true
    date?: true
  }

  export type InstantLeaderboardCountAggregateInputType = {
    id?: true
    tournamentId?: true
    userId?: true
    bestScore?: true
    rank?: true
    coinPoints?: true
    submittedAt?: true
    updatedAt?: true
    date?: true
    _all?: true
  }

  export type InstantLeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstantLeaderboard to aggregate.
     */
    where?: InstantLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantLeaderboards to fetch.
     */
    orderBy?: InstantLeaderboardOrderByWithRelationInput | InstantLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstantLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstantLeaderboards
    **/
    _count?: true | InstantLeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstantLeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstantLeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstantLeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstantLeaderboardMaxAggregateInputType
  }

  export type GetInstantLeaderboardAggregateType<T extends InstantLeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateInstantLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstantLeaderboard[P]>
      : GetScalarType<T[P], AggregateInstantLeaderboard[P]>
  }




  export type InstantLeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstantLeaderboardWhereInput
    orderBy?: InstantLeaderboardOrderByWithAggregationInput | InstantLeaderboardOrderByWithAggregationInput[]
    by: InstantLeaderboardScalarFieldEnum[] | InstantLeaderboardScalarFieldEnum
    having?: InstantLeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstantLeaderboardCountAggregateInputType | true
    _avg?: InstantLeaderboardAvgAggregateInputType
    _sum?: InstantLeaderboardSumAggregateInputType
    _min?: InstantLeaderboardMinAggregateInputType
    _max?: InstantLeaderboardMaxAggregateInputType
  }

  export type InstantLeaderboardGroupByOutputType = {
    id: string
    tournamentId: string
    userId: string
    bestScore: number
    rank: number
    coinPoints: Decimal
    submittedAt: Date
    updatedAt: Date
    date: Date
    _count: InstantLeaderboardCountAggregateOutputType | null
    _avg: InstantLeaderboardAvgAggregateOutputType | null
    _sum: InstantLeaderboardSumAggregateOutputType | null
    _min: InstantLeaderboardMinAggregateOutputType | null
    _max: InstantLeaderboardMaxAggregateOutputType | null
  }

  type GetInstantLeaderboardGroupByPayload<T extends InstantLeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstantLeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstantLeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstantLeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], InstantLeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type InstantLeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    userId?: boolean
    bestScore?: boolean
    rank?: boolean
    coinPoints?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantLeaderboard"]>

  export type InstantLeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    userId?: boolean
    bestScore?: boolean
    rank?: boolean
    coinPoints?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantLeaderboard"]>

  export type InstantLeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tournamentId?: boolean
    userId?: boolean
    bestScore?: boolean
    rank?: boolean
    coinPoints?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instantLeaderboard"]>

  export type InstantLeaderboardSelectScalar = {
    id?: boolean
    tournamentId?: boolean
    userId?: boolean
    bestScore?: boolean
    rank?: boolean
    coinPoints?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    date?: boolean
  }

  export type InstantLeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tournamentId" | "userId" | "bestScore" | "rank" | "coinPoints" | "submittedAt" | "updatedAt" | "date", ExtArgs["result"]["instantLeaderboard"]>
  export type InstantLeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InstantLeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InstantLeaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InstantLeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstantLeaderboard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tournamentId: string
      userId: string
      bestScore: number
      rank: number
      coinPoints: Prisma.Decimal
      submittedAt: Date
      updatedAt: Date
      date: Date
    }, ExtArgs["result"]["instantLeaderboard"]>
    composites: {}
  }

  type InstantLeaderboardGetPayload<S extends boolean | null | undefined | InstantLeaderboardDefaultArgs> = $Result.GetResult<Prisma.$InstantLeaderboardPayload, S>

  type InstantLeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstantLeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstantLeaderboardCountAggregateInputType | true
    }

  export interface InstantLeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstantLeaderboard'], meta: { name: 'InstantLeaderboard' } }
    /**
     * Find zero or one InstantLeaderboard that matches the filter.
     * @param {InstantLeaderboardFindUniqueArgs} args - Arguments to find a InstantLeaderboard
     * @example
     * // Get one InstantLeaderboard
     * const instantLeaderboard = await prisma.instantLeaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstantLeaderboardFindUniqueArgs>(args: SelectSubset<T, InstantLeaderboardFindUniqueArgs<ExtArgs>>): Prisma__InstantLeaderboardClient<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstantLeaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstantLeaderboardFindUniqueOrThrowArgs} args - Arguments to find a InstantLeaderboard
     * @example
     * // Get one InstantLeaderboard
     * const instantLeaderboard = await prisma.instantLeaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstantLeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, InstantLeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstantLeaderboardClient<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstantLeaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantLeaderboardFindFirstArgs} args - Arguments to find a InstantLeaderboard
     * @example
     * // Get one InstantLeaderboard
     * const instantLeaderboard = await prisma.instantLeaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstantLeaderboardFindFirstArgs>(args?: SelectSubset<T, InstantLeaderboardFindFirstArgs<ExtArgs>>): Prisma__InstantLeaderboardClient<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstantLeaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantLeaderboardFindFirstOrThrowArgs} args - Arguments to find a InstantLeaderboard
     * @example
     * // Get one InstantLeaderboard
     * const instantLeaderboard = await prisma.instantLeaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstantLeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, InstantLeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstantLeaderboardClient<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstantLeaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantLeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstantLeaderboards
     * const instantLeaderboards = await prisma.instantLeaderboard.findMany()
     * 
     * // Get first 10 InstantLeaderboards
     * const instantLeaderboards = await prisma.instantLeaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instantLeaderboardWithIdOnly = await prisma.instantLeaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstantLeaderboardFindManyArgs>(args?: SelectSubset<T, InstantLeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstantLeaderboard.
     * @param {InstantLeaderboardCreateArgs} args - Arguments to create a InstantLeaderboard.
     * @example
     * // Create one InstantLeaderboard
     * const InstantLeaderboard = await prisma.instantLeaderboard.create({
     *   data: {
     *     // ... data to create a InstantLeaderboard
     *   }
     * })
     * 
     */
    create<T extends InstantLeaderboardCreateArgs>(args: SelectSubset<T, InstantLeaderboardCreateArgs<ExtArgs>>): Prisma__InstantLeaderboardClient<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstantLeaderboards.
     * @param {InstantLeaderboardCreateManyArgs} args - Arguments to create many InstantLeaderboards.
     * @example
     * // Create many InstantLeaderboards
     * const instantLeaderboard = await prisma.instantLeaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstantLeaderboardCreateManyArgs>(args?: SelectSubset<T, InstantLeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstantLeaderboards and returns the data saved in the database.
     * @param {InstantLeaderboardCreateManyAndReturnArgs} args - Arguments to create many InstantLeaderboards.
     * @example
     * // Create many InstantLeaderboards
     * const instantLeaderboard = await prisma.instantLeaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstantLeaderboards and only return the `id`
     * const instantLeaderboardWithIdOnly = await prisma.instantLeaderboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstantLeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, InstantLeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstantLeaderboard.
     * @param {InstantLeaderboardDeleteArgs} args - Arguments to delete one InstantLeaderboard.
     * @example
     * // Delete one InstantLeaderboard
     * const InstantLeaderboard = await prisma.instantLeaderboard.delete({
     *   where: {
     *     // ... filter to delete one InstantLeaderboard
     *   }
     * })
     * 
     */
    delete<T extends InstantLeaderboardDeleteArgs>(args: SelectSubset<T, InstantLeaderboardDeleteArgs<ExtArgs>>): Prisma__InstantLeaderboardClient<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstantLeaderboard.
     * @param {InstantLeaderboardUpdateArgs} args - Arguments to update one InstantLeaderboard.
     * @example
     * // Update one InstantLeaderboard
     * const instantLeaderboard = await prisma.instantLeaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstantLeaderboardUpdateArgs>(args: SelectSubset<T, InstantLeaderboardUpdateArgs<ExtArgs>>): Prisma__InstantLeaderboardClient<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstantLeaderboards.
     * @param {InstantLeaderboardDeleteManyArgs} args - Arguments to filter InstantLeaderboards to delete.
     * @example
     * // Delete a few InstantLeaderboards
     * const { count } = await prisma.instantLeaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstantLeaderboardDeleteManyArgs>(args?: SelectSubset<T, InstantLeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstantLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantLeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstantLeaderboards
     * const instantLeaderboard = await prisma.instantLeaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstantLeaderboardUpdateManyArgs>(args: SelectSubset<T, InstantLeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstantLeaderboards and returns the data updated in the database.
     * @param {InstantLeaderboardUpdateManyAndReturnArgs} args - Arguments to update many InstantLeaderboards.
     * @example
     * // Update many InstantLeaderboards
     * const instantLeaderboard = await prisma.instantLeaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstantLeaderboards and only return the `id`
     * const instantLeaderboardWithIdOnly = await prisma.instantLeaderboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstantLeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, InstantLeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstantLeaderboard.
     * @param {InstantLeaderboardUpsertArgs} args - Arguments to update or create a InstantLeaderboard.
     * @example
     * // Update or create a InstantLeaderboard
     * const instantLeaderboard = await prisma.instantLeaderboard.upsert({
     *   create: {
     *     // ... data to create a InstantLeaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstantLeaderboard we want to update
     *   }
     * })
     */
    upsert<T extends InstantLeaderboardUpsertArgs>(args: SelectSubset<T, InstantLeaderboardUpsertArgs<ExtArgs>>): Prisma__InstantLeaderboardClient<$Result.GetResult<Prisma.$InstantLeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstantLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantLeaderboardCountArgs} args - Arguments to filter InstantLeaderboards to count.
     * @example
     * // Count the number of InstantLeaderboards
     * const count = await prisma.instantLeaderboard.count({
     *   where: {
     *     // ... the filter for the InstantLeaderboards we want to count
     *   }
     * })
    **/
    count<T extends InstantLeaderboardCountArgs>(
      args?: Subset<T, InstantLeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstantLeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstantLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantLeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstantLeaderboardAggregateArgs>(args: Subset<T, InstantLeaderboardAggregateArgs>): Prisma.PrismaPromise<GetInstantLeaderboardAggregateType<T>>

    /**
     * Group by InstantLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstantLeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstantLeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstantLeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: InstantLeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstantLeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstantLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstantLeaderboard model
   */
  readonly fields: InstantLeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstantLeaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstantLeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstantLeaderboard model
   */
  interface InstantLeaderboardFieldRefs {
    readonly id: FieldRef<"InstantLeaderboard", 'String'>
    readonly tournamentId: FieldRef<"InstantLeaderboard", 'String'>
    readonly userId: FieldRef<"InstantLeaderboard", 'String'>
    readonly bestScore: FieldRef<"InstantLeaderboard", 'Int'>
    readonly rank: FieldRef<"InstantLeaderboard", 'Int'>
    readonly coinPoints: FieldRef<"InstantLeaderboard", 'Decimal'>
    readonly submittedAt: FieldRef<"InstantLeaderboard", 'DateTime'>
    readonly updatedAt: FieldRef<"InstantLeaderboard", 'DateTime'>
    readonly date: FieldRef<"InstantLeaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstantLeaderboard findUnique
   */
  export type InstantLeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which InstantLeaderboard to fetch.
     */
    where: InstantLeaderboardWhereUniqueInput
  }

  /**
   * InstantLeaderboard findUniqueOrThrow
   */
  export type InstantLeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which InstantLeaderboard to fetch.
     */
    where: InstantLeaderboardWhereUniqueInput
  }

  /**
   * InstantLeaderboard findFirst
   */
  export type InstantLeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which InstantLeaderboard to fetch.
     */
    where?: InstantLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantLeaderboards to fetch.
     */
    orderBy?: InstantLeaderboardOrderByWithRelationInput | InstantLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstantLeaderboards.
     */
    cursor?: InstantLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstantLeaderboards.
     */
    distinct?: InstantLeaderboardScalarFieldEnum | InstantLeaderboardScalarFieldEnum[]
  }

  /**
   * InstantLeaderboard findFirstOrThrow
   */
  export type InstantLeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which InstantLeaderboard to fetch.
     */
    where?: InstantLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantLeaderboards to fetch.
     */
    orderBy?: InstantLeaderboardOrderByWithRelationInput | InstantLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstantLeaderboards.
     */
    cursor?: InstantLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstantLeaderboards.
     */
    distinct?: InstantLeaderboardScalarFieldEnum | InstantLeaderboardScalarFieldEnum[]
  }

  /**
   * InstantLeaderboard findMany
   */
  export type InstantLeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which InstantLeaderboards to fetch.
     */
    where?: InstantLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstantLeaderboards to fetch.
     */
    orderBy?: InstantLeaderboardOrderByWithRelationInput | InstantLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstantLeaderboards.
     */
    cursor?: InstantLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstantLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstantLeaderboards.
     */
    skip?: number
    distinct?: InstantLeaderboardScalarFieldEnum | InstantLeaderboardScalarFieldEnum[]
  }

  /**
   * InstantLeaderboard create
   */
  export type InstantLeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a InstantLeaderboard.
     */
    data: XOR<InstantLeaderboardCreateInput, InstantLeaderboardUncheckedCreateInput>
  }

  /**
   * InstantLeaderboard createMany
   */
  export type InstantLeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstantLeaderboards.
     */
    data: InstantLeaderboardCreateManyInput | InstantLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstantLeaderboard createManyAndReturn
   */
  export type InstantLeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many InstantLeaderboards.
     */
    data: InstantLeaderboardCreateManyInput | InstantLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstantLeaderboard update
   */
  export type InstantLeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a InstantLeaderboard.
     */
    data: XOR<InstantLeaderboardUpdateInput, InstantLeaderboardUncheckedUpdateInput>
    /**
     * Choose, which InstantLeaderboard to update.
     */
    where: InstantLeaderboardWhereUniqueInput
  }

  /**
   * InstantLeaderboard updateMany
   */
  export type InstantLeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstantLeaderboards.
     */
    data: XOR<InstantLeaderboardUpdateManyMutationInput, InstantLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which InstantLeaderboards to update
     */
    where?: InstantLeaderboardWhereInput
    /**
     * Limit how many InstantLeaderboards to update.
     */
    limit?: number
  }

  /**
   * InstantLeaderboard updateManyAndReturn
   */
  export type InstantLeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update InstantLeaderboards.
     */
    data: XOR<InstantLeaderboardUpdateManyMutationInput, InstantLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which InstantLeaderboards to update
     */
    where?: InstantLeaderboardWhereInput
    /**
     * Limit how many InstantLeaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstantLeaderboard upsert
   */
  export type InstantLeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the InstantLeaderboard to update in case it exists.
     */
    where: InstantLeaderboardWhereUniqueInput
    /**
     * In case the InstantLeaderboard found by the `where` argument doesn't exist, create a new InstantLeaderboard with this data.
     */
    create: XOR<InstantLeaderboardCreateInput, InstantLeaderboardUncheckedCreateInput>
    /**
     * In case the InstantLeaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstantLeaderboardUpdateInput, InstantLeaderboardUncheckedUpdateInput>
  }

  /**
   * InstantLeaderboard delete
   */
  export type InstantLeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
    /**
     * Filter which InstantLeaderboard to delete.
     */
    where: InstantLeaderboardWhereUniqueInput
  }

  /**
   * InstantLeaderboard deleteMany
   */
  export type InstantLeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstantLeaderboards to delete
     */
    where?: InstantLeaderboardWhereInput
    /**
     * Limit how many InstantLeaderboards to delete.
     */
    limit?: number
  }

  /**
   * InstantLeaderboard without action
   */
  export type InstantLeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstantLeaderboard
     */
    select?: InstantLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstantLeaderboard
     */
    omit?: InstantLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstantLeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model DailyUserLeaderboard
   */

  export type AggregateDailyUserLeaderboard = {
    _count: DailyUserLeaderboardCountAggregateOutputType | null
    _avg: DailyUserLeaderboardAvgAggregateOutputType | null
    _sum: DailyUserLeaderboardSumAggregateOutputType | null
    _min: DailyUserLeaderboardMinAggregateOutputType | null
    _max: DailyUserLeaderboardMaxAggregateOutputType | null
  }

  export type DailyUserLeaderboardAvgAggregateOutputType = {
    dailyCoinPoints: number | null
    instantCoinPoints: Decimal | null
    totalCoinPoints: Decimal | null
    rank: number | null
    coinsAwarded: number | null
  }

  export type DailyUserLeaderboardSumAggregateOutputType = {
    dailyCoinPoints: number | null
    instantCoinPoints: Decimal | null
    totalCoinPoints: Decimal | null
    rank: number | null
    coinsAwarded: number | null
  }

  export type DailyUserLeaderboardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    dailyCoinPoints: number | null
    instantCoinPoints: Decimal | null
    totalCoinPoints: Decimal | null
    rank: number | null
    isEligible: boolean | null
    coinsAwarded: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyUserLeaderboardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    dailyCoinPoints: number | null
    instantCoinPoints: Decimal | null
    totalCoinPoints: Decimal | null
    rank: number | null
    isEligible: boolean | null
    coinsAwarded: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyUserLeaderboardCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    dailyCoinPoints: number
    instantCoinPoints: number
    totalCoinPoints: number
    rank: number
    isEligible: number
    coinsAwarded: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyUserLeaderboardAvgAggregateInputType = {
    dailyCoinPoints?: true
    instantCoinPoints?: true
    totalCoinPoints?: true
    rank?: true
    coinsAwarded?: true
  }

  export type DailyUserLeaderboardSumAggregateInputType = {
    dailyCoinPoints?: true
    instantCoinPoints?: true
    totalCoinPoints?: true
    rank?: true
    coinsAwarded?: true
  }

  export type DailyUserLeaderboardMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    dailyCoinPoints?: true
    instantCoinPoints?: true
    totalCoinPoints?: true
    rank?: true
    isEligible?: true
    coinsAwarded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyUserLeaderboardMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    dailyCoinPoints?: true
    instantCoinPoints?: true
    totalCoinPoints?: true
    rank?: true
    isEligible?: true
    coinsAwarded?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyUserLeaderboardCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    dailyCoinPoints?: true
    instantCoinPoints?: true
    totalCoinPoints?: true
    rank?: true
    isEligible?: true
    coinsAwarded?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyUserLeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyUserLeaderboard to aggregate.
     */
    where?: DailyUserLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyUserLeaderboards to fetch.
     */
    orderBy?: DailyUserLeaderboardOrderByWithRelationInput | DailyUserLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyUserLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyUserLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyUserLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyUserLeaderboards
    **/
    _count?: true | DailyUserLeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyUserLeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyUserLeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyUserLeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyUserLeaderboardMaxAggregateInputType
  }

  export type GetDailyUserLeaderboardAggregateType<T extends DailyUserLeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyUserLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyUserLeaderboard[P]>
      : GetScalarType<T[P], AggregateDailyUserLeaderboard[P]>
  }




  export type DailyUserLeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyUserLeaderboardWhereInput
    orderBy?: DailyUserLeaderboardOrderByWithAggregationInput | DailyUserLeaderboardOrderByWithAggregationInput[]
    by: DailyUserLeaderboardScalarFieldEnum[] | DailyUserLeaderboardScalarFieldEnum
    having?: DailyUserLeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyUserLeaderboardCountAggregateInputType | true
    _avg?: DailyUserLeaderboardAvgAggregateInputType
    _sum?: DailyUserLeaderboardSumAggregateInputType
    _min?: DailyUserLeaderboardMinAggregateInputType
    _max?: DailyUserLeaderboardMaxAggregateInputType
  }

  export type DailyUserLeaderboardGroupByOutputType = {
    id: string
    userId: string
    date: Date
    dailyCoinPoints: number
    instantCoinPoints: Decimal
    totalCoinPoints: Decimal
    rank: number
    isEligible: boolean
    coinsAwarded: number
    createdAt: Date
    updatedAt: Date
    _count: DailyUserLeaderboardCountAggregateOutputType | null
    _avg: DailyUserLeaderboardAvgAggregateOutputType | null
    _sum: DailyUserLeaderboardSumAggregateOutputType | null
    _min: DailyUserLeaderboardMinAggregateOutputType | null
    _max: DailyUserLeaderboardMaxAggregateOutputType | null
  }

  type GetDailyUserLeaderboardGroupByPayload<T extends DailyUserLeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyUserLeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyUserLeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyUserLeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], DailyUserLeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type DailyUserLeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    dailyCoinPoints?: boolean
    instantCoinPoints?: boolean
    totalCoinPoints?: boolean
    rank?: boolean
    isEligible?: boolean
    coinsAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyUserLeaderboard"]>

  export type DailyUserLeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    dailyCoinPoints?: boolean
    instantCoinPoints?: boolean
    totalCoinPoints?: boolean
    rank?: boolean
    isEligible?: boolean
    coinsAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyUserLeaderboard"]>

  export type DailyUserLeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    dailyCoinPoints?: boolean
    instantCoinPoints?: boolean
    totalCoinPoints?: boolean
    rank?: boolean
    isEligible?: boolean
    coinsAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyUserLeaderboard"]>

  export type DailyUserLeaderboardSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    dailyCoinPoints?: boolean
    instantCoinPoints?: boolean
    totalCoinPoints?: boolean
    rank?: boolean
    isEligible?: boolean
    coinsAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyUserLeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "dailyCoinPoints" | "instantCoinPoints" | "totalCoinPoints" | "rank" | "isEligible" | "coinsAwarded" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyUserLeaderboard"]>
  export type DailyUserLeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyUserLeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyUserLeaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyUserLeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyUserLeaderboard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      dailyCoinPoints: number
      instantCoinPoints: Prisma.Decimal
      totalCoinPoints: Prisma.Decimal
      rank: number
      isEligible: boolean
      coinsAwarded: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyUserLeaderboard"]>
    composites: {}
  }

  type DailyUserLeaderboardGetPayload<S extends boolean | null | undefined | DailyUserLeaderboardDefaultArgs> = $Result.GetResult<Prisma.$DailyUserLeaderboardPayload, S>

  type DailyUserLeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyUserLeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyUserLeaderboardCountAggregateInputType | true
    }

  export interface DailyUserLeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyUserLeaderboard'], meta: { name: 'DailyUserLeaderboard' } }
    /**
     * Find zero or one DailyUserLeaderboard that matches the filter.
     * @param {DailyUserLeaderboardFindUniqueArgs} args - Arguments to find a DailyUserLeaderboard
     * @example
     * // Get one DailyUserLeaderboard
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyUserLeaderboardFindUniqueArgs>(args: SelectSubset<T, DailyUserLeaderboardFindUniqueArgs<ExtArgs>>): Prisma__DailyUserLeaderboardClient<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyUserLeaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyUserLeaderboardFindUniqueOrThrowArgs} args - Arguments to find a DailyUserLeaderboard
     * @example
     * // Get one DailyUserLeaderboard
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyUserLeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyUserLeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyUserLeaderboardClient<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyUserLeaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyUserLeaderboardFindFirstArgs} args - Arguments to find a DailyUserLeaderboard
     * @example
     * // Get one DailyUserLeaderboard
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyUserLeaderboardFindFirstArgs>(args?: SelectSubset<T, DailyUserLeaderboardFindFirstArgs<ExtArgs>>): Prisma__DailyUserLeaderboardClient<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyUserLeaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyUserLeaderboardFindFirstOrThrowArgs} args - Arguments to find a DailyUserLeaderboard
     * @example
     * // Get one DailyUserLeaderboard
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyUserLeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyUserLeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyUserLeaderboardClient<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyUserLeaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyUserLeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyUserLeaderboards
     * const dailyUserLeaderboards = await prisma.dailyUserLeaderboard.findMany()
     * 
     * // Get first 10 DailyUserLeaderboards
     * const dailyUserLeaderboards = await prisma.dailyUserLeaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyUserLeaderboardWithIdOnly = await prisma.dailyUserLeaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyUserLeaderboardFindManyArgs>(args?: SelectSubset<T, DailyUserLeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyUserLeaderboard.
     * @param {DailyUserLeaderboardCreateArgs} args - Arguments to create a DailyUserLeaderboard.
     * @example
     * // Create one DailyUserLeaderboard
     * const DailyUserLeaderboard = await prisma.dailyUserLeaderboard.create({
     *   data: {
     *     // ... data to create a DailyUserLeaderboard
     *   }
     * })
     * 
     */
    create<T extends DailyUserLeaderboardCreateArgs>(args: SelectSubset<T, DailyUserLeaderboardCreateArgs<ExtArgs>>): Prisma__DailyUserLeaderboardClient<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyUserLeaderboards.
     * @param {DailyUserLeaderboardCreateManyArgs} args - Arguments to create many DailyUserLeaderboards.
     * @example
     * // Create many DailyUserLeaderboards
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyUserLeaderboardCreateManyArgs>(args?: SelectSubset<T, DailyUserLeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyUserLeaderboards and returns the data saved in the database.
     * @param {DailyUserLeaderboardCreateManyAndReturnArgs} args - Arguments to create many DailyUserLeaderboards.
     * @example
     * // Create many DailyUserLeaderboards
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyUserLeaderboards and only return the `id`
     * const dailyUserLeaderboardWithIdOnly = await prisma.dailyUserLeaderboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyUserLeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyUserLeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyUserLeaderboard.
     * @param {DailyUserLeaderboardDeleteArgs} args - Arguments to delete one DailyUserLeaderboard.
     * @example
     * // Delete one DailyUserLeaderboard
     * const DailyUserLeaderboard = await prisma.dailyUserLeaderboard.delete({
     *   where: {
     *     // ... filter to delete one DailyUserLeaderboard
     *   }
     * })
     * 
     */
    delete<T extends DailyUserLeaderboardDeleteArgs>(args: SelectSubset<T, DailyUserLeaderboardDeleteArgs<ExtArgs>>): Prisma__DailyUserLeaderboardClient<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyUserLeaderboard.
     * @param {DailyUserLeaderboardUpdateArgs} args - Arguments to update one DailyUserLeaderboard.
     * @example
     * // Update one DailyUserLeaderboard
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyUserLeaderboardUpdateArgs>(args: SelectSubset<T, DailyUserLeaderboardUpdateArgs<ExtArgs>>): Prisma__DailyUserLeaderboardClient<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyUserLeaderboards.
     * @param {DailyUserLeaderboardDeleteManyArgs} args - Arguments to filter DailyUserLeaderboards to delete.
     * @example
     * // Delete a few DailyUserLeaderboards
     * const { count } = await prisma.dailyUserLeaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyUserLeaderboardDeleteManyArgs>(args?: SelectSubset<T, DailyUserLeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyUserLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyUserLeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyUserLeaderboards
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyUserLeaderboardUpdateManyArgs>(args: SelectSubset<T, DailyUserLeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyUserLeaderboards and returns the data updated in the database.
     * @param {DailyUserLeaderboardUpdateManyAndReturnArgs} args - Arguments to update many DailyUserLeaderboards.
     * @example
     * // Update many DailyUserLeaderboards
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyUserLeaderboards and only return the `id`
     * const dailyUserLeaderboardWithIdOnly = await prisma.dailyUserLeaderboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyUserLeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyUserLeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyUserLeaderboard.
     * @param {DailyUserLeaderboardUpsertArgs} args - Arguments to update or create a DailyUserLeaderboard.
     * @example
     * // Update or create a DailyUserLeaderboard
     * const dailyUserLeaderboard = await prisma.dailyUserLeaderboard.upsert({
     *   create: {
     *     // ... data to create a DailyUserLeaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyUserLeaderboard we want to update
     *   }
     * })
     */
    upsert<T extends DailyUserLeaderboardUpsertArgs>(args: SelectSubset<T, DailyUserLeaderboardUpsertArgs<ExtArgs>>): Prisma__DailyUserLeaderboardClient<$Result.GetResult<Prisma.$DailyUserLeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyUserLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyUserLeaderboardCountArgs} args - Arguments to filter DailyUserLeaderboards to count.
     * @example
     * // Count the number of DailyUserLeaderboards
     * const count = await prisma.dailyUserLeaderboard.count({
     *   where: {
     *     // ... the filter for the DailyUserLeaderboards we want to count
     *   }
     * })
    **/
    count<T extends DailyUserLeaderboardCountArgs>(
      args?: Subset<T, DailyUserLeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyUserLeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyUserLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyUserLeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyUserLeaderboardAggregateArgs>(args: Subset<T, DailyUserLeaderboardAggregateArgs>): Prisma.PrismaPromise<GetDailyUserLeaderboardAggregateType<T>>

    /**
     * Group by DailyUserLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyUserLeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyUserLeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyUserLeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: DailyUserLeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyUserLeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyUserLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyUserLeaderboard model
   */
  readonly fields: DailyUserLeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyUserLeaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyUserLeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyUserLeaderboard model
   */
  interface DailyUserLeaderboardFieldRefs {
    readonly id: FieldRef<"DailyUserLeaderboard", 'String'>
    readonly userId: FieldRef<"DailyUserLeaderboard", 'String'>
    readonly date: FieldRef<"DailyUserLeaderboard", 'DateTime'>
    readonly dailyCoinPoints: FieldRef<"DailyUserLeaderboard", 'Int'>
    readonly instantCoinPoints: FieldRef<"DailyUserLeaderboard", 'Decimal'>
    readonly totalCoinPoints: FieldRef<"DailyUserLeaderboard", 'Decimal'>
    readonly rank: FieldRef<"DailyUserLeaderboard", 'Int'>
    readonly isEligible: FieldRef<"DailyUserLeaderboard", 'Boolean'>
    readonly coinsAwarded: FieldRef<"DailyUserLeaderboard", 'Float'>
    readonly createdAt: FieldRef<"DailyUserLeaderboard", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyUserLeaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyUserLeaderboard findUnique
   */
  export type DailyUserLeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyUserLeaderboard to fetch.
     */
    where: DailyUserLeaderboardWhereUniqueInput
  }

  /**
   * DailyUserLeaderboard findUniqueOrThrow
   */
  export type DailyUserLeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyUserLeaderboard to fetch.
     */
    where: DailyUserLeaderboardWhereUniqueInput
  }

  /**
   * DailyUserLeaderboard findFirst
   */
  export type DailyUserLeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyUserLeaderboard to fetch.
     */
    where?: DailyUserLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyUserLeaderboards to fetch.
     */
    orderBy?: DailyUserLeaderboardOrderByWithRelationInput | DailyUserLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyUserLeaderboards.
     */
    cursor?: DailyUserLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyUserLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyUserLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyUserLeaderboards.
     */
    distinct?: DailyUserLeaderboardScalarFieldEnum | DailyUserLeaderboardScalarFieldEnum[]
  }

  /**
   * DailyUserLeaderboard findFirstOrThrow
   */
  export type DailyUserLeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyUserLeaderboard to fetch.
     */
    where?: DailyUserLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyUserLeaderboards to fetch.
     */
    orderBy?: DailyUserLeaderboardOrderByWithRelationInput | DailyUserLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyUserLeaderboards.
     */
    cursor?: DailyUserLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyUserLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyUserLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyUserLeaderboards.
     */
    distinct?: DailyUserLeaderboardScalarFieldEnum | DailyUserLeaderboardScalarFieldEnum[]
  }

  /**
   * DailyUserLeaderboard findMany
   */
  export type DailyUserLeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which DailyUserLeaderboards to fetch.
     */
    where?: DailyUserLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyUserLeaderboards to fetch.
     */
    orderBy?: DailyUserLeaderboardOrderByWithRelationInput | DailyUserLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyUserLeaderboards.
     */
    cursor?: DailyUserLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyUserLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyUserLeaderboards.
     */
    skip?: number
    distinct?: DailyUserLeaderboardScalarFieldEnum | DailyUserLeaderboardScalarFieldEnum[]
  }

  /**
   * DailyUserLeaderboard create
   */
  export type DailyUserLeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyUserLeaderboard.
     */
    data: XOR<DailyUserLeaderboardCreateInput, DailyUserLeaderboardUncheckedCreateInput>
  }

  /**
   * DailyUserLeaderboard createMany
   */
  export type DailyUserLeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyUserLeaderboards.
     */
    data: DailyUserLeaderboardCreateManyInput | DailyUserLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyUserLeaderboard createManyAndReturn
   */
  export type DailyUserLeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many DailyUserLeaderboards.
     */
    data: DailyUserLeaderboardCreateManyInput | DailyUserLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyUserLeaderboard update
   */
  export type DailyUserLeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyUserLeaderboard.
     */
    data: XOR<DailyUserLeaderboardUpdateInput, DailyUserLeaderboardUncheckedUpdateInput>
    /**
     * Choose, which DailyUserLeaderboard to update.
     */
    where: DailyUserLeaderboardWhereUniqueInput
  }

  /**
   * DailyUserLeaderboard updateMany
   */
  export type DailyUserLeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyUserLeaderboards.
     */
    data: XOR<DailyUserLeaderboardUpdateManyMutationInput, DailyUserLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which DailyUserLeaderboards to update
     */
    where?: DailyUserLeaderboardWhereInput
    /**
     * Limit how many DailyUserLeaderboards to update.
     */
    limit?: number
  }

  /**
   * DailyUserLeaderboard updateManyAndReturn
   */
  export type DailyUserLeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update DailyUserLeaderboards.
     */
    data: XOR<DailyUserLeaderboardUpdateManyMutationInput, DailyUserLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which DailyUserLeaderboards to update
     */
    where?: DailyUserLeaderboardWhereInput
    /**
     * Limit how many DailyUserLeaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyUserLeaderboard upsert
   */
  export type DailyUserLeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyUserLeaderboard to update in case it exists.
     */
    where: DailyUserLeaderboardWhereUniqueInput
    /**
     * In case the DailyUserLeaderboard found by the `where` argument doesn't exist, create a new DailyUserLeaderboard with this data.
     */
    create: XOR<DailyUserLeaderboardCreateInput, DailyUserLeaderboardUncheckedCreateInput>
    /**
     * In case the DailyUserLeaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyUserLeaderboardUpdateInput, DailyUserLeaderboardUncheckedUpdateInput>
  }

  /**
   * DailyUserLeaderboard delete
   */
  export type DailyUserLeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
    /**
     * Filter which DailyUserLeaderboard to delete.
     */
    where: DailyUserLeaderboardWhereUniqueInput
  }

  /**
   * DailyUserLeaderboard deleteMany
   */
  export type DailyUserLeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyUserLeaderboards to delete
     */
    where?: DailyUserLeaderboardWhereInput
    /**
     * Limit how many DailyUserLeaderboards to delete.
     */
    limit?: number
  }

  /**
   * DailyUserLeaderboard without action
   */
  export type DailyUserLeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyUserLeaderboard
     */
    select?: DailyUserLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyUserLeaderboard
     */
    omit?: DailyUserLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyUserLeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model SoloLeaderboard
   */

  export type AggregateSoloLeaderboard = {
    _count: SoloLeaderboardCountAggregateOutputType | null
    _avg: SoloLeaderboardAvgAggregateOutputType | null
    _sum: SoloLeaderboardSumAggregateOutputType | null
    _min: SoloLeaderboardMinAggregateOutputType | null
    _max: SoloLeaderboardMaxAggregateOutputType | null
  }

  export type SoloLeaderboardAvgAggregateOutputType = {
    score: number | null
    rank: number | null
    percentile: number | null
    coinPoints: number | null
  }

  export type SoloLeaderboardSumAggregateOutputType = {
    score: number | null
    rank: number | null
    percentile: number | null
    coinPoints: number | null
  }

  export type SoloLeaderboardMinAggregateOutputType = {
    id: string | null
    date: Date | null
    userId: string | null
    score: number | null
    rank: number | null
    percentile: number | null
    coinPoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SoloLeaderboardMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    userId: string | null
    score: number | null
    rank: number | null
    percentile: number | null
    coinPoints: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SoloLeaderboardCountAggregateOutputType = {
    id: number
    date: number
    userId: number
    score: number
    rank: number
    percentile: number
    coinPoints: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SoloLeaderboardAvgAggregateInputType = {
    score?: true
    rank?: true
    percentile?: true
    coinPoints?: true
  }

  export type SoloLeaderboardSumAggregateInputType = {
    score?: true
    rank?: true
    percentile?: true
    coinPoints?: true
  }

  export type SoloLeaderboardMinAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    score?: true
    rank?: true
    percentile?: true
    coinPoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SoloLeaderboardMaxAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    score?: true
    rank?: true
    percentile?: true
    coinPoints?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SoloLeaderboardCountAggregateInputType = {
    id?: true
    date?: true
    userId?: true
    score?: true
    rank?: true
    percentile?: true
    coinPoints?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SoloLeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoloLeaderboard to aggregate.
     */
    where?: SoloLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoloLeaderboards to fetch.
     */
    orderBy?: SoloLeaderboardOrderByWithRelationInput | SoloLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SoloLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoloLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoloLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SoloLeaderboards
    **/
    _count?: true | SoloLeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoloLeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoloLeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoloLeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoloLeaderboardMaxAggregateInputType
  }

  export type GetSoloLeaderboardAggregateType<T extends SoloLeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateSoloLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoloLeaderboard[P]>
      : GetScalarType<T[P], AggregateSoloLeaderboard[P]>
  }




  export type SoloLeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SoloLeaderboardWhereInput
    orderBy?: SoloLeaderboardOrderByWithAggregationInput | SoloLeaderboardOrderByWithAggregationInput[]
    by: SoloLeaderboardScalarFieldEnum[] | SoloLeaderboardScalarFieldEnum
    having?: SoloLeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoloLeaderboardCountAggregateInputType | true
    _avg?: SoloLeaderboardAvgAggregateInputType
    _sum?: SoloLeaderboardSumAggregateInputType
    _min?: SoloLeaderboardMinAggregateInputType
    _max?: SoloLeaderboardMaxAggregateInputType
  }

  export type SoloLeaderboardGroupByOutputType = {
    id: string
    date: Date
    userId: string
    score: number
    rank: number
    percentile: number
    coinPoints: number
    createdAt: Date
    updatedAt: Date
    _count: SoloLeaderboardCountAggregateOutputType | null
    _avg: SoloLeaderboardAvgAggregateOutputType | null
    _sum: SoloLeaderboardSumAggregateOutputType | null
    _min: SoloLeaderboardMinAggregateOutputType | null
    _max: SoloLeaderboardMaxAggregateOutputType | null
  }

  type GetSoloLeaderboardGroupByPayload<T extends SoloLeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoloLeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoloLeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoloLeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], SoloLeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type SoloLeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    score?: boolean
    rank?: boolean
    percentile?: boolean
    coinPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["soloLeaderboard"]>

  export type SoloLeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    score?: boolean
    rank?: boolean
    percentile?: boolean
    coinPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["soloLeaderboard"]>

  export type SoloLeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    userId?: boolean
    score?: boolean
    rank?: boolean
    percentile?: boolean
    coinPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["soloLeaderboard"]>

  export type SoloLeaderboardSelectScalar = {
    id?: boolean
    date?: boolean
    userId?: boolean
    score?: boolean
    rank?: boolean
    percentile?: boolean
    coinPoints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SoloLeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "userId" | "score" | "rank" | "percentile" | "coinPoints" | "createdAt" | "updatedAt", ExtArgs["result"]["soloLeaderboard"]>

  export type $SoloLeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SoloLeaderboard"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      userId: string
      score: number
      rank: number
      percentile: number
      coinPoints: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["soloLeaderboard"]>
    composites: {}
  }

  type SoloLeaderboardGetPayload<S extends boolean | null | undefined | SoloLeaderboardDefaultArgs> = $Result.GetResult<Prisma.$SoloLeaderboardPayload, S>

  type SoloLeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SoloLeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SoloLeaderboardCountAggregateInputType | true
    }

  export interface SoloLeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SoloLeaderboard'], meta: { name: 'SoloLeaderboard' } }
    /**
     * Find zero or one SoloLeaderboard that matches the filter.
     * @param {SoloLeaderboardFindUniqueArgs} args - Arguments to find a SoloLeaderboard
     * @example
     * // Get one SoloLeaderboard
     * const soloLeaderboard = await prisma.soloLeaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SoloLeaderboardFindUniqueArgs>(args: SelectSubset<T, SoloLeaderboardFindUniqueArgs<ExtArgs>>): Prisma__SoloLeaderboardClient<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SoloLeaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SoloLeaderboardFindUniqueOrThrowArgs} args - Arguments to find a SoloLeaderboard
     * @example
     * // Get one SoloLeaderboard
     * const soloLeaderboard = await prisma.soloLeaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SoloLeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, SoloLeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SoloLeaderboardClient<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SoloLeaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloLeaderboardFindFirstArgs} args - Arguments to find a SoloLeaderboard
     * @example
     * // Get one SoloLeaderboard
     * const soloLeaderboard = await prisma.soloLeaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SoloLeaderboardFindFirstArgs>(args?: SelectSubset<T, SoloLeaderboardFindFirstArgs<ExtArgs>>): Prisma__SoloLeaderboardClient<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SoloLeaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloLeaderboardFindFirstOrThrowArgs} args - Arguments to find a SoloLeaderboard
     * @example
     * // Get one SoloLeaderboard
     * const soloLeaderboard = await prisma.soloLeaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SoloLeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, SoloLeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__SoloLeaderboardClient<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SoloLeaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloLeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SoloLeaderboards
     * const soloLeaderboards = await prisma.soloLeaderboard.findMany()
     * 
     * // Get first 10 SoloLeaderboards
     * const soloLeaderboards = await prisma.soloLeaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const soloLeaderboardWithIdOnly = await prisma.soloLeaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SoloLeaderboardFindManyArgs>(args?: SelectSubset<T, SoloLeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SoloLeaderboard.
     * @param {SoloLeaderboardCreateArgs} args - Arguments to create a SoloLeaderboard.
     * @example
     * // Create one SoloLeaderboard
     * const SoloLeaderboard = await prisma.soloLeaderboard.create({
     *   data: {
     *     // ... data to create a SoloLeaderboard
     *   }
     * })
     * 
     */
    create<T extends SoloLeaderboardCreateArgs>(args: SelectSubset<T, SoloLeaderboardCreateArgs<ExtArgs>>): Prisma__SoloLeaderboardClient<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SoloLeaderboards.
     * @param {SoloLeaderboardCreateManyArgs} args - Arguments to create many SoloLeaderboards.
     * @example
     * // Create many SoloLeaderboards
     * const soloLeaderboard = await prisma.soloLeaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SoloLeaderboardCreateManyArgs>(args?: SelectSubset<T, SoloLeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SoloLeaderboards and returns the data saved in the database.
     * @param {SoloLeaderboardCreateManyAndReturnArgs} args - Arguments to create many SoloLeaderboards.
     * @example
     * // Create many SoloLeaderboards
     * const soloLeaderboard = await prisma.soloLeaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SoloLeaderboards and only return the `id`
     * const soloLeaderboardWithIdOnly = await prisma.soloLeaderboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SoloLeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, SoloLeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SoloLeaderboard.
     * @param {SoloLeaderboardDeleteArgs} args - Arguments to delete one SoloLeaderboard.
     * @example
     * // Delete one SoloLeaderboard
     * const SoloLeaderboard = await prisma.soloLeaderboard.delete({
     *   where: {
     *     // ... filter to delete one SoloLeaderboard
     *   }
     * })
     * 
     */
    delete<T extends SoloLeaderboardDeleteArgs>(args: SelectSubset<T, SoloLeaderboardDeleteArgs<ExtArgs>>): Prisma__SoloLeaderboardClient<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SoloLeaderboard.
     * @param {SoloLeaderboardUpdateArgs} args - Arguments to update one SoloLeaderboard.
     * @example
     * // Update one SoloLeaderboard
     * const soloLeaderboard = await prisma.soloLeaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SoloLeaderboardUpdateArgs>(args: SelectSubset<T, SoloLeaderboardUpdateArgs<ExtArgs>>): Prisma__SoloLeaderboardClient<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SoloLeaderboards.
     * @param {SoloLeaderboardDeleteManyArgs} args - Arguments to filter SoloLeaderboards to delete.
     * @example
     * // Delete a few SoloLeaderboards
     * const { count } = await prisma.soloLeaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SoloLeaderboardDeleteManyArgs>(args?: SelectSubset<T, SoloLeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoloLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloLeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SoloLeaderboards
     * const soloLeaderboard = await prisma.soloLeaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SoloLeaderboardUpdateManyArgs>(args: SelectSubset<T, SoloLeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SoloLeaderboards and returns the data updated in the database.
     * @param {SoloLeaderboardUpdateManyAndReturnArgs} args - Arguments to update many SoloLeaderboards.
     * @example
     * // Update many SoloLeaderboards
     * const soloLeaderboard = await prisma.soloLeaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SoloLeaderboards and only return the `id`
     * const soloLeaderboardWithIdOnly = await prisma.soloLeaderboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SoloLeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, SoloLeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SoloLeaderboard.
     * @param {SoloLeaderboardUpsertArgs} args - Arguments to update or create a SoloLeaderboard.
     * @example
     * // Update or create a SoloLeaderboard
     * const soloLeaderboard = await prisma.soloLeaderboard.upsert({
     *   create: {
     *     // ... data to create a SoloLeaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SoloLeaderboard we want to update
     *   }
     * })
     */
    upsert<T extends SoloLeaderboardUpsertArgs>(args: SelectSubset<T, SoloLeaderboardUpsertArgs<ExtArgs>>): Prisma__SoloLeaderboardClient<$Result.GetResult<Prisma.$SoloLeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SoloLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloLeaderboardCountArgs} args - Arguments to filter SoloLeaderboards to count.
     * @example
     * // Count the number of SoloLeaderboards
     * const count = await prisma.soloLeaderboard.count({
     *   where: {
     *     // ... the filter for the SoloLeaderboards we want to count
     *   }
     * })
    **/
    count<T extends SoloLeaderboardCountArgs>(
      args?: Subset<T, SoloLeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoloLeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SoloLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloLeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoloLeaderboardAggregateArgs>(args: Subset<T, SoloLeaderboardAggregateArgs>): Prisma.PrismaPromise<GetSoloLeaderboardAggregateType<T>>

    /**
     * Group by SoloLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoloLeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SoloLeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SoloLeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: SoloLeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SoloLeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoloLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SoloLeaderboard model
   */
  readonly fields: SoloLeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SoloLeaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SoloLeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SoloLeaderboard model
   */
  interface SoloLeaderboardFieldRefs {
    readonly id: FieldRef<"SoloLeaderboard", 'String'>
    readonly date: FieldRef<"SoloLeaderboard", 'DateTime'>
    readonly userId: FieldRef<"SoloLeaderboard", 'String'>
    readonly score: FieldRef<"SoloLeaderboard", 'Float'>
    readonly rank: FieldRef<"SoloLeaderboard", 'Int'>
    readonly percentile: FieldRef<"SoloLeaderboard", 'Float'>
    readonly coinPoints: FieldRef<"SoloLeaderboard", 'Float'>
    readonly createdAt: FieldRef<"SoloLeaderboard", 'DateTime'>
    readonly updatedAt: FieldRef<"SoloLeaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SoloLeaderboard findUnique
   */
  export type SoloLeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * Filter, which SoloLeaderboard to fetch.
     */
    where: SoloLeaderboardWhereUniqueInput
  }

  /**
   * SoloLeaderboard findUniqueOrThrow
   */
  export type SoloLeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * Filter, which SoloLeaderboard to fetch.
     */
    where: SoloLeaderboardWhereUniqueInput
  }

  /**
   * SoloLeaderboard findFirst
   */
  export type SoloLeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * Filter, which SoloLeaderboard to fetch.
     */
    where?: SoloLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoloLeaderboards to fetch.
     */
    orderBy?: SoloLeaderboardOrderByWithRelationInput | SoloLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoloLeaderboards.
     */
    cursor?: SoloLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoloLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoloLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoloLeaderboards.
     */
    distinct?: SoloLeaderboardScalarFieldEnum | SoloLeaderboardScalarFieldEnum[]
  }

  /**
   * SoloLeaderboard findFirstOrThrow
   */
  export type SoloLeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * Filter, which SoloLeaderboard to fetch.
     */
    where?: SoloLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoloLeaderboards to fetch.
     */
    orderBy?: SoloLeaderboardOrderByWithRelationInput | SoloLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SoloLeaderboards.
     */
    cursor?: SoloLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoloLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoloLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SoloLeaderboards.
     */
    distinct?: SoloLeaderboardScalarFieldEnum | SoloLeaderboardScalarFieldEnum[]
  }

  /**
   * SoloLeaderboard findMany
   */
  export type SoloLeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * Filter, which SoloLeaderboards to fetch.
     */
    where?: SoloLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SoloLeaderboards to fetch.
     */
    orderBy?: SoloLeaderboardOrderByWithRelationInput | SoloLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SoloLeaderboards.
     */
    cursor?: SoloLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SoloLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SoloLeaderboards.
     */
    skip?: number
    distinct?: SoloLeaderboardScalarFieldEnum | SoloLeaderboardScalarFieldEnum[]
  }

  /**
   * SoloLeaderboard create
   */
  export type SoloLeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * The data needed to create a SoloLeaderboard.
     */
    data: XOR<SoloLeaderboardCreateInput, SoloLeaderboardUncheckedCreateInput>
  }

  /**
   * SoloLeaderboard createMany
   */
  export type SoloLeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SoloLeaderboards.
     */
    data: SoloLeaderboardCreateManyInput | SoloLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SoloLeaderboard createManyAndReturn
   */
  export type SoloLeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many SoloLeaderboards.
     */
    data: SoloLeaderboardCreateManyInput | SoloLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SoloLeaderboard update
   */
  export type SoloLeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * The data needed to update a SoloLeaderboard.
     */
    data: XOR<SoloLeaderboardUpdateInput, SoloLeaderboardUncheckedUpdateInput>
    /**
     * Choose, which SoloLeaderboard to update.
     */
    where: SoloLeaderboardWhereUniqueInput
  }

  /**
   * SoloLeaderboard updateMany
   */
  export type SoloLeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SoloLeaderboards.
     */
    data: XOR<SoloLeaderboardUpdateManyMutationInput, SoloLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which SoloLeaderboards to update
     */
    where?: SoloLeaderboardWhereInput
    /**
     * Limit how many SoloLeaderboards to update.
     */
    limit?: number
  }

  /**
   * SoloLeaderboard updateManyAndReturn
   */
  export type SoloLeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update SoloLeaderboards.
     */
    data: XOR<SoloLeaderboardUpdateManyMutationInput, SoloLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which SoloLeaderboards to update
     */
    where?: SoloLeaderboardWhereInput
    /**
     * Limit how many SoloLeaderboards to update.
     */
    limit?: number
  }

  /**
   * SoloLeaderboard upsert
   */
  export type SoloLeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * The filter to search for the SoloLeaderboard to update in case it exists.
     */
    where: SoloLeaderboardWhereUniqueInput
    /**
     * In case the SoloLeaderboard found by the `where` argument doesn't exist, create a new SoloLeaderboard with this data.
     */
    create: XOR<SoloLeaderboardCreateInput, SoloLeaderboardUncheckedCreateInput>
    /**
     * In case the SoloLeaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SoloLeaderboardUpdateInput, SoloLeaderboardUncheckedUpdateInput>
  }

  /**
   * SoloLeaderboard delete
   */
  export type SoloLeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
    /**
     * Filter which SoloLeaderboard to delete.
     */
    where: SoloLeaderboardWhereUniqueInput
  }

  /**
   * SoloLeaderboard deleteMany
   */
  export type SoloLeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SoloLeaderboards to delete
     */
    where?: SoloLeaderboardWhereInput
    /**
     * Limit how many SoloLeaderboards to delete.
     */
    limit?: number
  }

  /**
   * SoloLeaderboard without action
   */
  export type SoloLeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SoloLeaderboard
     */
    select?: SoloLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SoloLeaderboard
     */
    omit?: SoloLeaderboardOmit<ExtArgs> | null
  }


  /**
   * Model RewardClaim
   */

  export type AggregateRewardClaim = {
    _count: RewardClaimCountAggregateOutputType | null
    _avg: RewardClaimAvgAggregateOutputType | null
    _sum: RewardClaimSumAggregateOutputType | null
    _min: RewardClaimMinAggregateOutputType | null
    _max: RewardClaimMaxAggregateOutputType | null
  }

  export type RewardClaimAvgAggregateOutputType = {
    coinsLocked: number | null
  }

  export type RewardClaimSumAggregateOutputType = {
    coinsLocked: number | null
  }

  export type RewardClaimMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coinsLocked: number | null
    status: $Enums.ClaimStatus | null
    voucherCode: string | null
    adminNotes: string | null
    fulfilledBy: string | null
    fulfilledAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardClaimMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coinsLocked: number | null
    status: $Enums.ClaimStatus | null
    voucherCode: string | null
    adminNotes: string | null
    fulfilledBy: string | null
    fulfilledAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RewardClaimCountAggregateOutputType = {
    id: number
    userId: number
    coinsLocked: number
    status: number
    voucherCode: number
    adminNotes: number
    fulfilledBy: number
    fulfilledAt: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RewardClaimAvgAggregateInputType = {
    coinsLocked?: true
  }

  export type RewardClaimSumAggregateInputType = {
    coinsLocked?: true
  }

  export type RewardClaimMinAggregateInputType = {
    id?: true
    userId?: true
    coinsLocked?: true
    status?: true
    voucherCode?: true
    adminNotes?: true
    fulfilledBy?: true
    fulfilledAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardClaimMaxAggregateInputType = {
    id?: true
    userId?: true
    coinsLocked?: true
    status?: true
    voucherCode?: true
    adminNotes?: true
    fulfilledBy?: true
    fulfilledAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RewardClaimCountAggregateInputType = {
    id?: true
    userId?: true
    coinsLocked?: true
    status?: true
    voucherCode?: true
    adminNotes?: true
    fulfilledBy?: true
    fulfilledAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardClaim to aggregate.
     */
    where?: RewardClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardClaims to fetch.
     */
    orderBy?: RewardClaimOrderByWithRelationInput | RewardClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardClaims
    **/
    _count?: true | RewardClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardClaimMaxAggregateInputType
  }

  export type GetRewardClaimAggregateType<T extends RewardClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardClaim[P]>
      : GetScalarType<T[P], AggregateRewardClaim[P]>
  }




  export type RewardClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardClaimWhereInput
    orderBy?: RewardClaimOrderByWithAggregationInput | RewardClaimOrderByWithAggregationInput[]
    by: RewardClaimScalarFieldEnum[] | RewardClaimScalarFieldEnum
    having?: RewardClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardClaimCountAggregateInputType | true
    _avg?: RewardClaimAvgAggregateInputType
    _sum?: RewardClaimSumAggregateInputType
    _min?: RewardClaimMinAggregateInputType
    _max?: RewardClaimMaxAggregateInputType
  }

  export type RewardClaimGroupByOutputType = {
    id: string
    userId: string
    coinsLocked: number
    status: $Enums.ClaimStatus
    voucherCode: string | null
    adminNotes: string | null
    fulfilledBy: string | null
    fulfilledAt: Date | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: RewardClaimCountAggregateOutputType | null
    _avg: RewardClaimAvgAggregateOutputType | null
    _sum: RewardClaimSumAggregateOutputType | null
    _min: RewardClaimMinAggregateOutputType | null
    _max: RewardClaimMaxAggregateOutputType | null
  }

  type GetRewardClaimGroupByPayload<T extends RewardClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardClaimGroupByOutputType[P]>
            : GetScalarType<T[P], RewardClaimGroupByOutputType[P]>
        }
      >
    >


  export type RewardClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinsLocked?: boolean
    status?: boolean
    voucherCode?: boolean
    adminNotes?: boolean
    fulfilledBy?: boolean
    fulfilledAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardClaim"]>

  export type RewardClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinsLocked?: boolean
    status?: boolean
    voucherCode?: boolean
    adminNotes?: boolean
    fulfilledBy?: boolean
    fulfilledAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardClaim"]>

  export type RewardClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinsLocked?: boolean
    status?: boolean
    voucherCode?: boolean
    adminNotes?: boolean
    fulfilledBy?: boolean
    fulfilledAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardClaim"]>

  export type RewardClaimSelectScalar = {
    id?: boolean
    userId?: boolean
    coinsLocked?: boolean
    status?: boolean
    voucherCode?: boolean
    adminNotes?: boolean
    fulfilledBy?: boolean
    fulfilledAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RewardClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "coinsLocked" | "status" | "voucherCode" | "adminNotes" | "fulfilledBy" | "fulfilledAt" | "rejectionReason" | "createdAt" | "updatedAt", ExtArgs["result"]["rewardClaim"]>
  export type RewardClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RewardClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RewardClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RewardClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardClaim"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coinsLocked: number
      status: $Enums.ClaimStatus
      voucherCode: string | null
      adminNotes: string | null
      fulfilledBy: string | null
      fulfilledAt: Date | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rewardClaim"]>
    composites: {}
  }

  type RewardClaimGetPayload<S extends boolean | null | undefined | RewardClaimDefaultArgs> = $Result.GetResult<Prisma.$RewardClaimPayload, S>

  type RewardClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardClaimCountAggregateInputType | true
    }

  export interface RewardClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardClaim'], meta: { name: 'RewardClaim' } }
    /**
     * Find zero or one RewardClaim that matches the filter.
     * @param {RewardClaimFindUniqueArgs} args - Arguments to find a RewardClaim
     * @example
     * // Get one RewardClaim
     * const rewardClaim = await prisma.rewardClaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardClaimFindUniqueArgs>(args: SelectSubset<T, RewardClaimFindUniqueArgs<ExtArgs>>): Prisma__RewardClaimClient<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RewardClaim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardClaimFindUniqueOrThrowArgs} args - Arguments to find a RewardClaim
     * @example
     * // Get one RewardClaim
     * const rewardClaim = await prisma.rewardClaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardClaimClient<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardClaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimFindFirstArgs} args - Arguments to find a RewardClaim
     * @example
     * // Get one RewardClaim
     * const rewardClaim = await prisma.rewardClaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardClaimFindFirstArgs>(args?: SelectSubset<T, RewardClaimFindFirstArgs<ExtArgs>>): Prisma__RewardClaimClient<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardClaim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimFindFirstOrThrowArgs} args - Arguments to find a RewardClaim
     * @example
     * // Get one RewardClaim
     * const rewardClaim = await prisma.rewardClaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardClaimClient<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RewardClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardClaims
     * const rewardClaims = await prisma.rewardClaim.findMany()
     * 
     * // Get first 10 RewardClaims
     * const rewardClaims = await prisma.rewardClaim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardClaimWithIdOnly = await prisma.rewardClaim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardClaimFindManyArgs>(args?: SelectSubset<T, RewardClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RewardClaim.
     * @param {RewardClaimCreateArgs} args - Arguments to create a RewardClaim.
     * @example
     * // Create one RewardClaim
     * const RewardClaim = await prisma.rewardClaim.create({
     *   data: {
     *     // ... data to create a RewardClaim
     *   }
     * })
     * 
     */
    create<T extends RewardClaimCreateArgs>(args: SelectSubset<T, RewardClaimCreateArgs<ExtArgs>>): Prisma__RewardClaimClient<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RewardClaims.
     * @param {RewardClaimCreateManyArgs} args - Arguments to create many RewardClaims.
     * @example
     * // Create many RewardClaims
     * const rewardClaim = await prisma.rewardClaim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardClaimCreateManyArgs>(args?: SelectSubset<T, RewardClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardClaims and returns the data saved in the database.
     * @param {RewardClaimCreateManyAndReturnArgs} args - Arguments to create many RewardClaims.
     * @example
     * // Create many RewardClaims
     * const rewardClaim = await prisma.rewardClaim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardClaims and only return the `id`
     * const rewardClaimWithIdOnly = await prisma.rewardClaim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RewardClaim.
     * @param {RewardClaimDeleteArgs} args - Arguments to delete one RewardClaim.
     * @example
     * // Delete one RewardClaim
     * const RewardClaim = await prisma.rewardClaim.delete({
     *   where: {
     *     // ... filter to delete one RewardClaim
     *   }
     * })
     * 
     */
    delete<T extends RewardClaimDeleteArgs>(args: SelectSubset<T, RewardClaimDeleteArgs<ExtArgs>>): Prisma__RewardClaimClient<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RewardClaim.
     * @param {RewardClaimUpdateArgs} args - Arguments to update one RewardClaim.
     * @example
     * // Update one RewardClaim
     * const rewardClaim = await prisma.rewardClaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardClaimUpdateArgs>(args: SelectSubset<T, RewardClaimUpdateArgs<ExtArgs>>): Prisma__RewardClaimClient<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RewardClaims.
     * @param {RewardClaimDeleteManyArgs} args - Arguments to filter RewardClaims to delete.
     * @example
     * // Delete a few RewardClaims
     * const { count } = await prisma.rewardClaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardClaimDeleteManyArgs>(args?: SelectSubset<T, RewardClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardClaims
     * const rewardClaim = await prisma.rewardClaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardClaimUpdateManyArgs>(args: SelectSubset<T, RewardClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardClaims and returns the data updated in the database.
     * @param {RewardClaimUpdateManyAndReturnArgs} args - Arguments to update many RewardClaims.
     * @example
     * // Update many RewardClaims
     * const rewardClaim = await prisma.rewardClaim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardClaims and only return the `id`
     * const rewardClaimWithIdOnly = await prisma.rewardClaim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RewardClaim.
     * @param {RewardClaimUpsertArgs} args - Arguments to update or create a RewardClaim.
     * @example
     * // Update or create a RewardClaim
     * const rewardClaim = await prisma.rewardClaim.upsert({
     *   create: {
     *     // ... data to create a RewardClaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardClaim we want to update
     *   }
     * })
     */
    upsert<T extends RewardClaimUpsertArgs>(args: SelectSubset<T, RewardClaimUpsertArgs<ExtArgs>>): Prisma__RewardClaimClient<$Result.GetResult<Prisma.$RewardClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RewardClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimCountArgs} args - Arguments to filter RewardClaims to count.
     * @example
     * // Count the number of RewardClaims
     * const count = await prisma.rewardClaim.count({
     *   where: {
     *     // ... the filter for the RewardClaims we want to count
     *   }
     * })
    **/
    count<T extends RewardClaimCountArgs>(
      args?: Subset<T, RewardClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardClaimAggregateArgs>(args: Subset<T, RewardClaimAggregateArgs>): Prisma.PrismaPromise<GetRewardClaimAggregateType<T>>

    /**
     * Group by RewardClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardClaimGroupByArgs['orderBy'] }
        : { orderBy?: RewardClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardClaim model
   */
  readonly fields: RewardClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardClaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardClaim model
   */
  interface RewardClaimFieldRefs {
    readonly id: FieldRef<"RewardClaim", 'String'>
    readonly userId: FieldRef<"RewardClaim", 'String'>
    readonly coinsLocked: FieldRef<"RewardClaim", 'Int'>
    readonly status: FieldRef<"RewardClaim", 'ClaimStatus'>
    readonly voucherCode: FieldRef<"RewardClaim", 'String'>
    readonly adminNotes: FieldRef<"RewardClaim", 'String'>
    readonly fulfilledBy: FieldRef<"RewardClaim", 'String'>
    readonly fulfilledAt: FieldRef<"RewardClaim", 'DateTime'>
    readonly rejectionReason: FieldRef<"RewardClaim", 'String'>
    readonly createdAt: FieldRef<"RewardClaim", 'DateTime'>
    readonly updatedAt: FieldRef<"RewardClaim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RewardClaim findUnique
   */
  export type RewardClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaim to fetch.
     */
    where: RewardClaimWhereUniqueInput
  }

  /**
   * RewardClaim findUniqueOrThrow
   */
  export type RewardClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaim to fetch.
     */
    where: RewardClaimWhereUniqueInput
  }

  /**
   * RewardClaim findFirst
   */
  export type RewardClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaim to fetch.
     */
    where?: RewardClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardClaims to fetch.
     */
    orderBy?: RewardClaimOrderByWithRelationInput | RewardClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardClaims.
     */
    cursor?: RewardClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardClaims.
     */
    distinct?: RewardClaimScalarFieldEnum | RewardClaimScalarFieldEnum[]
  }

  /**
   * RewardClaim findFirstOrThrow
   */
  export type RewardClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaim to fetch.
     */
    where?: RewardClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardClaims to fetch.
     */
    orderBy?: RewardClaimOrderByWithRelationInput | RewardClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardClaims.
     */
    cursor?: RewardClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardClaims.
     */
    distinct?: RewardClaimScalarFieldEnum | RewardClaimScalarFieldEnum[]
  }

  /**
   * RewardClaim findMany
   */
  export type RewardClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaims to fetch.
     */
    where?: RewardClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardClaims to fetch.
     */
    orderBy?: RewardClaimOrderByWithRelationInput | RewardClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardClaims.
     */
    cursor?: RewardClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardClaims.
     */
    skip?: number
    distinct?: RewardClaimScalarFieldEnum | RewardClaimScalarFieldEnum[]
  }

  /**
   * RewardClaim create
   */
  export type RewardClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardClaim.
     */
    data: XOR<RewardClaimCreateInput, RewardClaimUncheckedCreateInput>
  }

  /**
   * RewardClaim createMany
   */
  export type RewardClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardClaims.
     */
    data: RewardClaimCreateManyInput | RewardClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardClaim createManyAndReturn
   */
  export type RewardClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * The data used to create many RewardClaims.
     */
    data: RewardClaimCreateManyInput | RewardClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardClaim update
   */
  export type RewardClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardClaim.
     */
    data: XOR<RewardClaimUpdateInput, RewardClaimUncheckedUpdateInput>
    /**
     * Choose, which RewardClaim to update.
     */
    where: RewardClaimWhereUniqueInput
  }

  /**
   * RewardClaim updateMany
   */
  export type RewardClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardClaims.
     */
    data: XOR<RewardClaimUpdateManyMutationInput, RewardClaimUncheckedUpdateManyInput>
    /**
     * Filter which RewardClaims to update
     */
    where?: RewardClaimWhereInput
    /**
     * Limit how many RewardClaims to update.
     */
    limit?: number
  }

  /**
   * RewardClaim updateManyAndReturn
   */
  export type RewardClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * The data used to update RewardClaims.
     */
    data: XOR<RewardClaimUpdateManyMutationInput, RewardClaimUncheckedUpdateManyInput>
    /**
     * Filter which RewardClaims to update
     */
    where?: RewardClaimWhereInput
    /**
     * Limit how many RewardClaims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardClaim upsert
   */
  export type RewardClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardClaim to update in case it exists.
     */
    where: RewardClaimWhereUniqueInput
    /**
     * In case the RewardClaim found by the `where` argument doesn't exist, create a new RewardClaim with this data.
     */
    create: XOR<RewardClaimCreateInput, RewardClaimUncheckedCreateInput>
    /**
     * In case the RewardClaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardClaimUpdateInput, RewardClaimUncheckedUpdateInput>
  }

  /**
   * RewardClaim delete
   */
  export type RewardClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
    /**
     * Filter which RewardClaim to delete.
     */
    where: RewardClaimWhereUniqueInput
  }

  /**
   * RewardClaim deleteMany
   */
  export type RewardClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardClaims to delete
     */
    where?: RewardClaimWhereInput
    /**
     * Limit how many RewardClaims to delete.
     */
    limit?: number
  }

  /**
   * RewardClaim without action
   */
  export type RewardClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaim
     */
    select?: RewardClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaim
     */
    omit?: RewardClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    referrerCoins: number | null
    refereeCoins: number | null
  }

  export type ReferralSumAggregateOutputType = {
    referrerCoins: number | null
    refereeCoins: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    referralCode: string | null
    status: $Enums.ReferralStatus | null
    referrerCoins: number | null
    refereeCoins: number | null
    rewardedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    referralCode: string | null
    status: $Enums.ReferralStatus | null
    referrerCoins: number | null
    refereeCoins: number | null
    rewardedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerId: number
    refereeId: number
    referralCode: number
    status: number
    referrerCoins: number
    refereeCoins: number
    rewardedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    referrerCoins?: true
    refereeCoins?: true
  }

  export type ReferralSumAggregateInputType = {
    referrerCoins?: true
    refereeCoins?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    referralCode?: true
    status?: true
    referrerCoins?: true
    refereeCoins?: true
    rewardedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    referralCode?: true
    status?: true
    referrerCoins?: true
    refereeCoins?: true
    rewardedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    referralCode?: true
    status?: true
    referrerCoins?: true
    refereeCoins?: true
    rewardedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrerId: string
    refereeId: string | null
    referralCode: string
    status: $Enums.ReferralStatus
    referrerCoins: number
    refereeCoins: number
    rewardedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    referralCode?: boolean
    status?: boolean
    referrerCoins?: boolean
    refereeCoins?: boolean
    rewardedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | Referral$refereeArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    referralCode?: boolean
    status?: boolean
    referrerCoins?: boolean
    refereeCoins?: boolean
    rewardedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | Referral$refereeArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    referralCode?: boolean
    status?: boolean
    referrerCoins?: boolean
    refereeCoins?: boolean
    rewardedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | Referral$refereeArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    referralCode?: boolean
    status?: boolean
    referrerCoins?: boolean
    refereeCoins?: boolean
    rewardedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referrerId" | "refereeId" | "referralCode" | "status" | "referrerCoins" | "refereeCoins" | "rewardedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | Referral$refereeArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | Referral$refereeArgs<ExtArgs>
  }
  export type ReferralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | Referral$refereeArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referee: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerId: string
      refereeId: string | null
      referralCode: string
      status: $Enums.ReferralStatus
      referrerCoins: number
      refereeCoins: number
      rewardedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referee<T extends Referral$refereeArgs<ExtArgs> = {}>(args?: Subset<T, Referral$refereeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrerId: FieldRef<"Referral", 'String'>
    readonly refereeId: FieldRef<"Referral", 'String'>
    readonly referralCode: FieldRef<"Referral", 'String'>
    readonly status: FieldRef<"Referral", 'ReferralStatus'>
    readonly referrerCoins: FieldRef<"Referral", 'Int'>
    readonly refereeCoins: FieldRef<"Referral", 'Int'>
    readonly rewardedAt: FieldRef<"Referral", 'DateTime'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
    readonly updatedAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral updateManyAndReturn
   */
  export type ReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral.referee
   */
  export type Referral$refereeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model CoinLedger
   */

  export type AggregateCoinLedger = {
    _count: CoinLedgerCountAggregateOutputType | null
    _avg: CoinLedgerAvgAggregateOutputType | null
    _sum: CoinLedgerSumAggregateOutputType | null
    _min: CoinLedgerMinAggregateOutputType | null
    _max: CoinLedgerMaxAggregateOutputType | null
  }

  export type CoinLedgerAvgAggregateOutputType = {
    delta: number | null
  }

  export type CoinLedgerSumAggregateOutputType = {
    delta: number | null
  }

  export type CoinLedgerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    delta: number | null
    source: $Enums.CoinLedgerSource | null
    referenceId: string | null
    createdAt: Date | null
  }

  export type CoinLedgerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    delta: number | null
    source: $Enums.CoinLedgerSource | null
    referenceId: string | null
    createdAt: Date | null
  }

  export type CoinLedgerCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    delta: number
    source: number
    referenceId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type CoinLedgerAvgAggregateInputType = {
    delta?: true
  }

  export type CoinLedgerSumAggregateInputType = {
    delta?: true
  }

  export type CoinLedgerMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    delta?: true
    source?: true
    referenceId?: true
    createdAt?: true
  }

  export type CoinLedgerMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    delta?: true
    source?: true
    referenceId?: true
    createdAt?: true
  }

  export type CoinLedgerCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    delta?: true
    source?: true
    referenceId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type CoinLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinLedger to aggregate.
     */
    where?: CoinLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinLedgers to fetch.
     */
    orderBy?: CoinLedgerOrderByWithRelationInput | CoinLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoinLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoinLedgers
    **/
    _count?: true | CoinLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoinLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoinLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoinLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoinLedgerMaxAggregateInputType
  }

  export type GetCoinLedgerAggregateType<T extends CoinLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateCoinLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoinLedger[P]>
      : GetScalarType<T[P], AggregateCoinLedger[P]>
  }




  export type CoinLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoinLedgerWhereInput
    orderBy?: CoinLedgerOrderByWithAggregationInput | CoinLedgerOrderByWithAggregationInput[]
    by: CoinLedgerScalarFieldEnum[] | CoinLedgerScalarFieldEnum
    having?: CoinLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoinLedgerCountAggregateInputType | true
    _avg?: CoinLedgerAvgAggregateInputType
    _sum?: CoinLedgerSumAggregateInputType
    _min?: CoinLedgerMinAggregateInputType
    _max?: CoinLedgerMaxAggregateInputType
  }

  export type CoinLedgerGroupByOutputType = {
    id: string
    userId: string
    date: Date
    delta: number
    source: $Enums.CoinLedgerSource
    referenceId: string
    metadata: JsonValue | null
    createdAt: Date
    _count: CoinLedgerCountAggregateOutputType | null
    _avg: CoinLedgerAvgAggregateOutputType | null
    _sum: CoinLedgerSumAggregateOutputType | null
    _min: CoinLedgerMinAggregateOutputType | null
    _max: CoinLedgerMaxAggregateOutputType | null
  }

  type GetCoinLedgerGroupByPayload<T extends CoinLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoinLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoinLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoinLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], CoinLedgerGroupByOutputType[P]>
        }
      >
    >


  export type CoinLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    delta?: boolean
    source?: boolean
    referenceId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinLedger"]>

  export type CoinLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    delta?: boolean
    source?: boolean
    referenceId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinLedger"]>

  export type CoinLedgerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    delta?: boolean
    source?: boolean
    referenceId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinLedger"]>

  export type CoinLedgerSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    delta?: boolean
    source?: boolean
    referenceId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type CoinLedgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "delta" | "source" | "referenceId" | "metadata" | "createdAt", ExtArgs["result"]["coinLedger"]>
  export type CoinLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CoinLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CoinLedgerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoinLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoinLedger"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      delta: number
      source: $Enums.CoinLedgerSource
      referenceId: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["coinLedger"]>
    composites: {}
  }

  type CoinLedgerGetPayload<S extends boolean | null | undefined | CoinLedgerDefaultArgs> = $Result.GetResult<Prisma.$CoinLedgerPayload, S>

  type CoinLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoinLedgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoinLedgerCountAggregateInputType | true
    }

  export interface CoinLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoinLedger'], meta: { name: 'CoinLedger' } }
    /**
     * Find zero or one CoinLedger that matches the filter.
     * @param {CoinLedgerFindUniqueArgs} args - Arguments to find a CoinLedger
     * @example
     * // Get one CoinLedger
     * const coinLedger = await prisma.coinLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoinLedgerFindUniqueArgs>(args: SelectSubset<T, CoinLedgerFindUniqueArgs<ExtArgs>>): Prisma__CoinLedgerClient<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoinLedger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoinLedgerFindUniqueOrThrowArgs} args - Arguments to find a CoinLedger
     * @example
     * // Get one CoinLedger
     * const coinLedger = await prisma.coinLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoinLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, CoinLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoinLedgerClient<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoinLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinLedgerFindFirstArgs} args - Arguments to find a CoinLedger
     * @example
     * // Get one CoinLedger
     * const coinLedger = await prisma.coinLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoinLedgerFindFirstArgs>(args?: SelectSubset<T, CoinLedgerFindFirstArgs<ExtArgs>>): Prisma__CoinLedgerClient<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoinLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinLedgerFindFirstOrThrowArgs} args - Arguments to find a CoinLedger
     * @example
     * // Get one CoinLedger
     * const coinLedger = await prisma.coinLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoinLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, CoinLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoinLedgerClient<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoinLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoinLedgers
     * const coinLedgers = await prisma.coinLedger.findMany()
     * 
     * // Get first 10 CoinLedgers
     * const coinLedgers = await prisma.coinLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coinLedgerWithIdOnly = await prisma.coinLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoinLedgerFindManyArgs>(args?: SelectSubset<T, CoinLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoinLedger.
     * @param {CoinLedgerCreateArgs} args - Arguments to create a CoinLedger.
     * @example
     * // Create one CoinLedger
     * const CoinLedger = await prisma.coinLedger.create({
     *   data: {
     *     // ... data to create a CoinLedger
     *   }
     * })
     * 
     */
    create<T extends CoinLedgerCreateArgs>(args: SelectSubset<T, CoinLedgerCreateArgs<ExtArgs>>): Prisma__CoinLedgerClient<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoinLedgers.
     * @param {CoinLedgerCreateManyArgs} args - Arguments to create many CoinLedgers.
     * @example
     * // Create many CoinLedgers
     * const coinLedger = await prisma.coinLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoinLedgerCreateManyArgs>(args?: SelectSubset<T, CoinLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoinLedgers and returns the data saved in the database.
     * @param {CoinLedgerCreateManyAndReturnArgs} args - Arguments to create many CoinLedgers.
     * @example
     * // Create many CoinLedgers
     * const coinLedger = await prisma.coinLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoinLedgers and only return the `id`
     * const coinLedgerWithIdOnly = await prisma.coinLedger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoinLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, CoinLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoinLedger.
     * @param {CoinLedgerDeleteArgs} args - Arguments to delete one CoinLedger.
     * @example
     * // Delete one CoinLedger
     * const CoinLedger = await prisma.coinLedger.delete({
     *   where: {
     *     // ... filter to delete one CoinLedger
     *   }
     * })
     * 
     */
    delete<T extends CoinLedgerDeleteArgs>(args: SelectSubset<T, CoinLedgerDeleteArgs<ExtArgs>>): Prisma__CoinLedgerClient<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoinLedger.
     * @param {CoinLedgerUpdateArgs} args - Arguments to update one CoinLedger.
     * @example
     * // Update one CoinLedger
     * const coinLedger = await prisma.coinLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoinLedgerUpdateArgs>(args: SelectSubset<T, CoinLedgerUpdateArgs<ExtArgs>>): Prisma__CoinLedgerClient<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoinLedgers.
     * @param {CoinLedgerDeleteManyArgs} args - Arguments to filter CoinLedgers to delete.
     * @example
     * // Delete a few CoinLedgers
     * const { count } = await prisma.coinLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoinLedgerDeleteManyArgs>(args?: SelectSubset<T, CoinLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoinLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoinLedgers
     * const coinLedger = await prisma.coinLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoinLedgerUpdateManyArgs>(args: SelectSubset<T, CoinLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoinLedgers and returns the data updated in the database.
     * @param {CoinLedgerUpdateManyAndReturnArgs} args - Arguments to update many CoinLedgers.
     * @example
     * // Update many CoinLedgers
     * const coinLedger = await prisma.coinLedger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoinLedgers and only return the `id`
     * const coinLedgerWithIdOnly = await prisma.coinLedger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoinLedgerUpdateManyAndReturnArgs>(args: SelectSubset<T, CoinLedgerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoinLedger.
     * @param {CoinLedgerUpsertArgs} args - Arguments to update or create a CoinLedger.
     * @example
     * // Update or create a CoinLedger
     * const coinLedger = await prisma.coinLedger.upsert({
     *   create: {
     *     // ... data to create a CoinLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoinLedger we want to update
     *   }
     * })
     */
    upsert<T extends CoinLedgerUpsertArgs>(args: SelectSubset<T, CoinLedgerUpsertArgs<ExtArgs>>): Prisma__CoinLedgerClient<$Result.GetResult<Prisma.$CoinLedgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoinLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinLedgerCountArgs} args - Arguments to filter CoinLedgers to count.
     * @example
     * // Count the number of CoinLedgers
     * const count = await prisma.coinLedger.count({
     *   where: {
     *     // ... the filter for the CoinLedgers we want to count
     *   }
     * })
    **/
    count<T extends CoinLedgerCountArgs>(
      args?: Subset<T, CoinLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoinLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoinLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoinLedgerAggregateArgs>(args: Subset<T, CoinLedgerAggregateArgs>): Prisma.PrismaPromise<GetCoinLedgerAggregateType<T>>

    /**
     * Group by CoinLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoinLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoinLedgerGroupByArgs['orderBy'] }
        : { orderBy?: CoinLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoinLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoinLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoinLedger model
   */
  readonly fields: CoinLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoinLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoinLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoinLedger model
   */
  interface CoinLedgerFieldRefs {
    readonly id: FieldRef<"CoinLedger", 'String'>
    readonly userId: FieldRef<"CoinLedger", 'String'>
    readonly date: FieldRef<"CoinLedger", 'DateTime'>
    readonly delta: FieldRef<"CoinLedger", 'Int'>
    readonly source: FieldRef<"CoinLedger", 'CoinLedgerSource'>
    readonly referenceId: FieldRef<"CoinLedger", 'String'>
    readonly metadata: FieldRef<"CoinLedger", 'Json'>
    readonly createdAt: FieldRef<"CoinLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoinLedger findUnique
   */
  export type CoinLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CoinLedger to fetch.
     */
    where: CoinLedgerWhereUniqueInput
  }

  /**
   * CoinLedger findUniqueOrThrow
   */
  export type CoinLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CoinLedger to fetch.
     */
    where: CoinLedgerWhereUniqueInput
  }

  /**
   * CoinLedger findFirst
   */
  export type CoinLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CoinLedger to fetch.
     */
    where?: CoinLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinLedgers to fetch.
     */
    orderBy?: CoinLedgerOrderByWithRelationInput | CoinLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinLedgers.
     */
    cursor?: CoinLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinLedgers.
     */
    distinct?: CoinLedgerScalarFieldEnum | CoinLedgerScalarFieldEnum[]
  }

  /**
   * CoinLedger findFirstOrThrow
   */
  export type CoinLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CoinLedger to fetch.
     */
    where?: CoinLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinLedgers to fetch.
     */
    orderBy?: CoinLedgerOrderByWithRelationInput | CoinLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinLedgers.
     */
    cursor?: CoinLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinLedgers.
     */
    distinct?: CoinLedgerScalarFieldEnum | CoinLedgerScalarFieldEnum[]
  }

  /**
   * CoinLedger findMany
   */
  export type CoinLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * Filter, which CoinLedgers to fetch.
     */
    where?: CoinLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinLedgers to fetch.
     */
    orderBy?: CoinLedgerOrderByWithRelationInput | CoinLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoinLedgers.
     */
    cursor?: CoinLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinLedgers.
     */
    skip?: number
    distinct?: CoinLedgerScalarFieldEnum | CoinLedgerScalarFieldEnum[]
  }

  /**
   * CoinLedger create
   */
  export type CoinLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a CoinLedger.
     */
    data: XOR<CoinLedgerCreateInput, CoinLedgerUncheckedCreateInput>
  }

  /**
   * CoinLedger createMany
   */
  export type CoinLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoinLedgers.
     */
    data: CoinLedgerCreateManyInput | CoinLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoinLedger createManyAndReturn
   */
  export type CoinLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * The data used to create many CoinLedgers.
     */
    data: CoinLedgerCreateManyInput | CoinLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoinLedger update
   */
  export type CoinLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a CoinLedger.
     */
    data: XOR<CoinLedgerUpdateInput, CoinLedgerUncheckedUpdateInput>
    /**
     * Choose, which CoinLedger to update.
     */
    where: CoinLedgerWhereUniqueInput
  }

  /**
   * CoinLedger updateMany
   */
  export type CoinLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoinLedgers.
     */
    data: XOR<CoinLedgerUpdateManyMutationInput, CoinLedgerUncheckedUpdateManyInput>
    /**
     * Filter which CoinLedgers to update
     */
    where?: CoinLedgerWhereInput
    /**
     * Limit how many CoinLedgers to update.
     */
    limit?: number
  }

  /**
   * CoinLedger updateManyAndReturn
   */
  export type CoinLedgerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * The data used to update CoinLedgers.
     */
    data: XOR<CoinLedgerUpdateManyMutationInput, CoinLedgerUncheckedUpdateManyInput>
    /**
     * Filter which CoinLedgers to update
     */
    where?: CoinLedgerWhereInput
    /**
     * Limit how many CoinLedgers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoinLedger upsert
   */
  export type CoinLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the CoinLedger to update in case it exists.
     */
    where: CoinLedgerWhereUniqueInput
    /**
     * In case the CoinLedger found by the `where` argument doesn't exist, create a new CoinLedger with this data.
     */
    create: XOR<CoinLedgerCreateInput, CoinLedgerUncheckedCreateInput>
    /**
     * In case the CoinLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoinLedgerUpdateInput, CoinLedgerUncheckedUpdateInput>
  }

  /**
   * CoinLedger delete
   */
  export type CoinLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
    /**
     * Filter which CoinLedger to delete.
     */
    where: CoinLedgerWhereUniqueInput
  }

  /**
   * CoinLedger deleteMany
   */
  export type CoinLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinLedgers to delete
     */
    where?: CoinLedgerWhereInput
    /**
     * Limit how many CoinLedgers to delete.
     */
    limit?: number
  }

  /**
   * CoinLedger without action
   */
  export type CoinLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinLedger
     */
    select?: CoinLedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinLedger
     */
    omit?: CoinLedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinLedgerInclude<ExtArgs> | null
  }


  /**
   * Model GameConfig
   */

  export type AggregateGameConfig = {
    _count: GameConfigCountAggregateOutputType | null
    _min: GameConfigMinAggregateOutputType | null
    _max: GameConfigMaxAggregateOutputType | null
  }

  export type GameConfigMinAggregateOutputType = {
    id: string | null
    version: string | null
    updatedBy: string | null
    notes: string | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type GameConfigMaxAggregateOutputType = {
    id: string | null
    version: string | null
    updatedBy: string | null
    notes: string | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type GameConfigCountAggregateOutputType = {
    id: number
    version: number
    daily_tournament: number
    instant_tournament: number
    single_player: number
    leveling: number
    base_points_by_level: number
    scoring: number
    points_distribution: number
    caps: number
    ad_units: number
    lifelines: number
    top_attempts: number
    feature_flags: number
    safety: number
    referrals: number
    rewards: number
    cron: number
    analytics: number
    leaderboard: number
    qa: number
    updatedBy: number
    notes: number
    createdAt: number
    isActive: number
    _all: number
  }


  export type GameConfigMinAggregateInputType = {
    id?: true
    version?: true
    updatedBy?: true
    notes?: true
    createdAt?: true
    isActive?: true
  }

  export type GameConfigMaxAggregateInputType = {
    id?: true
    version?: true
    updatedBy?: true
    notes?: true
    createdAt?: true
    isActive?: true
  }

  export type GameConfigCountAggregateInputType = {
    id?: true
    version?: true
    daily_tournament?: true
    instant_tournament?: true
    single_player?: true
    leveling?: true
    base_points_by_level?: true
    scoring?: true
    points_distribution?: true
    caps?: true
    ad_units?: true
    lifelines?: true
    top_attempts?: true
    feature_flags?: true
    safety?: true
    referrals?: true
    rewards?: true
    cron?: true
    analytics?: true
    leaderboard?: true
    qa?: true
    updatedBy?: true
    notes?: true
    createdAt?: true
    isActive?: true
    _all?: true
  }

  export type GameConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameConfig to aggregate.
     */
    where?: GameConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameConfigs to fetch.
     */
    orderBy?: GameConfigOrderByWithRelationInput | GameConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameConfigs
    **/
    _count?: true | GameConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameConfigMaxAggregateInputType
  }

  export type GetGameConfigAggregateType<T extends GameConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateGameConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameConfig[P]>
      : GetScalarType<T[P], AggregateGameConfig[P]>
  }




  export type GameConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameConfigWhereInput
    orderBy?: GameConfigOrderByWithAggregationInput | GameConfigOrderByWithAggregationInput[]
    by: GameConfigScalarFieldEnum[] | GameConfigScalarFieldEnum
    having?: GameConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameConfigCountAggregateInputType | true
    _min?: GameConfigMinAggregateInputType
    _max?: GameConfigMaxAggregateInputType
  }

  export type GameConfigGroupByOutputType = {
    id: string
    version: string
    daily_tournament: JsonValue
    instant_tournament: JsonValue
    single_player: JsonValue
    leveling: JsonValue
    base_points_by_level: JsonValue
    scoring: JsonValue
    points_distribution: JsonValue
    caps: JsonValue
    ad_units: JsonValue
    lifelines: JsonValue
    top_attempts: JsonValue
    feature_flags: JsonValue
    safety: JsonValue
    referrals: JsonValue
    rewards: JsonValue
    cron: JsonValue
    analytics: JsonValue
    leaderboard: JsonValue
    qa: JsonValue
    updatedBy: string
    notes: string | null
    createdAt: Date
    isActive: boolean
    _count: GameConfigCountAggregateOutputType | null
    _min: GameConfigMinAggregateOutputType | null
    _max: GameConfigMaxAggregateOutputType | null
  }

  type GetGameConfigGroupByPayload<T extends GameConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameConfigGroupByOutputType[P]>
            : GetScalarType<T[P], GameConfigGroupByOutputType[P]>
        }
      >
    >


  export type GameConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    daily_tournament?: boolean
    instant_tournament?: boolean
    single_player?: boolean
    leveling?: boolean
    base_points_by_level?: boolean
    scoring?: boolean
    points_distribution?: boolean
    caps?: boolean
    ad_units?: boolean
    lifelines?: boolean
    top_attempts?: boolean
    feature_flags?: boolean
    safety?: boolean
    referrals?: boolean
    rewards?: boolean
    cron?: boolean
    analytics?: boolean
    leaderboard?: boolean
    qa?: boolean
    updatedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["gameConfig"]>

  export type GameConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    daily_tournament?: boolean
    instant_tournament?: boolean
    single_player?: boolean
    leveling?: boolean
    base_points_by_level?: boolean
    scoring?: boolean
    points_distribution?: boolean
    caps?: boolean
    ad_units?: boolean
    lifelines?: boolean
    top_attempts?: boolean
    feature_flags?: boolean
    safety?: boolean
    referrals?: boolean
    rewards?: boolean
    cron?: boolean
    analytics?: boolean
    leaderboard?: boolean
    qa?: boolean
    updatedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["gameConfig"]>

  export type GameConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    daily_tournament?: boolean
    instant_tournament?: boolean
    single_player?: boolean
    leveling?: boolean
    base_points_by_level?: boolean
    scoring?: boolean
    points_distribution?: boolean
    caps?: boolean
    ad_units?: boolean
    lifelines?: boolean
    top_attempts?: boolean
    feature_flags?: boolean
    safety?: boolean
    referrals?: boolean
    rewards?: boolean
    cron?: boolean
    analytics?: boolean
    leaderboard?: boolean
    qa?: boolean
    updatedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["gameConfig"]>

  export type GameConfigSelectScalar = {
    id?: boolean
    version?: boolean
    daily_tournament?: boolean
    instant_tournament?: boolean
    single_player?: boolean
    leveling?: boolean
    base_points_by_level?: boolean
    scoring?: boolean
    points_distribution?: boolean
    caps?: boolean
    ad_units?: boolean
    lifelines?: boolean
    top_attempts?: boolean
    feature_flags?: boolean
    safety?: boolean
    referrals?: boolean
    rewards?: boolean
    cron?: boolean
    analytics?: boolean
    leaderboard?: boolean
    qa?: boolean
    updatedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    isActive?: boolean
  }

  export type GameConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version" | "daily_tournament" | "instant_tournament" | "single_player" | "leveling" | "base_points_by_level" | "scoring" | "points_distribution" | "caps" | "ad_units" | "lifelines" | "top_attempts" | "feature_flags" | "safety" | "referrals" | "rewards" | "cron" | "analytics" | "leaderboard" | "qa" | "updatedBy" | "notes" | "createdAt" | "isActive", ExtArgs["result"]["gameConfig"]>

  export type $GameConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      daily_tournament: Prisma.JsonValue
      instant_tournament: Prisma.JsonValue
      single_player: Prisma.JsonValue
      leveling: Prisma.JsonValue
      base_points_by_level: Prisma.JsonValue
      scoring: Prisma.JsonValue
      points_distribution: Prisma.JsonValue
      caps: Prisma.JsonValue
      ad_units: Prisma.JsonValue
      lifelines: Prisma.JsonValue
      top_attempts: Prisma.JsonValue
      feature_flags: Prisma.JsonValue
      safety: Prisma.JsonValue
      referrals: Prisma.JsonValue
      rewards: Prisma.JsonValue
      cron: Prisma.JsonValue
      analytics: Prisma.JsonValue
      leaderboard: Prisma.JsonValue
      qa: Prisma.JsonValue
      updatedBy: string
      notes: string | null
      createdAt: Date
      isActive: boolean
    }, ExtArgs["result"]["gameConfig"]>
    composites: {}
  }

  type GameConfigGetPayload<S extends boolean | null | undefined | GameConfigDefaultArgs> = $Result.GetResult<Prisma.$GameConfigPayload, S>

  type GameConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameConfigCountAggregateInputType | true
    }

  export interface GameConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameConfig'], meta: { name: 'GameConfig' } }
    /**
     * Find zero or one GameConfig that matches the filter.
     * @param {GameConfigFindUniqueArgs} args - Arguments to find a GameConfig
     * @example
     * // Get one GameConfig
     * const gameConfig = await prisma.gameConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameConfigFindUniqueArgs>(args: SelectSubset<T, GameConfigFindUniqueArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameConfigFindUniqueOrThrowArgs} args - Arguments to find a GameConfig
     * @example
     * // Get one GameConfig
     * const gameConfig = await prisma.gameConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, GameConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigFindFirstArgs} args - Arguments to find a GameConfig
     * @example
     * // Get one GameConfig
     * const gameConfig = await prisma.gameConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameConfigFindFirstArgs>(args?: SelectSubset<T, GameConfigFindFirstArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigFindFirstOrThrowArgs} args - Arguments to find a GameConfig
     * @example
     * // Get one GameConfig
     * const gameConfig = await prisma.gameConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, GameConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameConfigs
     * const gameConfigs = await prisma.gameConfig.findMany()
     * 
     * // Get first 10 GameConfigs
     * const gameConfigs = await prisma.gameConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameConfigWithIdOnly = await prisma.gameConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameConfigFindManyArgs>(args?: SelectSubset<T, GameConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameConfig.
     * @param {GameConfigCreateArgs} args - Arguments to create a GameConfig.
     * @example
     * // Create one GameConfig
     * const GameConfig = await prisma.gameConfig.create({
     *   data: {
     *     // ... data to create a GameConfig
     *   }
     * })
     * 
     */
    create<T extends GameConfigCreateArgs>(args: SelectSubset<T, GameConfigCreateArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameConfigs.
     * @param {GameConfigCreateManyArgs} args - Arguments to create many GameConfigs.
     * @example
     * // Create many GameConfigs
     * const gameConfig = await prisma.gameConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameConfigCreateManyArgs>(args?: SelectSubset<T, GameConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameConfigs and returns the data saved in the database.
     * @param {GameConfigCreateManyAndReturnArgs} args - Arguments to create many GameConfigs.
     * @example
     * // Create many GameConfigs
     * const gameConfig = await prisma.gameConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameConfigs and only return the `id`
     * const gameConfigWithIdOnly = await prisma.gameConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, GameConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameConfig.
     * @param {GameConfigDeleteArgs} args - Arguments to delete one GameConfig.
     * @example
     * // Delete one GameConfig
     * const GameConfig = await prisma.gameConfig.delete({
     *   where: {
     *     // ... filter to delete one GameConfig
     *   }
     * })
     * 
     */
    delete<T extends GameConfigDeleteArgs>(args: SelectSubset<T, GameConfigDeleteArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameConfig.
     * @param {GameConfigUpdateArgs} args - Arguments to update one GameConfig.
     * @example
     * // Update one GameConfig
     * const gameConfig = await prisma.gameConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameConfigUpdateArgs>(args: SelectSubset<T, GameConfigUpdateArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameConfigs.
     * @param {GameConfigDeleteManyArgs} args - Arguments to filter GameConfigs to delete.
     * @example
     * // Delete a few GameConfigs
     * const { count } = await prisma.gameConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameConfigDeleteManyArgs>(args?: SelectSubset<T, GameConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameConfigs
     * const gameConfig = await prisma.gameConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameConfigUpdateManyArgs>(args: SelectSubset<T, GameConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameConfigs and returns the data updated in the database.
     * @param {GameConfigUpdateManyAndReturnArgs} args - Arguments to update many GameConfigs.
     * @example
     * // Update many GameConfigs
     * const gameConfig = await prisma.gameConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameConfigs and only return the `id`
     * const gameConfigWithIdOnly = await prisma.gameConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, GameConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameConfig.
     * @param {GameConfigUpsertArgs} args - Arguments to update or create a GameConfig.
     * @example
     * // Update or create a GameConfig
     * const gameConfig = await prisma.gameConfig.upsert({
     *   create: {
     *     // ... data to create a GameConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameConfig we want to update
     *   }
     * })
     */
    upsert<T extends GameConfigUpsertArgs>(args: SelectSubset<T, GameConfigUpsertArgs<ExtArgs>>): Prisma__GameConfigClient<$Result.GetResult<Prisma.$GameConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigCountArgs} args - Arguments to filter GameConfigs to count.
     * @example
     * // Count the number of GameConfigs
     * const count = await prisma.gameConfig.count({
     *   where: {
     *     // ... the filter for the GameConfigs we want to count
     *   }
     * })
    **/
    count<T extends GameConfigCountArgs>(
      args?: Subset<T, GameConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameConfigAggregateArgs>(args: Subset<T, GameConfigAggregateArgs>): Prisma.PrismaPromise<GetGameConfigAggregateType<T>>

    /**
     * Group by GameConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameConfigGroupByArgs['orderBy'] }
        : { orderBy?: GameConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameConfig model
   */
  readonly fields: GameConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameConfig model
   */
  interface GameConfigFieldRefs {
    readonly id: FieldRef<"GameConfig", 'String'>
    readonly version: FieldRef<"GameConfig", 'String'>
    readonly daily_tournament: FieldRef<"GameConfig", 'Json'>
    readonly instant_tournament: FieldRef<"GameConfig", 'Json'>
    readonly single_player: FieldRef<"GameConfig", 'Json'>
    readonly leveling: FieldRef<"GameConfig", 'Json'>
    readonly base_points_by_level: FieldRef<"GameConfig", 'Json'>
    readonly scoring: FieldRef<"GameConfig", 'Json'>
    readonly points_distribution: FieldRef<"GameConfig", 'Json'>
    readonly caps: FieldRef<"GameConfig", 'Json'>
    readonly ad_units: FieldRef<"GameConfig", 'Json'>
    readonly lifelines: FieldRef<"GameConfig", 'Json'>
    readonly top_attempts: FieldRef<"GameConfig", 'Json'>
    readonly feature_flags: FieldRef<"GameConfig", 'Json'>
    readonly safety: FieldRef<"GameConfig", 'Json'>
    readonly referrals: FieldRef<"GameConfig", 'Json'>
    readonly rewards: FieldRef<"GameConfig", 'Json'>
    readonly cron: FieldRef<"GameConfig", 'Json'>
    readonly analytics: FieldRef<"GameConfig", 'Json'>
    readonly leaderboard: FieldRef<"GameConfig", 'Json'>
    readonly qa: FieldRef<"GameConfig", 'Json'>
    readonly updatedBy: FieldRef<"GameConfig", 'String'>
    readonly notes: FieldRef<"GameConfig", 'String'>
    readonly createdAt: FieldRef<"GameConfig", 'DateTime'>
    readonly isActive: FieldRef<"GameConfig", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * GameConfig findUnique
   */
  export type GameConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * Filter, which GameConfig to fetch.
     */
    where: GameConfigWhereUniqueInput
  }

  /**
   * GameConfig findUniqueOrThrow
   */
  export type GameConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * Filter, which GameConfig to fetch.
     */
    where: GameConfigWhereUniqueInput
  }

  /**
   * GameConfig findFirst
   */
  export type GameConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * Filter, which GameConfig to fetch.
     */
    where?: GameConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameConfigs to fetch.
     */
    orderBy?: GameConfigOrderByWithRelationInput | GameConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameConfigs.
     */
    cursor?: GameConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameConfigs.
     */
    distinct?: GameConfigScalarFieldEnum | GameConfigScalarFieldEnum[]
  }

  /**
   * GameConfig findFirstOrThrow
   */
  export type GameConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * Filter, which GameConfig to fetch.
     */
    where?: GameConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameConfigs to fetch.
     */
    orderBy?: GameConfigOrderByWithRelationInput | GameConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameConfigs.
     */
    cursor?: GameConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameConfigs.
     */
    distinct?: GameConfigScalarFieldEnum | GameConfigScalarFieldEnum[]
  }

  /**
   * GameConfig findMany
   */
  export type GameConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * Filter, which GameConfigs to fetch.
     */
    where?: GameConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameConfigs to fetch.
     */
    orderBy?: GameConfigOrderByWithRelationInput | GameConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameConfigs.
     */
    cursor?: GameConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameConfigs.
     */
    skip?: number
    distinct?: GameConfigScalarFieldEnum | GameConfigScalarFieldEnum[]
  }

  /**
   * GameConfig create
   */
  export type GameConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a GameConfig.
     */
    data: XOR<GameConfigCreateInput, GameConfigUncheckedCreateInput>
  }

  /**
   * GameConfig createMany
   */
  export type GameConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameConfigs.
     */
    data: GameConfigCreateManyInput | GameConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameConfig createManyAndReturn
   */
  export type GameConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * The data used to create many GameConfigs.
     */
    data: GameConfigCreateManyInput | GameConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameConfig update
   */
  export type GameConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a GameConfig.
     */
    data: XOR<GameConfigUpdateInput, GameConfigUncheckedUpdateInput>
    /**
     * Choose, which GameConfig to update.
     */
    where: GameConfigWhereUniqueInput
  }

  /**
   * GameConfig updateMany
   */
  export type GameConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameConfigs.
     */
    data: XOR<GameConfigUpdateManyMutationInput, GameConfigUncheckedUpdateManyInput>
    /**
     * Filter which GameConfigs to update
     */
    where?: GameConfigWhereInput
    /**
     * Limit how many GameConfigs to update.
     */
    limit?: number
  }

  /**
   * GameConfig updateManyAndReturn
   */
  export type GameConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * The data used to update GameConfigs.
     */
    data: XOR<GameConfigUpdateManyMutationInput, GameConfigUncheckedUpdateManyInput>
    /**
     * Filter which GameConfigs to update
     */
    where?: GameConfigWhereInput
    /**
     * Limit how many GameConfigs to update.
     */
    limit?: number
  }

  /**
   * GameConfig upsert
   */
  export type GameConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the GameConfig to update in case it exists.
     */
    where: GameConfigWhereUniqueInput
    /**
     * In case the GameConfig found by the `where` argument doesn't exist, create a new GameConfig with this data.
     */
    create: XOR<GameConfigCreateInput, GameConfigUncheckedCreateInput>
    /**
     * In case the GameConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameConfigUpdateInput, GameConfigUncheckedUpdateInput>
  }

  /**
   * GameConfig delete
   */
  export type GameConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
    /**
     * Filter which GameConfig to delete.
     */
    where: GameConfigWhereUniqueInput
  }

  /**
   * GameConfig deleteMany
   */
  export type GameConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameConfigs to delete
     */
    where?: GameConfigWhereInput
    /**
     * Limit how many GameConfigs to delete.
     */
    limit?: number
  }

  /**
   * GameConfig without action
   */
  export type GameConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameConfig
     */
    select?: GameConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameConfig
     */
    omit?: GameConfigOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phoneNumber: 'phoneNumber',
    googleId: 'googleId',
    email: 'email',
    deviceHash: 'deviceHash',
    username: 'username',
    usernameReservedAt: 'usernameReservedAt',
    avatarType: 'avatarType',
    profilePictureUrl: 'profilePictureUrl',
    coins: 'coins',
    lifetimeCoins: 'lifetimeCoins',
    lifetimeCoinPoints: 'lifetimeCoinPoints',
    level: 'level',
    theme: 'theme',
    soundEnabled: 'soundEnabled',
    hapticsEnabled: 'hapticsEnabled',
    language: 'language',
    referralCode: 'referralCode',
    referredById: 'referredById',
    referralRewarded: 'referralRewarded',
    role: 'role',
    soloAttemptCount: 'soloAttemptCount',
    instantAttemptCount: 'instantAttemptCount',
    dailyAttemptCount: 'dailyAttemptCount',
    currentLoginStreak: 'currentLoginStreak',
    longestLoginStreak: 'longestLoginStreak',
    lastLoginRewardDate: 'lastLoginRewardDate',
    totalLoginDays: 'totalLoginDays'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DailyTournamentScalarFieldEnum: {
    id: 'id',
    date: 'date',
    createdAt: 'createdAt',
    status: 'status',
    configVersion: 'configVersion',
    final: 'final'
  };

  export type DailyTournamentScalarFieldEnum = (typeof DailyTournamentScalarFieldEnum)[keyof typeof DailyTournamentScalarFieldEnum]


  export const DailyTournamentSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    tournamentId: 'tournamentId',
    sessionSeed: 'sessionSeed',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    currentScore: 'currentScore',
    finalScore: 'finalScore',
    minute1Score: 'minute1Score',
    minute2Score: 'minute2Score',
    minute3Score: 'minute3Score',
    minute4Score: 'minute4Score',
    isFreeAttempt: 'isFreeAttempt',
    isRewardedAttempt: 'isRewardedAttempt',
    currentLevel: 'currentLevel',
    questionsAnswered: 'questionsAnswered',
    correctAnswers: 'correctAnswers',
    endsAt: 'endsAt'
  };

  export type DailyTournamentSessionScalarFieldEnum = (typeof DailyTournamentSessionScalarFieldEnum)[keyof typeof DailyTournamentSessionScalarFieldEnum]


  export const MinuteSnapshotScalarFieldEnum: {
    id: 'id',
    tournamentId: 'tournamentId',
    minuteNumber: 'minuteNumber',
    snapshot: 'snapshot',
    createdAt: 'createdAt'
  };

  export type MinuteSnapshotScalarFieldEnum = (typeof MinuteSnapshotScalarFieldEnum)[keyof typeof MinuteSnapshotScalarFieldEnum]


  export const SoloSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    date: 'date',
    sessionSeed: 'sessionSeed',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    currentRound: 'currentRound',
    bankedPoints: 'bankedPoints',
    finalScore: 'finalScore',
    coinPointsEarned: 'coinPointsEarned',
    isFreeAttempt: 'isFreeAttempt',
    currentLevel: 'currentLevel',
    questionsAnswered: 'questionsAnswered',
    correctAnswers: 'correctAnswers',
    madeMistake: 'madeMistake',
    quitEarly: 'quitEarly'
  };

  export type SoloSessionScalarFieldEnum = (typeof SoloSessionScalarFieldEnum)[keyof typeof SoloSessionScalarFieldEnum]


  export const QuestionAttemptScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    questionIndex: 'questionIndex',
    level: 'level',
    expression: 'expression',
    result: 'result',
    side: 'side',
    kthDigit: 'kthDigit',
    correctDigit: 'correctDigit',
    dailySessionId: 'dailySessionId',
    soloSessionId: 'soloSessionId',
    instantSessionId: 'instantSessionId'
  };

  export type QuestionAttemptScalarFieldEnum = (typeof QuestionAttemptScalarFieldEnum)[keyof typeof QuestionAttemptScalarFieldEnum]


  export const InstantTournamentScalarFieldEnum: {
    id: 'id',
    status: 'status',
    maxPlayers: 'maxPlayers',
    playersCount: 'playersCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt'
  };

  export type InstantTournamentScalarFieldEnum = (typeof InstantTournamentScalarFieldEnum)[keyof typeof InstantTournamentScalarFieldEnum]


  export const InstantSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    tournamentId: 'tournamentId',
    score: 'score',
    finalScore: 'finalScore',
    bestScore: 'bestScore',
    startedAt: 'startedAt',
    endsAt: 'endsAt',
    submittedAt: 'submittedAt'
  };

  export type InstantSessionScalarFieldEnum = (typeof InstantSessionScalarFieldEnum)[keyof typeof InstantSessionScalarFieldEnum]


  export const InstantParticipantScalarFieldEnum: {
    tournamentId: 'tournamentId',
    userId: 'userId',
    joinedAt: 'joinedAt',
    joinOrder: 'joinOrder',
    sessionStarted: 'sessionStarted',
    finalScore: 'finalScore',
    submittedAt: 'submittedAt',
    finalRank: 'finalRank'
  };

  export type InstantParticipantScalarFieldEnum = (typeof InstantParticipantScalarFieldEnum)[keyof typeof InstantParticipantScalarFieldEnum]


  export const DailyLeaderboardScalarFieldEnum: {
    id: 'id',
    date: 'date',
    userId: 'userId',
    bestScore: 'bestScore',
    rank: 'rank',
    coinPoints: 'coinPoints',
    updatedAt: 'updatedAt'
  };

  export type DailyLeaderboardScalarFieldEnum = (typeof DailyLeaderboardScalarFieldEnum)[keyof typeof DailyLeaderboardScalarFieldEnum]


  export const InstantLeaderboardScalarFieldEnum: {
    id: 'id',
    tournamentId: 'tournamentId',
    userId: 'userId',
    bestScore: 'bestScore',
    rank: 'rank',
    coinPoints: 'coinPoints',
    submittedAt: 'submittedAt',
    updatedAt: 'updatedAt',
    date: 'date'
  };

  export type InstantLeaderboardScalarFieldEnum = (typeof InstantLeaderboardScalarFieldEnum)[keyof typeof InstantLeaderboardScalarFieldEnum]


  export const DailyUserLeaderboardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    dailyCoinPoints: 'dailyCoinPoints',
    instantCoinPoints: 'instantCoinPoints',
    totalCoinPoints: 'totalCoinPoints',
    rank: 'rank',
    isEligible: 'isEligible',
    coinsAwarded: 'coinsAwarded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyUserLeaderboardScalarFieldEnum = (typeof DailyUserLeaderboardScalarFieldEnum)[keyof typeof DailyUserLeaderboardScalarFieldEnum]


  export const SoloLeaderboardScalarFieldEnum: {
    id: 'id',
    date: 'date',
    userId: 'userId',
    score: 'score',
    rank: 'rank',
    percentile: 'percentile',
    coinPoints: 'coinPoints',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SoloLeaderboardScalarFieldEnum = (typeof SoloLeaderboardScalarFieldEnum)[keyof typeof SoloLeaderboardScalarFieldEnum]


  export const RewardClaimScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coinsLocked: 'coinsLocked',
    status: 'status',
    voucherCode: 'voucherCode',
    adminNotes: 'adminNotes',
    fulfilledBy: 'fulfilledBy',
    fulfilledAt: 'fulfilledAt',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RewardClaimScalarFieldEnum = (typeof RewardClaimScalarFieldEnum)[keyof typeof RewardClaimScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    referralCode: 'referralCode',
    status: 'status',
    referrerCoins: 'referrerCoins',
    refereeCoins: 'refereeCoins',
    rewardedAt: 'rewardedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const CoinLedgerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    delta: 'delta',
    source: 'source',
    referenceId: 'referenceId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type CoinLedgerScalarFieldEnum = (typeof CoinLedgerScalarFieldEnum)[keyof typeof CoinLedgerScalarFieldEnum]


  export const GameConfigScalarFieldEnum: {
    id: 'id',
    version: 'version',
    daily_tournament: 'daily_tournament',
    instant_tournament: 'instant_tournament',
    single_player: 'single_player',
    leveling: 'leveling',
    base_points_by_level: 'base_points_by_level',
    scoring: 'scoring',
    points_distribution: 'points_distribution',
    caps: 'caps',
    ad_units: 'ad_units',
    lifelines: 'lifelines',
    top_attempts: 'top_attempts',
    feature_flags: 'feature_flags',
    safety: 'safety',
    referrals: 'referrals',
    rewards: 'rewards',
    cron: 'cron',
    analytics: 'analytics',
    leaderboard: 'leaderboard',
    qa: 'qa',
    updatedBy: 'updatedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    isActive: 'isActive'
  };

  export type GameConfigScalarFieldEnum = (typeof GameConfigScalarFieldEnum)[keyof typeof GameConfigScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AvatarType'
   */
  export type EnumAvatarTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvatarType'>
    


  /**
   * Reference to a field of type 'AvatarType[]'
   */
  export type ListEnumAvatarTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvatarType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Theme'
   */
  export type EnumThemeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Theme'>
    


  /**
   * Reference to a field of type 'Theme[]'
   */
  export type ListEnumThemeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Theme[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'TournamentStatus'
   */
  export type EnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus'>
    


  /**
   * Reference to a field of type 'TournamentStatus[]'
   */
  export type ListEnumTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TournamentStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'UserTournamentStatus'
   */
  export type EnumUserTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTournamentStatus'>
    


  /**
   * Reference to a field of type 'UserTournamentStatus[]'
   */
  export type ListEnumUserTournamentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserTournamentStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'InstantTournamentSessionStatus'
   */
  export type EnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstantTournamentSessionStatus'>
    


  /**
   * Reference to a field of type 'InstantTournamentSessionStatus[]'
   */
  export type ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstantTournamentSessionStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ClaimStatus'
   */
  export type EnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus'>
    


  /**
   * Reference to a field of type 'ClaimStatus[]'
   */
  export type ListEnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus[]'>
    


  /**
   * Reference to a field of type 'ReferralStatus'
   */
  export type EnumReferralStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralStatus'>
    


  /**
   * Reference to a field of type 'ReferralStatus[]'
   */
  export type ListEnumReferralStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReferralStatus[]'>
    


  /**
   * Reference to a field of type 'CoinLedgerSource'
   */
  export type EnumCoinLedgerSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoinLedgerSource'>
    


  /**
   * Reference to a field of type 'CoinLedgerSource[]'
   */
  export type ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoinLedgerSource[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    deviceHash?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    usernameReservedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    avatarType?: EnumAvatarTypeFilter<"User"> | $Enums.AvatarType
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    coins?: IntFilter<"User"> | number
    lifetimeCoins?: IntFilter<"User"> | number
    lifetimeCoinPoints?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    theme?: EnumThemeFilter<"User"> | $Enums.Theme
    soundEnabled?: BoolFilter<"User"> | boolean
    hapticsEnabled?: BoolFilter<"User"> | boolean
    language?: StringFilter<"User"> | string
    referralCode?: StringNullableFilter<"User"> | string | null
    referredById?: StringNullableFilter<"User"> | string | null
    referralRewarded?: BoolFilter<"User"> | boolean
    role?: EnumRoleFilter<"User"> | $Enums.Role
    soloAttemptCount?: IntFilter<"User"> | number
    instantAttemptCount?: IntFilter<"User"> | number
    dailyAttemptCount?: IntFilter<"User"> | number
    currentLoginStreak?: IntFilter<"User"> | number
    longestLoginStreak?: IntFilter<"User"> | number
    lastLoginRewardDate?: DateTimeNullableFilter<"User"> | Date | string | null
    totalLoginDays?: IntFilter<"User"> | number
    referredBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    dailySessions?: DailyTournamentSessionListRelationFilter
    soloSessions?: SoloSessionListRelationFilter
    instantSessions?: InstantSessionListRelationFilter
    instantParticipant?: InstantParticipantListRelationFilter
    dailyLeaderBoards?: DailyLeaderboardListRelationFilter
    instantLeaderboard?: InstantLeaderboardListRelationFilter
    rewardClaim?: RewardClaimListRelationFilter
    referralsGiven?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
    coinLedger?: CoinLedgerListRelationFilter
    dailyUserLeaderboard?: DailyUserLeaderboardListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    deviceHash?: SortOrderInput | SortOrder
    username?: SortOrder
    usernameReservedAt?: SortOrderInput | SortOrder
    avatarType?: SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    coins?: SortOrder
    lifetimeCoins?: SortOrder
    lifetimeCoinPoints?: SortOrder
    level?: SortOrder
    theme?: SortOrder
    soundEnabled?: SortOrder
    hapticsEnabled?: SortOrder
    language?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredById?: SortOrderInput | SortOrder
    referralRewarded?: SortOrder
    role?: SortOrder
    soloAttemptCount?: SortOrder
    instantAttemptCount?: SortOrder
    dailyAttemptCount?: SortOrder
    currentLoginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    lastLoginRewardDate?: SortOrderInput | SortOrder
    totalLoginDays?: SortOrder
    referredBy?: UserOrderByWithRelationInput
    referrals?: UserOrderByRelationAggregateInput
    dailySessions?: DailyTournamentSessionOrderByRelationAggregateInput
    soloSessions?: SoloSessionOrderByRelationAggregateInput
    instantSessions?: InstantSessionOrderByRelationAggregateInput
    instantParticipant?: InstantParticipantOrderByRelationAggregateInput
    dailyLeaderBoards?: DailyLeaderboardOrderByRelationAggregateInput
    instantLeaderboard?: InstantLeaderboardOrderByRelationAggregateInput
    rewardClaim?: RewardClaimOrderByRelationAggregateInput
    referralsGiven?: ReferralOrderByRelationAggregateInput
    referralsReceived?: ReferralOrderByRelationAggregateInput
    coinLedger?: CoinLedgerOrderByRelationAggregateInput
    dailyUserLeaderboard?: DailyUserLeaderboardOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phoneNumber?: string
    googleId?: string
    email?: string
    username?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deviceHash?: StringNullableFilter<"User"> | string | null
    usernameReservedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    avatarType?: EnumAvatarTypeFilter<"User"> | $Enums.AvatarType
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    coins?: IntFilter<"User"> | number
    lifetimeCoins?: IntFilter<"User"> | number
    lifetimeCoinPoints?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    theme?: EnumThemeFilter<"User"> | $Enums.Theme
    soundEnabled?: BoolFilter<"User"> | boolean
    hapticsEnabled?: BoolFilter<"User"> | boolean
    language?: StringFilter<"User"> | string
    referredById?: StringNullableFilter<"User"> | string | null
    referralRewarded?: BoolFilter<"User"> | boolean
    role?: EnumRoleFilter<"User"> | $Enums.Role
    soloAttemptCount?: IntFilter<"User"> | number
    instantAttemptCount?: IntFilter<"User"> | number
    dailyAttemptCount?: IntFilter<"User"> | number
    currentLoginStreak?: IntFilter<"User"> | number
    longestLoginStreak?: IntFilter<"User"> | number
    lastLoginRewardDate?: DateTimeNullableFilter<"User"> | Date | string | null
    totalLoginDays?: IntFilter<"User"> | number
    referredBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    dailySessions?: DailyTournamentSessionListRelationFilter
    soloSessions?: SoloSessionListRelationFilter
    instantSessions?: InstantSessionListRelationFilter
    instantParticipant?: InstantParticipantListRelationFilter
    dailyLeaderBoards?: DailyLeaderboardListRelationFilter
    instantLeaderboard?: InstantLeaderboardListRelationFilter
    rewardClaim?: RewardClaimListRelationFilter
    referralsGiven?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
    coinLedger?: CoinLedgerListRelationFilter
    dailyUserLeaderboard?: DailyUserLeaderboardListRelationFilter
  }, "id" | "phoneNumber" | "googleId" | "email" | "username" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    googleId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    deviceHash?: SortOrderInput | SortOrder
    username?: SortOrder
    usernameReservedAt?: SortOrderInput | SortOrder
    avatarType?: SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    coins?: SortOrder
    lifetimeCoins?: SortOrder
    lifetimeCoinPoints?: SortOrder
    level?: SortOrder
    theme?: SortOrder
    soundEnabled?: SortOrder
    hapticsEnabled?: SortOrder
    language?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredById?: SortOrderInput | SortOrder
    referralRewarded?: SortOrder
    role?: SortOrder
    soloAttemptCount?: SortOrder
    instantAttemptCount?: SortOrder
    dailyAttemptCount?: SortOrder
    currentLoginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    lastLoginRewardDate?: SortOrderInput | SortOrder
    totalLoginDays?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    deviceHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    usernameReservedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    avatarType?: EnumAvatarTypeWithAggregatesFilter<"User"> | $Enums.AvatarType
    profilePictureUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    coins?: IntWithAggregatesFilter<"User"> | number
    lifetimeCoins?: IntWithAggregatesFilter<"User"> | number
    lifetimeCoinPoints?: IntWithAggregatesFilter<"User"> | number
    level?: IntWithAggregatesFilter<"User"> | number
    theme?: EnumThemeWithAggregatesFilter<"User"> | $Enums.Theme
    soundEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    hapticsEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    language?: StringWithAggregatesFilter<"User"> | string
    referralCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    referredById?: StringNullableWithAggregatesFilter<"User"> | string | null
    referralRewarded?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    soloAttemptCount?: IntWithAggregatesFilter<"User"> | number
    instantAttemptCount?: IntWithAggregatesFilter<"User"> | number
    dailyAttemptCount?: IntWithAggregatesFilter<"User"> | number
    currentLoginStreak?: IntWithAggregatesFilter<"User"> | number
    longestLoginStreak?: IntWithAggregatesFilter<"User"> | number
    lastLoginRewardDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    totalLoginDays?: IntWithAggregatesFilter<"User"> | number
  }

  export type DailyTournamentWhereInput = {
    AND?: DailyTournamentWhereInput | DailyTournamentWhereInput[]
    OR?: DailyTournamentWhereInput[]
    NOT?: DailyTournamentWhereInput | DailyTournamentWhereInput[]
    id?: StringFilter<"DailyTournament"> | string
    date?: DateTimeFilter<"DailyTournament"> | Date | string
    createdAt?: DateTimeFilter<"DailyTournament"> | Date | string
    status?: EnumTournamentStatusFilter<"DailyTournament"> | $Enums.TournamentStatus
    configVersion?: StringNullableFilter<"DailyTournament"> | string | null
    final?: JsonFilter<"DailyTournament">
    minuteSnapshot?: MinuteSnapshotListRelationFilter
    sessions?: DailyTournamentSessionListRelationFilter
  }

  export type DailyTournamentOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    configVersion?: SortOrderInput | SortOrder
    final?: SortOrder
    minuteSnapshot?: MinuteSnapshotOrderByRelationAggregateInput
    sessions?: DailyTournamentSessionOrderByRelationAggregateInput
  }

  export type DailyTournamentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    AND?: DailyTournamentWhereInput | DailyTournamentWhereInput[]
    OR?: DailyTournamentWhereInput[]
    NOT?: DailyTournamentWhereInput | DailyTournamentWhereInput[]
    createdAt?: DateTimeFilter<"DailyTournament"> | Date | string
    status?: EnumTournamentStatusFilter<"DailyTournament"> | $Enums.TournamentStatus
    configVersion?: StringNullableFilter<"DailyTournament"> | string | null
    final?: JsonFilter<"DailyTournament">
    minuteSnapshot?: MinuteSnapshotListRelationFilter
    sessions?: DailyTournamentSessionListRelationFilter
  }, "id" | "date">

  export type DailyTournamentOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    configVersion?: SortOrderInput | SortOrder
    final?: SortOrder
    _count?: DailyTournamentCountOrderByAggregateInput
    _max?: DailyTournamentMaxOrderByAggregateInput
    _min?: DailyTournamentMinOrderByAggregateInput
  }

  export type DailyTournamentScalarWhereWithAggregatesInput = {
    AND?: DailyTournamentScalarWhereWithAggregatesInput | DailyTournamentScalarWhereWithAggregatesInput[]
    OR?: DailyTournamentScalarWhereWithAggregatesInput[]
    NOT?: DailyTournamentScalarWhereWithAggregatesInput | DailyTournamentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyTournament"> | string
    date?: DateTimeWithAggregatesFilter<"DailyTournament"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"DailyTournament"> | Date | string
    status?: EnumTournamentStatusWithAggregatesFilter<"DailyTournament"> | $Enums.TournamentStatus
    configVersion?: StringNullableWithAggregatesFilter<"DailyTournament"> | string | null
    final?: JsonWithAggregatesFilter<"DailyTournament">
  }

  export type DailyTournamentSessionWhereInput = {
    AND?: DailyTournamentSessionWhereInput | DailyTournamentSessionWhereInput[]
    OR?: DailyTournamentSessionWhereInput[]
    NOT?: DailyTournamentSessionWhereInput | DailyTournamentSessionWhereInput[]
    id?: StringFilter<"DailyTournamentSession"> | string
    createdAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    updatedAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    userId?: StringFilter<"DailyTournamentSession"> | string
    tournamentId?: StringFilter<"DailyTournamentSession"> | string
    sessionSeed?: StringFilter<"DailyTournamentSession"> | string
    startedAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"DailyTournamentSession"> | Date | string | null
    status?: EnumUserTournamentStatusFilter<"DailyTournamentSession"> | $Enums.UserTournamentStatus
    currentScore?: IntFilter<"DailyTournamentSession"> | number
    finalScore?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute1Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute2Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute3Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute4Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    isFreeAttempt?: BoolFilter<"DailyTournamentSession"> | boolean
    isRewardedAttempt?: BoolFilter<"DailyTournamentSession"> | boolean
    currentLevel?: IntFilter<"DailyTournamentSession"> | number
    questionsAnswered?: IntFilter<"DailyTournamentSession"> | number
    correctAnswers?: IntFilter<"DailyTournamentSession"> | number
    endsAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tournament?: XOR<DailyTournamentScalarRelationFilter, DailyTournamentWhereInput>
    questions?: QuestionAttemptListRelationFilter
  }

  export type DailyTournamentSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    currentScore?: SortOrder
    finalScore?: SortOrderInput | SortOrder
    minute1Score?: SortOrderInput | SortOrder
    minute2Score?: SortOrderInput | SortOrder
    minute3Score?: SortOrderInput | SortOrder
    minute4Score?: SortOrderInput | SortOrder
    isFreeAttempt?: SortOrder
    isRewardedAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    endsAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tournament?: DailyTournamentOrderByWithRelationInput
    questions?: QuestionAttemptOrderByRelationAggregateInput
  }

  export type DailyTournamentSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyTournamentSessionWhereInput | DailyTournamentSessionWhereInput[]
    OR?: DailyTournamentSessionWhereInput[]
    NOT?: DailyTournamentSessionWhereInput | DailyTournamentSessionWhereInput[]
    createdAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    updatedAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    userId?: StringFilter<"DailyTournamentSession"> | string
    tournamentId?: StringFilter<"DailyTournamentSession"> | string
    sessionSeed?: StringFilter<"DailyTournamentSession"> | string
    startedAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"DailyTournamentSession"> | Date | string | null
    status?: EnumUserTournamentStatusFilter<"DailyTournamentSession"> | $Enums.UserTournamentStatus
    currentScore?: IntFilter<"DailyTournamentSession"> | number
    finalScore?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute1Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute2Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute3Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute4Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    isFreeAttempt?: BoolFilter<"DailyTournamentSession"> | boolean
    isRewardedAttempt?: BoolFilter<"DailyTournamentSession"> | boolean
    currentLevel?: IntFilter<"DailyTournamentSession"> | number
    questionsAnswered?: IntFilter<"DailyTournamentSession"> | number
    correctAnswers?: IntFilter<"DailyTournamentSession"> | number
    endsAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tournament?: XOR<DailyTournamentScalarRelationFilter, DailyTournamentWhereInput>
    questions?: QuestionAttemptListRelationFilter
  }, "id">

  export type DailyTournamentSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    currentScore?: SortOrder
    finalScore?: SortOrderInput | SortOrder
    minute1Score?: SortOrderInput | SortOrder
    minute2Score?: SortOrderInput | SortOrder
    minute3Score?: SortOrderInput | SortOrder
    minute4Score?: SortOrderInput | SortOrder
    isFreeAttempt?: SortOrder
    isRewardedAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    endsAt?: SortOrder
    _count?: DailyTournamentSessionCountOrderByAggregateInput
    _avg?: DailyTournamentSessionAvgOrderByAggregateInput
    _max?: DailyTournamentSessionMaxOrderByAggregateInput
    _min?: DailyTournamentSessionMinOrderByAggregateInput
    _sum?: DailyTournamentSessionSumOrderByAggregateInput
  }

  export type DailyTournamentSessionScalarWhereWithAggregatesInput = {
    AND?: DailyTournamentSessionScalarWhereWithAggregatesInput | DailyTournamentSessionScalarWhereWithAggregatesInput[]
    OR?: DailyTournamentSessionScalarWhereWithAggregatesInput[]
    NOT?: DailyTournamentSessionScalarWhereWithAggregatesInput | DailyTournamentSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyTournamentSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DailyTournamentSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyTournamentSession"> | Date | string
    userId?: StringWithAggregatesFilter<"DailyTournamentSession"> | string
    tournamentId?: StringWithAggregatesFilter<"DailyTournamentSession"> | string
    sessionSeed?: StringWithAggregatesFilter<"DailyTournamentSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"DailyTournamentSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"DailyTournamentSession"> | Date | string | null
    status?: EnumUserTournamentStatusWithAggregatesFilter<"DailyTournamentSession"> | $Enums.UserTournamentStatus
    currentScore?: IntWithAggregatesFilter<"DailyTournamentSession"> | number
    finalScore?: IntNullableWithAggregatesFilter<"DailyTournamentSession"> | number | null
    minute1Score?: IntNullableWithAggregatesFilter<"DailyTournamentSession"> | number | null
    minute2Score?: IntNullableWithAggregatesFilter<"DailyTournamentSession"> | number | null
    minute3Score?: IntNullableWithAggregatesFilter<"DailyTournamentSession"> | number | null
    minute4Score?: IntNullableWithAggregatesFilter<"DailyTournamentSession"> | number | null
    isFreeAttempt?: BoolWithAggregatesFilter<"DailyTournamentSession"> | boolean
    isRewardedAttempt?: BoolWithAggregatesFilter<"DailyTournamentSession"> | boolean
    currentLevel?: IntWithAggregatesFilter<"DailyTournamentSession"> | number
    questionsAnswered?: IntWithAggregatesFilter<"DailyTournamentSession"> | number
    correctAnswers?: IntWithAggregatesFilter<"DailyTournamentSession"> | number
    endsAt?: DateTimeWithAggregatesFilter<"DailyTournamentSession"> | Date | string
  }

  export type MinuteSnapshotWhereInput = {
    AND?: MinuteSnapshotWhereInput | MinuteSnapshotWhereInput[]
    OR?: MinuteSnapshotWhereInput[]
    NOT?: MinuteSnapshotWhereInput | MinuteSnapshotWhereInput[]
    id?: StringFilter<"MinuteSnapshot"> | string
    tournamentId?: StringFilter<"MinuteSnapshot"> | string
    minuteNumber?: IntFilter<"MinuteSnapshot"> | number
    snapshot?: JsonFilter<"MinuteSnapshot">
    createdAt?: DateTimeFilter<"MinuteSnapshot"> | Date | string
    tournament?: XOR<DailyTournamentScalarRelationFilter, DailyTournamentWhereInput>
  }

  export type MinuteSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    minuteNumber?: SortOrder
    snapshot?: SortOrder
    createdAt?: SortOrder
    tournament?: DailyTournamentOrderByWithRelationInput
  }

  export type MinuteSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MinuteSnapshotWhereInput | MinuteSnapshotWhereInput[]
    OR?: MinuteSnapshotWhereInput[]
    NOT?: MinuteSnapshotWhereInput | MinuteSnapshotWhereInput[]
    tournamentId?: StringFilter<"MinuteSnapshot"> | string
    minuteNumber?: IntFilter<"MinuteSnapshot"> | number
    snapshot?: JsonFilter<"MinuteSnapshot">
    createdAt?: DateTimeFilter<"MinuteSnapshot"> | Date | string
    tournament?: XOR<DailyTournamentScalarRelationFilter, DailyTournamentWhereInput>
  }, "id">

  export type MinuteSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    minuteNumber?: SortOrder
    snapshot?: SortOrder
    createdAt?: SortOrder
    _count?: MinuteSnapshotCountOrderByAggregateInput
    _avg?: MinuteSnapshotAvgOrderByAggregateInput
    _max?: MinuteSnapshotMaxOrderByAggregateInput
    _min?: MinuteSnapshotMinOrderByAggregateInput
    _sum?: MinuteSnapshotSumOrderByAggregateInput
  }

  export type MinuteSnapshotScalarWhereWithAggregatesInput = {
    AND?: MinuteSnapshotScalarWhereWithAggregatesInput | MinuteSnapshotScalarWhereWithAggregatesInput[]
    OR?: MinuteSnapshotScalarWhereWithAggregatesInput[]
    NOT?: MinuteSnapshotScalarWhereWithAggregatesInput | MinuteSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MinuteSnapshot"> | string
    tournamentId?: StringWithAggregatesFilter<"MinuteSnapshot"> | string
    minuteNumber?: IntWithAggregatesFilter<"MinuteSnapshot"> | number
    snapshot?: JsonWithAggregatesFilter<"MinuteSnapshot">
    createdAt?: DateTimeWithAggregatesFilter<"MinuteSnapshot"> | Date | string
  }

  export type SoloSessionWhereInput = {
    AND?: SoloSessionWhereInput | SoloSessionWhereInput[]
    OR?: SoloSessionWhereInput[]
    NOT?: SoloSessionWhereInput | SoloSessionWhereInput[]
    id?: StringFilter<"SoloSession"> | string
    createdAt?: DateTimeFilter<"SoloSession"> | Date | string
    updatedAt?: DateTimeFilter<"SoloSession"> | Date | string
    userId?: StringFilter<"SoloSession"> | string
    date?: DateTimeFilter<"SoloSession"> | Date | string
    sessionSeed?: StringFilter<"SoloSession"> | string
    startedAt?: DateTimeFilter<"SoloSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"SoloSession"> | Date | string | null
    status?: EnumUserTournamentStatusFilter<"SoloSession"> | $Enums.UserTournamentStatus
    currentRound?: IntFilter<"SoloSession"> | number
    bankedPoints?: FloatFilter<"SoloSession"> | number
    finalScore?: FloatNullableFilter<"SoloSession"> | number | null
    coinPointsEarned?: IntFilter<"SoloSession"> | number
    isFreeAttempt?: BoolFilter<"SoloSession"> | boolean
    currentLevel?: IntFilter<"SoloSession"> | number
    questionsAnswered?: IntFilter<"SoloSession"> | number
    correctAnswers?: IntFilter<"SoloSession"> | number
    madeMistake?: BoolFilter<"SoloSession"> | boolean
    quitEarly?: BoolFilter<"SoloSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    questions?: QuestionAttemptListRelationFilter
  }

  export type SoloSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    bankedPoints?: SortOrder
    finalScore?: SortOrderInput | SortOrder
    coinPointsEarned?: SortOrder
    isFreeAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    madeMistake?: SortOrder
    quitEarly?: SortOrder
    user?: UserOrderByWithRelationInput
    questions?: QuestionAttemptOrderByRelationAggregateInput
  }

  export type SoloSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SoloSessionWhereInput | SoloSessionWhereInput[]
    OR?: SoloSessionWhereInput[]
    NOT?: SoloSessionWhereInput | SoloSessionWhereInput[]
    createdAt?: DateTimeFilter<"SoloSession"> | Date | string
    updatedAt?: DateTimeFilter<"SoloSession"> | Date | string
    userId?: StringFilter<"SoloSession"> | string
    date?: DateTimeFilter<"SoloSession"> | Date | string
    sessionSeed?: StringFilter<"SoloSession"> | string
    startedAt?: DateTimeFilter<"SoloSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"SoloSession"> | Date | string | null
    status?: EnumUserTournamentStatusFilter<"SoloSession"> | $Enums.UserTournamentStatus
    currentRound?: IntFilter<"SoloSession"> | number
    bankedPoints?: FloatFilter<"SoloSession"> | number
    finalScore?: FloatNullableFilter<"SoloSession"> | number | null
    coinPointsEarned?: IntFilter<"SoloSession"> | number
    isFreeAttempt?: BoolFilter<"SoloSession"> | boolean
    currentLevel?: IntFilter<"SoloSession"> | number
    questionsAnswered?: IntFilter<"SoloSession"> | number
    correctAnswers?: IntFilter<"SoloSession"> | number
    madeMistake?: BoolFilter<"SoloSession"> | boolean
    quitEarly?: BoolFilter<"SoloSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    questions?: QuestionAttemptListRelationFilter
  }, "id">

  export type SoloSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    bankedPoints?: SortOrder
    finalScore?: SortOrderInput | SortOrder
    coinPointsEarned?: SortOrder
    isFreeAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    madeMistake?: SortOrder
    quitEarly?: SortOrder
    _count?: SoloSessionCountOrderByAggregateInput
    _avg?: SoloSessionAvgOrderByAggregateInput
    _max?: SoloSessionMaxOrderByAggregateInput
    _min?: SoloSessionMinOrderByAggregateInput
    _sum?: SoloSessionSumOrderByAggregateInput
  }

  export type SoloSessionScalarWhereWithAggregatesInput = {
    AND?: SoloSessionScalarWhereWithAggregatesInput | SoloSessionScalarWhereWithAggregatesInput[]
    OR?: SoloSessionScalarWhereWithAggregatesInput[]
    NOT?: SoloSessionScalarWhereWithAggregatesInput | SoloSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SoloSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SoloSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SoloSession"> | Date | string
    userId?: StringWithAggregatesFilter<"SoloSession"> | string
    date?: DateTimeWithAggregatesFilter<"SoloSession"> | Date | string
    sessionSeed?: StringWithAggregatesFilter<"SoloSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"SoloSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"SoloSession"> | Date | string | null
    status?: EnumUserTournamentStatusWithAggregatesFilter<"SoloSession"> | $Enums.UserTournamentStatus
    currentRound?: IntWithAggregatesFilter<"SoloSession"> | number
    bankedPoints?: FloatWithAggregatesFilter<"SoloSession"> | number
    finalScore?: FloatNullableWithAggregatesFilter<"SoloSession"> | number | null
    coinPointsEarned?: IntWithAggregatesFilter<"SoloSession"> | number
    isFreeAttempt?: BoolWithAggregatesFilter<"SoloSession"> | boolean
    currentLevel?: IntWithAggregatesFilter<"SoloSession"> | number
    questionsAnswered?: IntWithAggregatesFilter<"SoloSession"> | number
    correctAnswers?: IntWithAggregatesFilter<"SoloSession"> | number
    madeMistake?: BoolWithAggregatesFilter<"SoloSession"> | boolean
    quitEarly?: BoolWithAggregatesFilter<"SoloSession"> | boolean
  }

  export type QuestionAttemptWhereInput = {
    AND?: QuestionAttemptWhereInput | QuestionAttemptWhereInput[]
    OR?: QuestionAttemptWhereInput[]
    NOT?: QuestionAttemptWhereInput | QuestionAttemptWhereInput[]
    id?: StringFilter<"QuestionAttempt"> | string
    createdAt?: DateTimeFilter<"QuestionAttempt"> | Date | string
    questionIndex?: IntFilter<"QuestionAttempt"> | number
    level?: IntFilter<"QuestionAttempt"> | number
    expression?: StringFilter<"QuestionAttempt"> | string
    result?: StringFilter<"QuestionAttempt"> | string
    side?: StringFilter<"QuestionAttempt"> | string
    kthDigit?: IntFilter<"QuestionAttempt"> | number
    correctDigit?: IntFilter<"QuestionAttempt"> | number
    dailySessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
    soloSessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
    instantSessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
    dailySession?: XOR<DailyTournamentSessionNullableScalarRelationFilter, DailyTournamentSessionWhereInput> | null
    soloSession?: XOR<SoloSessionNullableScalarRelationFilter, SoloSessionWhereInput> | null
    instantSession?: XOR<InstantSessionNullableScalarRelationFilter, InstantSessionWhereInput> | null
  }

  export type QuestionAttemptOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    questionIndex?: SortOrder
    level?: SortOrder
    expression?: SortOrder
    result?: SortOrder
    side?: SortOrder
    kthDigit?: SortOrder
    correctDigit?: SortOrder
    dailySessionId?: SortOrderInput | SortOrder
    soloSessionId?: SortOrderInput | SortOrder
    instantSessionId?: SortOrderInput | SortOrder
    dailySession?: DailyTournamentSessionOrderByWithRelationInput
    soloSession?: SoloSessionOrderByWithRelationInput
    instantSession?: InstantSessionOrderByWithRelationInput
  }

  export type QuestionAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionAttemptWhereInput | QuestionAttemptWhereInput[]
    OR?: QuestionAttemptWhereInput[]
    NOT?: QuestionAttemptWhereInput | QuestionAttemptWhereInput[]
    createdAt?: DateTimeFilter<"QuestionAttempt"> | Date | string
    questionIndex?: IntFilter<"QuestionAttempt"> | number
    level?: IntFilter<"QuestionAttempt"> | number
    expression?: StringFilter<"QuestionAttempt"> | string
    result?: StringFilter<"QuestionAttempt"> | string
    side?: StringFilter<"QuestionAttempt"> | string
    kthDigit?: IntFilter<"QuestionAttempt"> | number
    correctDigit?: IntFilter<"QuestionAttempt"> | number
    dailySessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
    soloSessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
    instantSessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
    dailySession?: XOR<DailyTournamentSessionNullableScalarRelationFilter, DailyTournamentSessionWhereInput> | null
    soloSession?: XOR<SoloSessionNullableScalarRelationFilter, SoloSessionWhereInput> | null
    instantSession?: XOR<InstantSessionNullableScalarRelationFilter, InstantSessionWhereInput> | null
  }, "id">

  export type QuestionAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    questionIndex?: SortOrder
    level?: SortOrder
    expression?: SortOrder
    result?: SortOrder
    side?: SortOrder
    kthDigit?: SortOrder
    correctDigit?: SortOrder
    dailySessionId?: SortOrderInput | SortOrder
    soloSessionId?: SortOrderInput | SortOrder
    instantSessionId?: SortOrderInput | SortOrder
    _count?: QuestionAttemptCountOrderByAggregateInput
    _avg?: QuestionAttemptAvgOrderByAggregateInput
    _max?: QuestionAttemptMaxOrderByAggregateInput
    _min?: QuestionAttemptMinOrderByAggregateInput
    _sum?: QuestionAttemptSumOrderByAggregateInput
  }

  export type QuestionAttemptScalarWhereWithAggregatesInput = {
    AND?: QuestionAttemptScalarWhereWithAggregatesInput | QuestionAttemptScalarWhereWithAggregatesInput[]
    OR?: QuestionAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuestionAttemptScalarWhereWithAggregatesInput | QuestionAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionAttempt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuestionAttempt"> | Date | string
    questionIndex?: IntWithAggregatesFilter<"QuestionAttempt"> | number
    level?: IntWithAggregatesFilter<"QuestionAttempt"> | number
    expression?: StringWithAggregatesFilter<"QuestionAttempt"> | string
    result?: StringWithAggregatesFilter<"QuestionAttempt"> | string
    side?: StringWithAggregatesFilter<"QuestionAttempt"> | string
    kthDigit?: IntWithAggregatesFilter<"QuestionAttempt"> | number
    correctDigit?: IntWithAggregatesFilter<"QuestionAttempt"> | number
    dailySessionId?: StringNullableWithAggregatesFilter<"QuestionAttempt"> | string | null
    soloSessionId?: StringNullableWithAggregatesFilter<"QuestionAttempt"> | string | null
    instantSessionId?: StringNullableWithAggregatesFilter<"QuestionAttempt"> | string | null
  }

  export type InstantTournamentWhereInput = {
    AND?: InstantTournamentWhereInput | InstantTournamentWhereInput[]
    OR?: InstantTournamentWhereInput[]
    NOT?: InstantTournamentWhereInput | InstantTournamentWhereInput[]
    id?: StringFilter<"InstantTournament"> | string
    status?: EnumTournamentStatusFilter<"InstantTournament"> | $Enums.TournamentStatus
    maxPlayers?: IntFilter<"InstantTournament"> | number
    playersCount?: IntFilter<"InstantTournament"> | number
    createdAt?: DateTimeFilter<"InstantTournament"> | Date | string
    updatedAt?: DateTimeFilter<"InstantTournament"> | Date | string
    expiresAt?: DateTimeFilter<"InstantTournament"> | Date | string
    sessions?: InstantSessionListRelationFilter
    instantParticipant?: InstantParticipantListRelationFilter
  }

  export type InstantTournamentOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    maxPlayers?: SortOrder
    playersCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    sessions?: InstantSessionOrderByRelationAggregateInput
    instantParticipant?: InstantParticipantOrderByRelationAggregateInput
  }

  export type InstantTournamentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstantTournamentWhereInput | InstantTournamentWhereInput[]
    OR?: InstantTournamentWhereInput[]
    NOT?: InstantTournamentWhereInput | InstantTournamentWhereInput[]
    status?: EnumTournamentStatusFilter<"InstantTournament"> | $Enums.TournamentStatus
    maxPlayers?: IntFilter<"InstantTournament"> | number
    playersCount?: IntFilter<"InstantTournament"> | number
    createdAt?: DateTimeFilter<"InstantTournament"> | Date | string
    updatedAt?: DateTimeFilter<"InstantTournament"> | Date | string
    expiresAt?: DateTimeFilter<"InstantTournament"> | Date | string
    sessions?: InstantSessionListRelationFilter
    instantParticipant?: InstantParticipantListRelationFilter
  }, "id">

  export type InstantTournamentOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    maxPlayers?: SortOrder
    playersCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    _count?: InstantTournamentCountOrderByAggregateInput
    _avg?: InstantTournamentAvgOrderByAggregateInput
    _max?: InstantTournamentMaxOrderByAggregateInput
    _min?: InstantTournamentMinOrderByAggregateInput
    _sum?: InstantTournamentSumOrderByAggregateInput
  }

  export type InstantTournamentScalarWhereWithAggregatesInput = {
    AND?: InstantTournamentScalarWhereWithAggregatesInput | InstantTournamentScalarWhereWithAggregatesInput[]
    OR?: InstantTournamentScalarWhereWithAggregatesInput[]
    NOT?: InstantTournamentScalarWhereWithAggregatesInput | InstantTournamentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstantTournament"> | string
    status?: EnumTournamentStatusWithAggregatesFilter<"InstantTournament"> | $Enums.TournamentStatus
    maxPlayers?: IntWithAggregatesFilter<"InstantTournament"> | number
    playersCount?: IntWithAggregatesFilter<"InstantTournament"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InstantTournament"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InstantTournament"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"InstantTournament"> | Date | string
  }

  export type InstantSessionWhereInput = {
    AND?: InstantSessionWhereInput | InstantSessionWhereInput[]
    OR?: InstantSessionWhereInput[]
    NOT?: InstantSessionWhereInput | InstantSessionWhereInput[]
    id?: StringFilter<"InstantSession"> | string
    userId?: StringFilter<"InstantSession"> | string
    status?: EnumInstantTournamentSessionStatusFilter<"InstantSession"> | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringFilter<"InstantSession"> | string
    score?: IntFilter<"InstantSession"> | number
    finalScore?: IntNullableFilter<"InstantSession"> | number | null
    bestScore?: IntFilter<"InstantSession"> | number
    startedAt?: DateTimeFilter<"InstantSession"> | Date | string
    endsAt?: DateTimeNullableFilter<"InstantSession"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"InstantSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tournament?: XOR<InstantTournamentScalarRelationFilter, InstantTournamentWhereInput>
    questions?: QuestionAttemptListRelationFilter
  }

  export type InstantSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    tournamentId?: SortOrder
    score?: SortOrder
    finalScore?: SortOrderInput | SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    endsAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    tournament?: InstantTournamentOrderByWithRelationInput
    questions?: QuestionAttemptOrderByRelationAggregateInput
  }

  export type InstantSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstantSessionWhereInput | InstantSessionWhereInput[]
    OR?: InstantSessionWhereInput[]
    NOT?: InstantSessionWhereInput | InstantSessionWhereInput[]
    userId?: StringFilter<"InstantSession"> | string
    status?: EnumInstantTournamentSessionStatusFilter<"InstantSession"> | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringFilter<"InstantSession"> | string
    score?: IntFilter<"InstantSession"> | number
    finalScore?: IntNullableFilter<"InstantSession"> | number | null
    bestScore?: IntFilter<"InstantSession"> | number
    startedAt?: DateTimeFilter<"InstantSession"> | Date | string
    endsAt?: DateTimeNullableFilter<"InstantSession"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"InstantSession"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tournament?: XOR<InstantTournamentScalarRelationFilter, InstantTournamentWhereInput>
    questions?: QuestionAttemptListRelationFilter
  }, "id">

  export type InstantSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    tournamentId?: SortOrder
    score?: SortOrder
    finalScore?: SortOrderInput | SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    endsAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    _count?: InstantSessionCountOrderByAggregateInput
    _avg?: InstantSessionAvgOrderByAggregateInput
    _max?: InstantSessionMaxOrderByAggregateInput
    _min?: InstantSessionMinOrderByAggregateInput
    _sum?: InstantSessionSumOrderByAggregateInput
  }

  export type InstantSessionScalarWhereWithAggregatesInput = {
    AND?: InstantSessionScalarWhereWithAggregatesInput | InstantSessionScalarWhereWithAggregatesInput[]
    OR?: InstantSessionScalarWhereWithAggregatesInput[]
    NOT?: InstantSessionScalarWhereWithAggregatesInput | InstantSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstantSession"> | string
    userId?: StringWithAggregatesFilter<"InstantSession"> | string
    status?: EnumInstantTournamentSessionStatusWithAggregatesFilter<"InstantSession"> | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringWithAggregatesFilter<"InstantSession"> | string
    score?: IntWithAggregatesFilter<"InstantSession"> | number
    finalScore?: IntNullableWithAggregatesFilter<"InstantSession"> | number | null
    bestScore?: IntWithAggregatesFilter<"InstantSession"> | number
    startedAt?: DateTimeWithAggregatesFilter<"InstantSession"> | Date | string
    endsAt?: DateTimeNullableWithAggregatesFilter<"InstantSession"> | Date | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"InstantSession"> | Date | string | null
  }

  export type InstantParticipantWhereInput = {
    AND?: InstantParticipantWhereInput | InstantParticipantWhereInput[]
    OR?: InstantParticipantWhereInput[]
    NOT?: InstantParticipantWhereInput | InstantParticipantWhereInput[]
    tournamentId?: StringFilter<"InstantParticipant"> | string
    userId?: StringFilter<"InstantParticipant"> | string
    joinedAt?: DateTimeFilter<"InstantParticipant"> | Date | string
    joinOrder?: IntFilter<"InstantParticipant"> | number
    sessionStarted?: BoolFilter<"InstantParticipant"> | boolean
    finalScore?: IntNullableFilter<"InstantParticipant"> | number | null
    submittedAt?: DateTimeNullableFilter<"InstantParticipant"> | Date | string | null
    finalRank?: IntNullableFilter<"InstantParticipant"> | number | null
    tournament?: XOR<InstantTournamentScalarRelationFilter, InstantTournamentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InstantParticipantOrderByWithRelationInput = {
    tournamentId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    joinOrder?: SortOrder
    sessionStarted?: SortOrder
    finalScore?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    finalRank?: SortOrderInput | SortOrder
    tournament?: InstantTournamentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InstantParticipantWhereUniqueInput = Prisma.AtLeast<{
    tournamentId_userId?: InstantParticipantTournamentIdUserIdCompoundUniqueInput
    AND?: InstantParticipantWhereInput | InstantParticipantWhereInput[]
    OR?: InstantParticipantWhereInput[]
    NOT?: InstantParticipantWhereInput | InstantParticipantWhereInput[]
    tournamentId?: StringFilter<"InstantParticipant"> | string
    userId?: StringFilter<"InstantParticipant"> | string
    joinedAt?: DateTimeFilter<"InstantParticipant"> | Date | string
    joinOrder?: IntFilter<"InstantParticipant"> | number
    sessionStarted?: BoolFilter<"InstantParticipant"> | boolean
    finalScore?: IntNullableFilter<"InstantParticipant"> | number | null
    submittedAt?: DateTimeNullableFilter<"InstantParticipant"> | Date | string | null
    finalRank?: IntNullableFilter<"InstantParticipant"> | number | null
    tournament?: XOR<InstantTournamentScalarRelationFilter, InstantTournamentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "tournamentId_userId" | "tournamentId_userId">

  export type InstantParticipantOrderByWithAggregationInput = {
    tournamentId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    joinOrder?: SortOrder
    sessionStarted?: SortOrder
    finalScore?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    finalRank?: SortOrderInput | SortOrder
    _count?: InstantParticipantCountOrderByAggregateInput
    _avg?: InstantParticipantAvgOrderByAggregateInput
    _max?: InstantParticipantMaxOrderByAggregateInput
    _min?: InstantParticipantMinOrderByAggregateInput
    _sum?: InstantParticipantSumOrderByAggregateInput
  }

  export type InstantParticipantScalarWhereWithAggregatesInput = {
    AND?: InstantParticipantScalarWhereWithAggregatesInput | InstantParticipantScalarWhereWithAggregatesInput[]
    OR?: InstantParticipantScalarWhereWithAggregatesInput[]
    NOT?: InstantParticipantScalarWhereWithAggregatesInput | InstantParticipantScalarWhereWithAggregatesInput[]
    tournamentId?: StringWithAggregatesFilter<"InstantParticipant"> | string
    userId?: StringWithAggregatesFilter<"InstantParticipant"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"InstantParticipant"> | Date | string
    joinOrder?: IntWithAggregatesFilter<"InstantParticipant"> | number
    sessionStarted?: BoolWithAggregatesFilter<"InstantParticipant"> | boolean
    finalScore?: IntNullableWithAggregatesFilter<"InstantParticipant"> | number | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"InstantParticipant"> | Date | string | null
    finalRank?: IntNullableWithAggregatesFilter<"InstantParticipant"> | number | null
  }

  export type DailyLeaderboardWhereInput = {
    AND?: DailyLeaderboardWhereInput | DailyLeaderboardWhereInput[]
    OR?: DailyLeaderboardWhereInput[]
    NOT?: DailyLeaderboardWhereInput | DailyLeaderboardWhereInput[]
    id?: StringFilter<"DailyLeaderboard"> | string
    date?: DateTimeFilter<"DailyLeaderboard"> | Date | string
    userId?: StringFilter<"DailyLeaderboard"> | string
    bestScore?: IntFilter<"DailyLeaderboard"> | number
    rank?: IntFilter<"DailyLeaderboard"> | number
    coinPoints?: IntFilter<"DailyLeaderboard"> | number
    updatedAt?: DateTimeFilter<"DailyLeaderboard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyLeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyLeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date_userId?: DailyLeaderboardDateUserIdCompoundUniqueInput
    AND?: DailyLeaderboardWhereInput | DailyLeaderboardWhereInput[]
    OR?: DailyLeaderboardWhereInput[]
    NOT?: DailyLeaderboardWhereInput | DailyLeaderboardWhereInput[]
    date?: DateTimeFilter<"DailyLeaderboard"> | Date | string
    userId?: StringFilter<"DailyLeaderboard"> | string
    bestScore?: IntFilter<"DailyLeaderboard"> | number
    rank?: IntFilter<"DailyLeaderboard"> | number
    coinPoints?: IntFilter<"DailyLeaderboard"> | number
    updatedAt?: DateTimeFilter<"DailyLeaderboard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "date_userId">

  export type DailyLeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyLeaderboardCountOrderByAggregateInput
    _avg?: DailyLeaderboardAvgOrderByAggregateInput
    _max?: DailyLeaderboardMaxOrderByAggregateInput
    _min?: DailyLeaderboardMinOrderByAggregateInput
    _sum?: DailyLeaderboardSumOrderByAggregateInput
  }

  export type DailyLeaderboardScalarWhereWithAggregatesInput = {
    AND?: DailyLeaderboardScalarWhereWithAggregatesInput | DailyLeaderboardScalarWhereWithAggregatesInput[]
    OR?: DailyLeaderboardScalarWhereWithAggregatesInput[]
    NOT?: DailyLeaderboardScalarWhereWithAggregatesInput | DailyLeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyLeaderboard"> | string
    date?: DateTimeWithAggregatesFilter<"DailyLeaderboard"> | Date | string
    userId?: StringWithAggregatesFilter<"DailyLeaderboard"> | string
    bestScore?: IntWithAggregatesFilter<"DailyLeaderboard"> | number
    rank?: IntWithAggregatesFilter<"DailyLeaderboard"> | number
    coinPoints?: IntWithAggregatesFilter<"DailyLeaderboard"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"DailyLeaderboard"> | Date | string
  }

  export type InstantLeaderboardWhereInput = {
    AND?: InstantLeaderboardWhereInput | InstantLeaderboardWhereInput[]
    OR?: InstantLeaderboardWhereInput[]
    NOT?: InstantLeaderboardWhereInput | InstantLeaderboardWhereInput[]
    id?: StringFilter<"InstantLeaderboard"> | string
    tournamentId?: StringFilter<"InstantLeaderboard"> | string
    userId?: StringFilter<"InstantLeaderboard"> | string
    bestScore?: IntFilter<"InstantLeaderboard"> | number
    rank?: IntFilter<"InstantLeaderboard"> | number
    coinPoints?: DecimalFilter<"InstantLeaderboard"> | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFilter<"InstantLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"InstantLeaderboard"> | Date | string
    date?: DateTimeFilter<"InstantLeaderboard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InstantLeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InstantLeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tournamentId_userId?: InstantLeaderboardTournamentIdUserIdCompoundUniqueInput
    AND?: InstantLeaderboardWhereInput | InstantLeaderboardWhereInput[]
    OR?: InstantLeaderboardWhereInput[]
    NOT?: InstantLeaderboardWhereInput | InstantLeaderboardWhereInput[]
    tournamentId?: StringFilter<"InstantLeaderboard"> | string
    userId?: StringFilter<"InstantLeaderboard"> | string
    bestScore?: IntFilter<"InstantLeaderboard"> | number
    rank?: IntFilter<"InstantLeaderboard"> | number
    coinPoints?: DecimalFilter<"InstantLeaderboard"> | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFilter<"InstantLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"InstantLeaderboard"> | Date | string
    date?: DateTimeFilter<"InstantLeaderboard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tournamentId_userId">

  export type InstantLeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
    _count?: InstantLeaderboardCountOrderByAggregateInput
    _avg?: InstantLeaderboardAvgOrderByAggregateInput
    _max?: InstantLeaderboardMaxOrderByAggregateInput
    _min?: InstantLeaderboardMinOrderByAggregateInput
    _sum?: InstantLeaderboardSumOrderByAggregateInput
  }

  export type InstantLeaderboardScalarWhereWithAggregatesInput = {
    AND?: InstantLeaderboardScalarWhereWithAggregatesInput | InstantLeaderboardScalarWhereWithAggregatesInput[]
    OR?: InstantLeaderboardScalarWhereWithAggregatesInput[]
    NOT?: InstantLeaderboardScalarWhereWithAggregatesInput | InstantLeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InstantLeaderboard"> | string
    tournamentId?: StringWithAggregatesFilter<"InstantLeaderboard"> | string
    userId?: StringWithAggregatesFilter<"InstantLeaderboard"> | string
    bestScore?: IntWithAggregatesFilter<"InstantLeaderboard"> | number
    rank?: IntWithAggregatesFilter<"InstantLeaderboard"> | number
    coinPoints?: DecimalWithAggregatesFilter<"InstantLeaderboard"> | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeWithAggregatesFilter<"InstantLeaderboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InstantLeaderboard"> | Date | string
    date?: DateTimeWithAggregatesFilter<"InstantLeaderboard"> | Date | string
  }

  export type DailyUserLeaderboardWhereInput = {
    AND?: DailyUserLeaderboardWhereInput | DailyUserLeaderboardWhereInput[]
    OR?: DailyUserLeaderboardWhereInput[]
    NOT?: DailyUserLeaderboardWhereInput | DailyUserLeaderboardWhereInput[]
    id?: StringFilter<"DailyUserLeaderboard"> | string
    userId?: StringFilter<"DailyUserLeaderboard"> | string
    date?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
    dailyCoinPoints?: IntFilter<"DailyUserLeaderboard"> | number
    instantCoinPoints?: DecimalFilter<"DailyUserLeaderboard"> | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFilter<"DailyUserLeaderboard"> | Decimal | DecimalJsLike | number | string
    rank?: IntFilter<"DailyUserLeaderboard"> | number
    isEligible?: BoolFilter<"DailyUserLeaderboard"> | boolean
    coinsAwarded?: FloatFilter<"DailyUserLeaderboard"> | number
    createdAt?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyUserLeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    dailyCoinPoints?: SortOrder
    instantCoinPoints?: SortOrder
    totalCoinPoints?: SortOrder
    rank?: SortOrder
    isEligible?: SortOrder
    coinsAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyUserLeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: DailyUserLeaderboardUserIdDateCompoundUniqueInput
    AND?: DailyUserLeaderboardWhereInput | DailyUserLeaderboardWhereInput[]
    OR?: DailyUserLeaderboardWhereInput[]
    NOT?: DailyUserLeaderboardWhereInput | DailyUserLeaderboardWhereInput[]
    userId?: StringFilter<"DailyUserLeaderboard"> | string
    date?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
    dailyCoinPoints?: IntFilter<"DailyUserLeaderboard"> | number
    instantCoinPoints?: DecimalFilter<"DailyUserLeaderboard"> | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFilter<"DailyUserLeaderboard"> | Decimal | DecimalJsLike | number | string
    rank?: IntFilter<"DailyUserLeaderboard"> | number
    isEligible?: BoolFilter<"DailyUserLeaderboard"> | boolean
    coinsAwarded?: FloatFilter<"DailyUserLeaderboard"> | number
    createdAt?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type DailyUserLeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    dailyCoinPoints?: SortOrder
    instantCoinPoints?: SortOrder
    totalCoinPoints?: SortOrder
    rank?: SortOrder
    isEligible?: SortOrder
    coinsAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyUserLeaderboardCountOrderByAggregateInput
    _avg?: DailyUserLeaderboardAvgOrderByAggregateInput
    _max?: DailyUserLeaderboardMaxOrderByAggregateInput
    _min?: DailyUserLeaderboardMinOrderByAggregateInput
    _sum?: DailyUserLeaderboardSumOrderByAggregateInput
  }

  export type DailyUserLeaderboardScalarWhereWithAggregatesInput = {
    AND?: DailyUserLeaderboardScalarWhereWithAggregatesInput | DailyUserLeaderboardScalarWhereWithAggregatesInput[]
    OR?: DailyUserLeaderboardScalarWhereWithAggregatesInput[]
    NOT?: DailyUserLeaderboardScalarWhereWithAggregatesInput | DailyUserLeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyUserLeaderboard"> | string
    userId?: StringWithAggregatesFilter<"DailyUserLeaderboard"> | string
    date?: DateTimeWithAggregatesFilter<"DailyUserLeaderboard"> | Date | string
    dailyCoinPoints?: IntWithAggregatesFilter<"DailyUserLeaderboard"> | number
    instantCoinPoints?: DecimalWithAggregatesFilter<"DailyUserLeaderboard"> | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalWithAggregatesFilter<"DailyUserLeaderboard"> | Decimal | DecimalJsLike | number | string
    rank?: IntWithAggregatesFilter<"DailyUserLeaderboard"> | number
    isEligible?: BoolWithAggregatesFilter<"DailyUserLeaderboard"> | boolean
    coinsAwarded?: FloatWithAggregatesFilter<"DailyUserLeaderboard"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DailyUserLeaderboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyUserLeaderboard"> | Date | string
  }

  export type SoloLeaderboardWhereInput = {
    AND?: SoloLeaderboardWhereInput | SoloLeaderboardWhereInput[]
    OR?: SoloLeaderboardWhereInput[]
    NOT?: SoloLeaderboardWhereInput | SoloLeaderboardWhereInput[]
    id?: StringFilter<"SoloLeaderboard"> | string
    date?: DateTimeFilter<"SoloLeaderboard"> | Date | string
    userId?: StringFilter<"SoloLeaderboard"> | string
    score?: FloatFilter<"SoloLeaderboard"> | number
    rank?: IntFilter<"SoloLeaderboard"> | number
    percentile?: FloatFilter<"SoloLeaderboard"> | number
    coinPoints?: FloatFilter<"SoloLeaderboard"> | number
    createdAt?: DateTimeFilter<"SoloLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"SoloLeaderboard"> | Date | string
  }

  export type SoloLeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    percentile?: SortOrder
    coinPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SoloLeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: SoloLeaderboardUserIdDateCompoundUniqueInput
    AND?: SoloLeaderboardWhereInput | SoloLeaderboardWhereInput[]
    OR?: SoloLeaderboardWhereInput[]
    NOT?: SoloLeaderboardWhereInput | SoloLeaderboardWhereInput[]
    date?: DateTimeFilter<"SoloLeaderboard"> | Date | string
    userId?: StringFilter<"SoloLeaderboard"> | string
    score?: FloatFilter<"SoloLeaderboard"> | number
    rank?: IntFilter<"SoloLeaderboard"> | number
    percentile?: FloatFilter<"SoloLeaderboard"> | number
    coinPoints?: FloatFilter<"SoloLeaderboard"> | number
    createdAt?: DateTimeFilter<"SoloLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"SoloLeaderboard"> | Date | string
  }, "id" | "userId_date">

  export type SoloLeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    percentile?: SortOrder
    coinPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SoloLeaderboardCountOrderByAggregateInput
    _avg?: SoloLeaderboardAvgOrderByAggregateInput
    _max?: SoloLeaderboardMaxOrderByAggregateInput
    _min?: SoloLeaderboardMinOrderByAggregateInput
    _sum?: SoloLeaderboardSumOrderByAggregateInput
  }

  export type SoloLeaderboardScalarWhereWithAggregatesInput = {
    AND?: SoloLeaderboardScalarWhereWithAggregatesInput | SoloLeaderboardScalarWhereWithAggregatesInput[]
    OR?: SoloLeaderboardScalarWhereWithAggregatesInput[]
    NOT?: SoloLeaderboardScalarWhereWithAggregatesInput | SoloLeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SoloLeaderboard"> | string
    date?: DateTimeWithAggregatesFilter<"SoloLeaderboard"> | Date | string
    userId?: StringWithAggregatesFilter<"SoloLeaderboard"> | string
    score?: FloatWithAggregatesFilter<"SoloLeaderboard"> | number
    rank?: IntWithAggregatesFilter<"SoloLeaderboard"> | number
    percentile?: FloatWithAggregatesFilter<"SoloLeaderboard"> | number
    coinPoints?: FloatWithAggregatesFilter<"SoloLeaderboard"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SoloLeaderboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SoloLeaderboard"> | Date | string
  }

  export type RewardClaimWhereInput = {
    AND?: RewardClaimWhereInput | RewardClaimWhereInput[]
    OR?: RewardClaimWhereInput[]
    NOT?: RewardClaimWhereInput | RewardClaimWhereInput[]
    id?: StringFilter<"RewardClaim"> | string
    userId?: StringFilter<"RewardClaim"> | string
    coinsLocked?: IntFilter<"RewardClaim"> | number
    status?: EnumClaimStatusFilter<"RewardClaim"> | $Enums.ClaimStatus
    voucherCode?: StringNullableFilter<"RewardClaim"> | string | null
    adminNotes?: StringNullableFilter<"RewardClaim"> | string | null
    fulfilledBy?: StringNullableFilter<"RewardClaim"> | string | null
    fulfilledAt?: DateTimeNullableFilter<"RewardClaim"> | Date | string | null
    rejectionReason?: StringNullableFilter<"RewardClaim"> | string | null
    createdAt?: DateTimeFilter<"RewardClaim"> | Date | string
    updatedAt?: DateTimeFilter<"RewardClaim"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RewardClaimOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinsLocked?: SortOrder
    status?: SortOrder
    voucherCode?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    fulfilledBy?: SortOrderInput | SortOrder
    fulfilledAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RewardClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardClaimWhereInput | RewardClaimWhereInput[]
    OR?: RewardClaimWhereInput[]
    NOT?: RewardClaimWhereInput | RewardClaimWhereInput[]
    userId?: StringFilter<"RewardClaim"> | string
    coinsLocked?: IntFilter<"RewardClaim"> | number
    status?: EnumClaimStatusFilter<"RewardClaim"> | $Enums.ClaimStatus
    voucherCode?: StringNullableFilter<"RewardClaim"> | string | null
    adminNotes?: StringNullableFilter<"RewardClaim"> | string | null
    fulfilledBy?: StringNullableFilter<"RewardClaim"> | string | null
    fulfilledAt?: DateTimeNullableFilter<"RewardClaim"> | Date | string | null
    rejectionReason?: StringNullableFilter<"RewardClaim"> | string | null
    createdAt?: DateTimeFilter<"RewardClaim"> | Date | string
    updatedAt?: DateTimeFilter<"RewardClaim"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RewardClaimOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinsLocked?: SortOrder
    status?: SortOrder
    voucherCode?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    fulfilledBy?: SortOrderInput | SortOrder
    fulfilledAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RewardClaimCountOrderByAggregateInput
    _avg?: RewardClaimAvgOrderByAggregateInput
    _max?: RewardClaimMaxOrderByAggregateInput
    _min?: RewardClaimMinOrderByAggregateInput
    _sum?: RewardClaimSumOrderByAggregateInput
  }

  export type RewardClaimScalarWhereWithAggregatesInput = {
    AND?: RewardClaimScalarWhereWithAggregatesInput | RewardClaimScalarWhereWithAggregatesInput[]
    OR?: RewardClaimScalarWhereWithAggregatesInput[]
    NOT?: RewardClaimScalarWhereWithAggregatesInput | RewardClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RewardClaim"> | string
    userId?: StringWithAggregatesFilter<"RewardClaim"> | string
    coinsLocked?: IntWithAggregatesFilter<"RewardClaim"> | number
    status?: EnumClaimStatusWithAggregatesFilter<"RewardClaim"> | $Enums.ClaimStatus
    voucherCode?: StringNullableWithAggregatesFilter<"RewardClaim"> | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"RewardClaim"> | string | null
    fulfilledBy?: StringNullableWithAggregatesFilter<"RewardClaim"> | string | null
    fulfilledAt?: DateTimeNullableWithAggregatesFilter<"RewardClaim"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"RewardClaim"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RewardClaim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RewardClaim"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringNullableFilter<"Referral"> | string | null
    referralCode?: StringFilter<"Referral"> | string
    status?: EnumReferralStatusFilter<"Referral"> | $Enums.ReferralStatus
    referrerCoins?: IntFilter<"Referral"> | number
    refereeCoins?: IntFilter<"Referral"> | number
    rewardedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrderInput | SortOrder
    referralCode?: SortOrder
    status?: SortOrder
    referrerCoins?: SortOrder
    refereeCoins?: SortOrder
    rewardedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referee?: UserOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referralCode?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringNullableFilter<"Referral"> | string | null
    status?: EnumReferralStatusFilter<"Referral"> | $Enums.ReferralStatus
    referrerCoins?: IntFilter<"Referral"> | number
    refereeCoins?: IntFilter<"Referral"> | number
    rewardedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "referralCode">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrderInput | SortOrder
    referralCode?: SortOrder
    status?: SortOrder
    referrerCoins?: SortOrder
    refereeCoins?: SortOrder
    rewardedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrerId?: StringWithAggregatesFilter<"Referral"> | string
    refereeId?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    referralCode?: StringWithAggregatesFilter<"Referral"> | string
    status?: EnumReferralStatusWithAggregatesFilter<"Referral"> | $Enums.ReferralStatus
    referrerCoins?: IntWithAggregatesFilter<"Referral"> | number
    refereeCoins?: IntWithAggregatesFilter<"Referral"> | number
    rewardedAt?: DateTimeNullableWithAggregatesFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type CoinLedgerWhereInput = {
    AND?: CoinLedgerWhereInput | CoinLedgerWhereInput[]
    OR?: CoinLedgerWhereInput[]
    NOT?: CoinLedgerWhereInput | CoinLedgerWhereInput[]
    id?: StringFilter<"CoinLedger"> | string
    userId?: StringFilter<"CoinLedger"> | string
    date?: DateTimeFilter<"CoinLedger"> | Date | string
    delta?: IntFilter<"CoinLedger"> | number
    source?: EnumCoinLedgerSourceFilter<"CoinLedger"> | $Enums.CoinLedgerSource
    referenceId?: StringFilter<"CoinLedger"> | string
    metadata?: JsonNullableFilter<"CoinLedger">
    createdAt?: DateTimeFilter<"CoinLedger"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CoinLedgerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    delta?: SortOrder
    source?: SortOrder
    referenceId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CoinLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_source_referenceId?: CoinLedgerUserIdSourceReferenceIdCompoundUniqueInput
    AND?: CoinLedgerWhereInput | CoinLedgerWhereInput[]
    OR?: CoinLedgerWhereInput[]
    NOT?: CoinLedgerWhereInput | CoinLedgerWhereInput[]
    userId?: StringFilter<"CoinLedger"> | string
    date?: DateTimeFilter<"CoinLedger"> | Date | string
    delta?: IntFilter<"CoinLedger"> | number
    source?: EnumCoinLedgerSourceFilter<"CoinLedger"> | $Enums.CoinLedgerSource
    referenceId?: StringFilter<"CoinLedger"> | string
    metadata?: JsonNullableFilter<"CoinLedger">
    createdAt?: DateTimeFilter<"CoinLedger"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_source_referenceId">

  export type CoinLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    delta?: SortOrder
    source?: SortOrder
    referenceId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CoinLedgerCountOrderByAggregateInput
    _avg?: CoinLedgerAvgOrderByAggregateInput
    _max?: CoinLedgerMaxOrderByAggregateInput
    _min?: CoinLedgerMinOrderByAggregateInput
    _sum?: CoinLedgerSumOrderByAggregateInput
  }

  export type CoinLedgerScalarWhereWithAggregatesInput = {
    AND?: CoinLedgerScalarWhereWithAggregatesInput | CoinLedgerScalarWhereWithAggregatesInput[]
    OR?: CoinLedgerScalarWhereWithAggregatesInput[]
    NOT?: CoinLedgerScalarWhereWithAggregatesInput | CoinLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoinLedger"> | string
    userId?: StringWithAggregatesFilter<"CoinLedger"> | string
    date?: DateTimeWithAggregatesFilter<"CoinLedger"> | Date | string
    delta?: IntWithAggregatesFilter<"CoinLedger"> | number
    source?: EnumCoinLedgerSourceWithAggregatesFilter<"CoinLedger"> | $Enums.CoinLedgerSource
    referenceId?: StringWithAggregatesFilter<"CoinLedger"> | string
    metadata?: JsonNullableWithAggregatesFilter<"CoinLedger">
    createdAt?: DateTimeWithAggregatesFilter<"CoinLedger"> | Date | string
  }

  export type GameConfigWhereInput = {
    AND?: GameConfigWhereInput | GameConfigWhereInput[]
    OR?: GameConfigWhereInput[]
    NOT?: GameConfigWhereInput | GameConfigWhereInput[]
    id?: StringFilter<"GameConfig"> | string
    version?: StringFilter<"GameConfig"> | string
    daily_tournament?: JsonFilter<"GameConfig">
    instant_tournament?: JsonFilter<"GameConfig">
    single_player?: JsonFilter<"GameConfig">
    leveling?: JsonFilter<"GameConfig">
    base_points_by_level?: JsonFilter<"GameConfig">
    scoring?: JsonFilter<"GameConfig">
    points_distribution?: JsonFilter<"GameConfig">
    caps?: JsonFilter<"GameConfig">
    ad_units?: JsonFilter<"GameConfig">
    lifelines?: JsonFilter<"GameConfig">
    top_attempts?: JsonFilter<"GameConfig">
    feature_flags?: JsonFilter<"GameConfig">
    safety?: JsonFilter<"GameConfig">
    referrals?: JsonFilter<"GameConfig">
    rewards?: JsonFilter<"GameConfig">
    cron?: JsonFilter<"GameConfig">
    analytics?: JsonFilter<"GameConfig">
    leaderboard?: JsonFilter<"GameConfig">
    qa?: JsonFilter<"GameConfig">
    updatedBy?: StringFilter<"GameConfig"> | string
    notes?: StringNullableFilter<"GameConfig"> | string | null
    createdAt?: DateTimeFilter<"GameConfig"> | Date | string
    isActive?: BoolFilter<"GameConfig"> | boolean
  }

  export type GameConfigOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    daily_tournament?: SortOrder
    instant_tournament?: SortOrder
    single_player?: SortOrder
    leveling?: SortOrder
    base_points_by_level?: SortOrder
    scoring?: SortOrder
    points_distribution?: SortOrder
    caps?: SortOrder
    ad_units?: SortOrder
    lifelines?: SortOrder
    top_attempts?: SortOrder
    feature_flags?: SortOrder
    safety?: SortOrder
    referrals?: SortOrder
    rewards?: SortOrder
    cron?: SortOrder
    analytics?: SortOrder
    leaderboard?: SortOrder
    qa?: SortOrder
    updatedBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type GameConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameConfigWhereInput | GameConfigWhereInput[]
    OR?: GameConfigWhereInput[]
    NOT?: GameConfigWhereInput | GameConfigWhereInput[]
    version?: StringFilter<"GameConfig"> | string
    daily_tournament?: JsonFilter<"GameConfig">
    instant_tournament?: JsonFilter<"GameConfig">
    single_player?: JsonFilter<"GameConfig">
    leveling?: JsonFilter<"GameConfig">
    base_points_by_level?: JsonFilter<"GameConfig">
    scoring?: JsonFilter<"GameConfig">
    points_distribution?: JsonFilter<"GameConfig">
    caps?: JsonFilter<"GameConfig">
    ad_units?: JsonFilter<"GameConfig">
    lifelines?: JsonFilter<"GameConfig">
    top_attempts?: JsonFilter<"GameConfig">
    feature_flags?: JsonFilter<"GameConfig">
    safety?: JsonFilter<"GameConfig">
    referrals?: JsonFilter<"GameConfig">
    rewards?: JsonFilter<"GameConfig">
    cron?: JsonFilter<"GameConfig">
    analytics?: JsonFilter<"GameConfig">
    leaderboard?: JsonFilter<"GameConfig">
    qa?: JsonFilter<"GameConfig">
    updatedBy?: StringFilter<"GameConfig"> | string
    notes?: StringNullableFilter<"GameConfig"> | string | null
    createdAt?: DateTimeFilter<"GameConfig"> | Date | string
    isActive?: BoolFilter<"GameConfig"> | boolean
  }, "id">

  export type GameConfigOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    daily_tournament?: SortOrder
    instant_tournament?: SortOrder
    single_player?: SortOrder
    leveling?: SortOrder
    base_points_by_level?: SortOrder
    scoring?: SortOrder
    points_distribution?: SortOrder
    caps?: SortOrder
    ad_units?: SortOrder
    lifelines?: SortOrder
    top_attempts?: SortOrder
    feature_flags?: SortOrder
    safety?: SortOrder
    referrals?: SortOrder
    rewards?: SortOrder
    cron?: SortOrder
    analytics?: SortOrder
    leaderboard?: SortOrder
    qa?: SortOrder
    updatedBy?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    _count?: GameConfigCountOrderByAggregateInput
    _max?: GameConfigMaxOrderByAggregateInput
    _min?: GameConfigMinOrderByAggregateInput
  }

  export type GameConfigScalarWhereWithAggregatesInput = {
    AND?: GameConfigScalarWhereWithAggregatesInput | GameConfigScalarWhereWithAggregatesInput[]
    OR?: GameConfigScalarWhereWithAggregatesInput[]
    NOT?: GameConfigScalarWhereWithAggregatesInput | GameConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameConfig"> | string
    version?: StringWithAggregatesFilter<"GameConfig"> | string
    daily_tournament?: JsonWithAggregatesFilter<"GameConfig">
    instant_tournament?: JsonWithAggregatesFilter<"GameConfig">
    single_player?: JsonWithAggregatesFilter<"GameConfig">
    leveling?: JsonWithAggregatesFilter<"GameConfig">
    base_points_by_level?: JsonWithAggregatesFilter<"GameConfig">
    scoring?: JsonWithAggregatesFilter<"GameConfig">
    points_distribution?: JsonWithAggregatesFilter<"GameConfig">
    caps?: JsonWithAggregatesFilter<"GameConfig">
    ad_units?: JsonWithAggregatesFilter<"GameConfig">
    lifelines?: JsonWithAggregatesFilter<"GameConfig">
    top_attempts?: JsonWithAggregatesFilter<"GameConfig">
    feature_flags?: JsonWithAggregatesFilter<"GameConfig">
    safety?: JsonWithAggregatesFilter<"GameConfig">
    referrals?: JsonWithAggregatesFilter<"GameConfig">
    rewards?: JsonWithAggregatesFilter<"GameConfig">
    cron?: JsonWithAggregatesFilter<"GameConfig">
    analytics?: JsonWithAggregatesFilter<"GameConfig">
    leaderboard?: JsonWithAggregatesFilter<"GameConfig">
    qa?: JsonWithAggregatesFilter<"GameConfig">
    updatedBy?: StringWithAggregatesFilter<"GameConfig"> | string
    notes?: StringNullableWithAggregatesFilter<"GameConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GameConfig"> | Date | string
    isActive?: BoolWithAggregatesFilter<"GameConfig"> | boolean
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
  }

  export type DailyTournamentCreateInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    status?: $Enums.TournamentStatus
    configVersion?: string | null
    final?: JsonNullValueInput | InputJsonValue
    minuteSnapshot?: MinuteSnapshotCreateNestedManyWithoutTournamentInput
    sessions?: DailyTournamentSessionCreateNestedManyWithoutTournamentInput
  }

  export type DailyTournamentUncheckedCreateInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    status?: $Enums.TournamentStatus
    configVersion?: string | null
    final?: JsonNullValueInput | InputJsonValue
    minuteSnapshot?: MinuteSnapshotUncheckedCreateNestedManyWithoutTournamentInput
    sessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type DailyTournamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    configVersion?: NullableStringFieldUpdateOperationsInput | string | null
    final?: JsonNullValueInput | InputJsonValue
    minuteSnapshot?: MinuteSnapshotUpdateManyWithoutTournamentNestedInput
    sessions?: DailyTournamentSessionUpdateManyWithoutTournamentNestedInput
  }

  export type DailyTournamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    configVersion?: NullableStringFieldUpdateOperationsInput | string | null
    final?: JsonNullValueInput | InputJsonValue
    minuteSnapshot?: MinuteSnapshotUncheckedUpdateManyWithoutTournamentNestedInput
    sessions?: DailyTournamentSessionUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type DailyTournamentCreateManyInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    status?: $Enums.TournamentStatus
    configVersion?: string | null
    final?: JsonNullValueInput | InputJsonValue
  }

  export type DailyTournamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    configVersion?: NullableStringFieldUpdateOperationsInput | string | null
    final?: JsonNullValueInput | InputJsonValue
  }

  export type DailyTournamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    configVersion?: NullableStringFieldUpdateOperationsInput | string | null
    final?: JsonNullValueInput | InputJsonValue
  }

  export type DailyTournamentSessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
    user: UserCreateNestedOneWithoutDailySessionsInput
    tournament: DailyTournamentCreateNestedOneWithoutSessionsInput
    questions?: QuestionAttemptCreateNestedManyWithoutDailySessionInput
  }

  export type DailyTournamentSessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    tournamentId: string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
    questions?: QuestionAttemptUncheckedCreateNestedManyWithoutDailySessionInput
  }

  export type DailyTournamentSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailySessionsNestedInput
    tournament?: DailyTournamentUpdateOneRequiredWithoutSessionsNestedInput
    questions?: QuestionAttemptUpdateManyWithoutDailySessionNestedInput
  }

  export type DailyTournamentSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionAttemptUncheckedUpdateManyWithoutDailySessionNestedInput
  }

  export type DailyTournamentSessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    tournamentId: string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
  }

  export type DailyTournamentSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyTournamentSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinuteSnapshotCreateInput = {
    id?: string
    minuteNumber: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tournament: DailyTournamentCreateNestedOneWithoutMinuteSnapshotInput
  }

  export type MinuteSnapshotUncheckedCreateInput = {
    id?: string
    tournamentId: string
    minuteNumber: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MinuteSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    minuteNumber?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: DailyTournamentUpdateOneRequiredWithoutMinuteSnapshotNestedInput
  }

  export type MinuteSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    minuteNumber?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinuteSnapshotCreateManyInput = {
    id?: string
    tournamentId: string
    minuteNumber: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MinuteSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    minuteNumber?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinuteSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    minuteNumber?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoloSessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentRound?: number
    bankedPoints?: number
    finalScore?: number | null
    coinPointsEarned?: number
    isFreeAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    madeMistake?: boolean
    quitEarly?: boolean
    user: UserCreateNestedOneWithoutSoloSessionsInput
    questions?: QuestionAttemptCreateNestedManyWithoutSoloSessionInput
  }

  export type SoloSessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    date: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentRound?: number
    bankedPoints?: number
    finalScore?: number | null
    coinPointsEarned?: number
    isFreeAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    madeMistake?: boolean
    quitEarly?: boolean
    questions?: QuestionAttemptUncheckedCreateNestedManyWithoutSoloSessionInput
  }

  export type SoloSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSoloSessionsNestedInput
    questions?: QuestionAttemptUpdateManyWithoutSoloSessionNestedInput
  }

  export type SoloSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionAttemptUncheckedUpdateManyWithoutSoloSessionNestedInput
  }

  export type SoloSessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    date: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentRound?: number
    bankedPoints?: number
    finalScore?: number | null
    coinPointsEarned?: number
    isFreeAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    madeMistake?: boolean
    quitEarly?: boolean
  }

  export type SoloSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SoloSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionAttemptCreateInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySession?: DailyTournamentSessionCreateNestedOneWithoutQuestionsInput
    soloSession?: SoloSessionCreateNestedOneWithoutQuestionsInput
    instantSession?: InstantSessionCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionAttemptUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySessionId?: string | null
    soloSessionId?: string | null
    instantSessionId?: string | null
  }

  export type QuestionAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySession?: DailyTournamentSessionUpdateOneWithoutQuestionsNestedInput
    soloSession?: SoloSessionUpdateOneWithoutQuestionsNestedInput
    instantSession?: InstantSessionUpdateOneWithoutQuestionsNestedInput
  }

  export type QuestionAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySessionId?: NullableStringFieldUpdateOperationsInput | string | null
    soloSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    instantSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionAttemptCreateManyInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySessionId?: string | null
    soloSessionId?: string | null
    instantSessionId?: string | null
  }

  export type QuestionAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySessionId?: NullableStringFieldUpdateOperationsInput | string | null
    soloSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    instantSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstantTournamentCreateInput = {
    id?: string
    status?: $Enums.TournamentStatus
    maxPlayers?: number
    playersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    sessions?: InstantSessionCreateNestedManyWithoutTournamentInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutTournamentInput
  }

  export type InstantTournamentUncheckedCreateInput = {
    id?: string
    status?: $Enums.TournamentStatus
    maxPlayers?: number
    playersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    sessions?: InstantSessionUncheckedCreateNestedManyWithoutTournamentInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type InstantTournamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    maxPlayers?: IntFieldUpdateOperationsInput | number
    playersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: InstantSessionUpdateManyWithoutTournamentNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutTournamentNestedInput
  }

  export type InstantTournamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    maxPlayers?: IntFieldUpdateOperationsInput | number
    playersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: InstantSessionUncheckedUpdateManyWithoutTournamentNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type InstantTournamentCreateManyInput = {
    id?: string
    status?: $Enums.TournamentStatus
    maxPlayers?: number
    playersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
  }

  export type InstantTournamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    maxPlayers?: IntFieldUpdateOperationsInput | number
    playersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstantTournamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    maxPlayers?: IntFieldUpdateOperationsInput | number
    playersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstantSessionCreateInput = {
    id?: string
    status?: $Enums.InstantTournamentSessionStatus
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
    user: UserCreateNestedOneWithoutInstantSessionsInput
    tournament: InstantTournamentCreateNestedOneWithoutSessionsInput
    questions?: QuestionAttemptCreateNestedManyWithoutInstantSessionInput
  }

  export type InstantSessionUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.InstantTournamentSessionStatus
    tournamentId: string
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
    questions?: QuestionAttemptUncheckedCreateNestedManyWithoutInstantSessionInput
  }

  export type InstantSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInstantSessionsNestedInput
    tournament?: InstantTournamentUpdateOneRequiredWithoutSessionsNestedInput
    questions?: QuestionAttemptUpdateManyWithoutInstantSessionNestedInput
  }

  export type InstantSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuestionAttemptUncheckedUpdateManyWithoutInstantSessionNestedInput
  }

  export type InstantSessionCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.InstantTournamentSessionStatus
    tournamentId: string
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
  }

  export type InstantSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstantSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstantParticipantCreateInput = {
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
    tournament: InstantTournamentCreateNestedOneWithoutInstantParticipantInput
    user: UserCreateNestedOneWithoutInstantParticipantInput
  }

  export type InstantParticipantUncheckedCreateInput = {
    tournamentId: string
    userId: string
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
  }

  export type InstantParticipantUpdateInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    tournament?: InstantTournamentUpdateOneRequiredWithoutInstantParticipantNestedInput
    user?: UserUpdateOneRequiredWithoutInstantParticipantNestedInput
  }

  export type InstantParticipantUncheckedUpdateInput = {
    tournamentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InstantParticipantCreateManyInput = {
    tournamentId: string
    userId: string
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
  }

  export type InstantParticipantUpdateManyMutationInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InstantParticipantUncheckedUpdateManyInput = {
    tournamentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DailyLeaderboardCreateInput = {
    id?: string
    date: Date | string
    bestScore?: number
    rank?: number
    coinPoints?: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyLeaderBoardsInput
  }

  export type DailyLeaderboardUncheckedCreateInput = {
    id?: string
    date: Date | string
    userId: string
    bestScore?: number
    rank?: number
    coinPoints?: number
    updatedAt?: Date | string
  }

  export type DailyLeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyLeaderBoardsNestedInput
  }

  export type DailyLeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyLeaderboardCreateManyInput = {
    id?: string
    date: Date | string
    userId: string
    bestScore?: number
    rank?: number
    coinPoints?: number
    updatedAt?: Date | string
  }

  export type DailyLeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyLeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstantLeaderboardCreateInput = {
    id?: string
    tournamentId: string
    bestScore?: number
    rank?: number
    coinPoints: Decimal | DecimalJsLike | number | string
    submittedAt: Date | string
    updatedAt?: Date | string
    date?: Date | string
    user: UserCreateNestedOneWithoutInstantLeaderboardInput
  }

  export type InstantLeaderboardUncheckedCreateInput = {
    id?: string
    tournamentId: string
    userId: string
    bestScore?: number
    rank?: number
    coinPoints: Decimal | DecimalJsLike | number | string
    submittedAt: Date | string
    updatedAt?: Date | string
    date?: Date | string
  }

  export type InstantLeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInstantLeaderboardNestedInput
  }

  export type InstantLeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstantLeaderboardCreateManyInput = {
    id?: string
    tournamentId: string
    userId: string
    bestScore?: number
    rank?: number
    coinPoints: Decimal | DecimalJsLike | number | string
    submittedAt: Date | string
    updatedAt?: Date | string
    date?: Date | string
  }

  export type InstantLeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstantLeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyUserLeaderboardCreateInput = {
    id?: string
    date: Date | string
    dailyCoinPoints?: number
    instantCoinPoints?: Decimal | DecimalJsLike | number | string
    totalCoinPoints?: Decimal | DecimalJsLike | number | string
    rank?: number
    isEligible?: boolean
    coinsAwarded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyUserLeaderboardInput
  }

  export type DailyUserLeaderboardUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    dailyCoinPoints?: number
    instantCoinPoints?: Decimal | DecimalJsLike | number | string
    totalCoinPoints?: Decimal | DecimalJsLike | number | string
    rank?: number
    isEligible?: boolean
    coinsAwarded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyUserLeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyCoinPoints?: IntFieldUpdateOperationsInput | number
    instantCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    isEligible?: BoolFieldUpdateOperationsInput | boolean
    coinsAwarded?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyUserLeaderboardNestedInput
  }

  export type DailyUserLeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyCoinPoints?: IntFieldUpdateOperationsInput | number
    instantCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    isEligible?: BoolFieldUpdateOperationsInput | boolean
    coinsAwarded?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyUserLeaderboardCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    dailyCoinPoints?: number
    instantCoinPoints?: Decimal | DecimalJsLike | number | string
    totalCoinPoints?: Decimal | DecimalJsLike | number | string
    rank?: number
    isEligible?: boolean
    coinsAwarded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyUserLeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyCoinPoints?: IntFieldUpdateOperationsInput | number
    instantCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    isEligible?: BoolFieldUpdateOperationsInput | boolean
    coinsAwarded?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyUserLeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyCoinPoints?: IntFieldUpdateOperationsInput | number
    instantCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    isEligible?: BoolFieldUpdateOperationsInput | boolean
    coinsAwarded?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoloLeaderboardCreateInput = {
    id?: string
    date: Date | string
    userId: string
    score: number
    rank: number
    percentile: number
    coinPoints: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SoloLeaderboardUncheckedCreateInput = {
    id?: string
    date: Date | string
    userId: string
    score: number
    rank: number
    percentile: number
    coinPoints: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SoloLeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    percentile?: FloatFieldUpdateOperationsInput | number
    coinPoints?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoloLeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    percentile?: FloatFieldUpdateOperationsInput | number
    coinPoints?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoloLeaderboardCreateManyInput = {
    id?: string
    date: Date | string
    userId: string
    score: number
    rank: number
    percentile: number
    coinPoints: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SoloLeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    percentile?: FloatFieldUpdateOperationsInput | number
    coinPoints?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoloLeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    percentile?: FloatFieldUpdateOperationsInput | number
    coinPoints?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimCreateInput = {
    id?: string
    coinsLocked: number
    status?: $Enums.ClaimStatus
    voucherCode?: string | null
    adminNotes?: string | null
    fulfilledBy?: string | null
    fulfilledAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRewardClaimInput
  }

  export type RewardClaimUncheckedCreateInput = {
    id?: string
    userId: string
    coinsLocked: number
    status?: $Enums.ClaimStatus
    voucherCode?: string | null
    adminNotes?: string | null
    fulfilledBy?: string | null
    fulfilledAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinsLocked?: IntFieldUpdateOperationsInput | number
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    voucherCode?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledBy?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRewardClaimNestedInput
  }

  export type RewardClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinsLocked?: IntFieldUpdateOperationsInput | number
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    voucherCode?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledBy?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimCreateManyInput = {
    id?: string
    userId: string
    coinsLocked: number
    status?: $Enums.ClaimStatus
    voucherCode?: string | null
    adminNotes?: string | null
    fulfilledBy?: string | null
    fulfilledAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinsLocked?: IntFieldUpdateOperationsInput | number
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    voucherCode?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledBy?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinsLocked?: IntFieldUpdateOperationsInput | number
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    voucherCode?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledBy?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsGivenInput
    referee?: UserCreateNestedOneWithoutReferralsReceivedInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrerId: string
    refereeId?: string | null
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsGivenNestedInput
    referee?: UserUpdateOneWithoutReferralsReceivedNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrerId: string
    refereeId?: string | null
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinLedgerCreateInput = {
    id?: string
    date: Date | string
    delta: number
    source: $Enums.CoinLedgerSource
    referenceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCoinLedgerInput
  }

  export type CoinLedgerUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    delta: number
    source: $Enums.CoinLedgerSource
    referenceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CoinLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    delta?: IntFieldUpdateOperationsInput | number
    source?: EnumCoinLedgerSourceFieldUpdateOperationsInput | $Enums.CoinLedgerSource
    referenceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoinLedgerNestedInput
  }

  export type CoinLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    delta?: IntFieldUpdateOperationsInput | number
    source?: EnumCoinLedgerSourceFieldUpdateOperationsInput | $Enums.CoinLedgerSource
    referenceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinLedgerCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    delta: number
    source: $Enums.CoinLedgerSource
    referenceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CoinLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    delta?: IntFieldUpdateOperationsInput | number
    source?: EnumCoinLedgerSourceFieldUpdateOperationsInput | $Enums.CoinLedgerSource
    referenceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    delta?: IntFieldUpdateOperationsInput | number
    source?: EnumCoinLedgerSourceFieldUpdateOperationsInput | $Enums.CoinLedgerSource
    referenceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameConfigCreateInput = {
    id?: string
    version: string
    daily_tournament: JsonNullValueInput | InputJsonValue
    instant_tournament: JsonNullValueInput | InputJsonValue
    single_player: JsonNullValueInput | InputJsonValue
    leveling: JsonNullValueInput | InputJsonValue
    base_points_by_level: JsonNullValueInput | InputJsonValue
    scoring: JsonNullValueInput | InputJsonValue
    points_distribution: JsonNullValueInput | InputJsonValue
    caps: JsonNullValueInput | InputJsonValue
    ad_units: JsonNullValueInput | InputJsonValue
    lifelines: JsonNullValueInput | InputJsonValue
    top_attempts: JsonNullValueInput | InputJsonValue
    feature_flags: JsonNullValueInput | InputJsonValue
    safety: JsonNullValueInput | InputJsonValue
    referrals: JsonNullValueInput | InputJsonValue
    rewards: JsonNullValueInput | InputJsonValue
    cron: JsonNullValueInput | InputJsonValue
    analytics: JsonNullValueInput | InputJsonValue
    leaderboard: JsonNullValueInput | InputJsonValue
    qa: JsonNullValueInput | InputJsonValue
    updatedBy: string
    notes?: string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type GameConfigUncheckedCreateInput = {
    id?: string
    version: string
    daily_tournament: JsonNullValueInput | InputJsonValue
    instant_tournament: JsonNullValueInput | InputJsonValue
    single_player: JsonNullValueInput | InputJsonValue
    leveling: JsonNullValueInput | InputJsonValue
    base_points_by_level: JsonNullValueInput | InputJsonValue
    scoring: JsonNullValueInput | InputJsonValue
    points_distribution: JsonNullValueInput | InputJsonValue
    caps: JsonNullValueInput | InputJsonValue
    ad_units: JsonNullValueInput | InputJsonValue
    lifelines: JsonNullValueInput | InputJsonValue
    top_attempts: JsonNullValueInput | InputJsonValue
    feature_flags: JsonNullValueInput | InputJsonValue
    safety: JsonNullValueInput | InputJsonValue
    referrals: JsonNullValueInput | InputJsonValue
    rewards: JsonNullValueInput | InputJsonValue
    cron: JsonNullValueInput | InputJsonValue
    analytics: JsonNullValueInput | InputJsonValue
    leaderboard: JsonNullValueInput | InputJsonValue
    qa: JsonNullValueInput | InputJsonValue
    updatedBy: string
    notes?: string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type GameConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    daily_tournament?: JsonNullValueInput | InputJsonValue
    instant_tournament?: JsonNullValueInput | InputJsonValue
    single_player?: JsonNullValueInput | InputJsonValue
    leveling?: JsonNullValueInput | InputJsonValue
    base_points_by_level?: JsonNullValueInput | InputJsonValue
    scoring?: JsonNullValueInput | InputJsonValue
    points_distribution?: JsonNullValueInput | InputJsonValue
    caps?: JsonNullValueInput | InputJsonValue
    ad_units?: JsonNullValueInput | InputJsonValue
    lifelines?: JsonNullValueInput | InputJsonValue
    top_attempts?: JsonNullValueInput | InputJsonValue
    feature_flags?: JsonNullValueInput | InputJsonValue
    safety?: JsonNullValueInput | InputJsonValue
    referrals?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    cron?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    leaderboard?: JsonNullValueInput | InputJsonValue
    qa?: JsonNullValueInput | InputJsonValue
    updatedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GameConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    daily_tournament?: JsonNullValueInput | InputJsonValue
    instant_tournament?: JsonNullValueInput | InputJsonValue
    single_player?: JsonNullValueInput | InputJsonValue
    leveling?: JsonNullValueInput | InputJsonValue
    base_points_by_level?: JsonNullValueInput | InputJsonValue
    scoring?: JsonNullValueInput | InputJsonValue
    points_distribution?: JsonNullValueInput | InputJsonValue
    caps?: JsonNullValueInput | InputJsonValue
    ad_units?: JsonNullValueInput | InputJsonValue
    lifelines?: JsonNullValueInput | InputJsonValue
    top_attempts?: JsonNullValueInput | InputJsonValue
    feature_flags?: JsonNullValueInput | InputJsonValue
    safety?: JsonNullValueInput | InputJsonValue
    referrals?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    cron?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    leaderboard?: JsonNullValueInput | InputJsonValue
    qa?: JsonNullValueInput | InputJsonValue
    updatedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GameConfigCreateManyInput = {
    id?: string
    version: string
    daily_tournament: JsonNullValueInput | InputJsonValue
    instant_tournament: JsonNullValueInput | InputJsonValue
    single_player: JsonNullValueInput | InputJsonValue
    leveling: JsonNullValueInput | InputJsonValue
    base_points_by_level: JsonNullValueInput | InputJsonValue
    scoring: JsonNullValueInput | InputJsonValue
    points_distribution: JsonNullValueInput | InputJsonValue
    caps: JsonNullValueInput | InputJsonValue
    ad_units: JsonNullValueInput | InputJsonValue
    lifelines: JsonNullValueInput | InputJsonValue
    top_attempts: JsonNullValueInput | InputJsonValue
    feature_flags: JsonNullValueInput | InputJsonValue
    safety: JsonNullValueInput | InputJsonValue
    referrals: JsonNullValueInput | InputJsonValue
    rewards: JsonNullValueInput | InputJsonValue
    cron: JsonNullValueInput | InputJsonValue
    analytics: JsonNullValueInput | InputJsonValue
    leaderboard: JsonNullValueInput | InputJsonValue
    qa: JsonNullValueInput | InputJsonValue
    updatedBy: string
    notes?: string | null
    createdAt?: Date | string
    isActive?: boolean
  }

  export type GameConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    daily_tournament?: JsonNullValueInput | InputJsonValue
    instant_tournament?: JsonNullValueInput | InputJsonValue
    single_player?: JsonNullValueInput | InputJsonValue
    leveling?: JsonNullValueInput | InputJsonValue
    base_points_by_level?: JsonNullValueInput | InputJsonValue
    scoring?: JsonNullValueInput | InputJsonValue
    points_distribution?: JsonNullValueInput | InputJsonValue
    caps?: JsonNullValueInput | InputJsonValue
    ad_units?: JsonNullValueInput | InputJsonValue
    lifelines?: JsonNullValueInput | InputJsonValue
    top_attempts?: JsonNullValueInput | InputJsonValue
    feature_flags?: JsonNullValueInput | InputJsonValue
    safety?: JsonNullValueInput | InputJsonValue
    referrals?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    cron?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    leaderboard?: JsonNullValueInput | InputJsonValue
    qa?: JsonNullValueInput | InputJsonValue
    updatedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GameConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    daily_tournament?: JsonNullValueInput | InputJsonValue
    instant_tournament?: JsonNullValueInput | InputJsonValue
    single_player?: JsonNullValueInput | InputJsonValue
    leveling?: JsonNullValueInput | InputJsonValue
    base_points_by_level?: JsonNullValueInput | InputJsonValue
    scoring?: JsonNullValueInput | InputJsonValue
    points_distribution?: JsonNullValueInput | InputJsonValue
    caps?: JsonNullValueInput | InputJsonValue
    ad_units?: JsonNullValueInput | InputJsonValue
    lifelines?: JsonNullValueInput | InputJsonValue
    top_attempts?: JsonNullValueInput | InputJsonValue
    feature_flags?: JsonNullValueInput | InputJsonValue
    safety?: JsonNullValueInput | InputJsonValue
    referrals?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    cron?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    leaderboard?: JsonNullValueInput | InputJsonValue
    qa?: JsonNullValueInput | InputJsonValue
    updatedBy?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumAvatarTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AvatarType | EnumAvatarTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvatarType[] | ListEnumAvatarTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvatarType[] | ListEnumAvatarTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvatarTypeFilter<$PrismaModel> | $Enums.AvatarType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumThemeFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeFilter<$PrismaModel> | $Enums.Theme
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type DailyTournamentSessionListRelationFilter = {
    every?: DailyTournamentSessionWhereInput
    some?: DailyTournamentSessionWhereInput
    none?: DailyTournamentSessionWhereInput
  }

  export type SoloSessionListRelationFilter = {
    every?: SoloSessionWhereInput
    some?: SoloSessionWhereInput
    none?: SoloSessionWhereInput
  }

  export type InstantSessionListRelationFilter = {
    every?: InstantSessionWhereInput
    some?: InstantSessionWhereInput
    none?: InstantSessionWhereInput
  }

  export type InstantParticipantListRelationFilter = {
    every?: InstantParticipantWhereInput
    some?: InstantParticipantWhereInput
    none?: InstantParticipantWhereInput
  }

  export type DailyLeaderboardListRelationFilter = {
    every?: DailyLeaderboardWhereInput
    some?: DailyLeaderboardWhereInput
    none?: DailyLeaderboardWhereInput
  }

  export type InstantLeaderboardListRelationFilter = {
    every?: InstantLeaderboardWhereInput
    some?: InstantLeaderboardWhereInput
    none?: InstantLeaderboardWhereInput
  }

  export type RewardClaimListRelationFilter = {
    every?: RewardClaimWhereInput
    some?: RewardClaimWhereInput
    none?: RewardClaimWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type CoinLedgerListRelationFilter = {
    every?: CoinLedgerWhereInput
    some?: CoinLedgerWhereInput
    none?: CoinLedgerWhereInput
  }

  export type DailyUserLeaderboardListRelationFilter = {
    every?: DailyUserLeaderboardWhereInput
    some?: DailyUserLeaderboardWhereInput
    none?: DailyUserLeaderboardWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyTournamentSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SoloSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstantSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstantParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyLeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstantLeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoinLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyUserLeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    googleId?: SortOrder
    email?: SortOrder
    deviceHash?: SortOrder
    username?: SortOrder
    usernameReservedAt?: SortOrder
    avatarType?: SortOrder
    profilePictureUrl?: SortOrder
    coins?: SortOrder
    lifetimeCoins?: SortOrder
    lifetimeCoinPoints?: SortOrder
    level?: SortOrder
    theme?: SortOrder
    soundEnabled?: SortOrder
    hapticsEnabled?: SortOrder
    language?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
    referralRewarded?: SortOrder
    role?: SortOrder
    soloAttemptCount?: SortOrder
    instantAttemptCount?: SortOrder
    dailyAttemptCount?: SortOrder
    currentLoginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    lastLoginRewardDate?: SortOrder
    totalLoginDays?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    coins?: SortOrder
    lifetimeCoins?: SortOrder
    lifetimeCoinPoints?: SortOrder
    level?: SortOrder
    soloAttemptCount?: SortOrder
    instantAttemptCount?: SortOrder
    dailyAttemptCount?: SortOrder
    currentLoginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    totalLoginDays?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    googleId?: SortOrder
    email?: SortOrder
    deviceHash?: SortOrder
    username?: SortOrder
    usernameReservedAt?: SortOrder
    avatarType?: SortOrder
    profilePictureUrl?: SortOrder
    coins?: SortOrder
    lifetimeCoins?: SortOrder
    lifetimeCoinPoints?: SortOrder
    level?: SortOrder
    theme?: SortOrder
    soundEnabled?: SortOrder
    hapticsEnabled?: SortOrder
    language?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
    referralRewarded?: SortOrder
    role?: SortOrder
    soloAttemptCount?: SortOrder
    instantAttemptCount?: SortOrder
    dailyAttemptCount?: SortOrder
    currentLoginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    lastLoginRewardDate?: SortOrder
    totalLoginDays?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phoneNumber?: SortOrder
    googleId?: SortOrder
    email?: SortOrder
    deviceHash?: SortOrder
    username?: SortOrder
    usernameReservedAt?: SortOrder
    avatarType?: SortOrder
    profilePictureUrl?: SortOrder
    coins?: SortOrder
    lifetimeCoins?: SortOrder
    lifetimeCoinPoints?: SortOrder
    level?: SortOrder
    theme?: SortOrder
    soundEnabled?: SortOrder
    hapticsEnabled?: SortOrder
    language?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
    referralRewarded?: SortOrder
    role?: SortOrder
    soloAttemptCount?: SortOrder
    instantAttemptCount?: SortOrder
    dailyAttemptCount?: SortOrder
    currentLoginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    lastLoginRewardDate?: SortOrder
    totalLoginDays?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    coins?: SortOrder
    lifetimeCoins?: SortOrder
    lifetimeCoinPoints?: SortOrder
    level?: SortOrder
    soloAttemptCount?: SortOrder
    instantAttemptCount?: SortOrder
    dailyAttemptCount?: SortOrder
    currentLoginStreak?: SortOrder
    longestLoginStreak?: SortOrder
    totalLoginDays?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAvatarTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvatarType | EnumAvatarTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvatarType[] | ListEnumAvatarTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvatarType[] | ListEnumAvatarTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvatarTypeWithAggregatesFilter<$PrismaModel> | $Enums.AvatarType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvatarTypeFilter<$PrismaModel>
    _max?: NestedEnumAvatarTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumThemeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeWithAggregatesFilter<$PrismaModel> | $Enums.Theme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThemeFilter<$PrismaModel>
    _max?: NestedEnumThemeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MinuteSnapshotListRelationFilter = {
    every?: MinuteSnapshotWhereInput
    some?: MinuteSnapshotWhereInput
    none?: MinuteSnapshotWhereInput
  }

  export type MinuteSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyTournamentCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    configVersion?: SortOrder
    final?: SortOrder
  }

  export type DailyTournamentMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    configVersion?: SortOrder
  }

  export type DailyTournamentMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    configVersion?: SortOrder
  }

  export type EnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumUserTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTournamentStatus | EnumUserTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserTournamentStatus[] | ListEnumUserTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTournamentStatus[] | ListEnumUserTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTournamentStatusFilter<$PrismaModel> | $Enums.UserTournamentStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DailyTournamentScalarRelationFilter = {
    is?: DailyTournamentWhereInput
    isNot?: DailyTournamentWhereInput
  }

  export type QuestionAttemptListRelationFilter = {
    every?: QuestionAttemptWhereInput
    some?: QuestionAttemptWhereInput
    none?: QuestionAttemptWhereInput
  }

  export type QuestionAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyTournamentSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    currentScore?: SortOrder
    finalScore?: SortOrder
    minute1Score?: SortOrder
    minute2Score?: SortOrder
    minute3Score?: SortOrder
    minute4Score?: SortOrder
    isFreeAttempt?: SortOrder
    isRewardedAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    endsAt?: SortOrder
  }

  export type DailyTournamentSessionAvgOrderByAggregateInput = {
    currentScore?: SortOrder
    finalScore?: SortOrder
    minute1Score?: SortOrder
    minute2Score?: SortOrder
    minute3Score?: SortOrder
    minute4Score?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
  }

  export type DailyTournamentSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    currentScore?: SortOrder
    finalScore?: SortOrder
    minute1Score?: SortOrder
    minute2Score?: SortOrder
    minute3Score?: SortOrder
    minute4Score?: SortOrder
    isFreeAttempt?: SortOrder
    isRewardedAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    endsAt?: SortOrder
  }

  export type DailyTournamentSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    currentScore?: SortOrder
    finalScore?: SortOrder
    minute1Score?: SortOrder
    minute2Score?: SortOrder
    minute3Score?: SortOrder
    minute4Score?: SortOrder
    isFreeAttempt?: SortOrder
    isRewardedAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    endsAt?: SortOrder
  }

  export type DailyTournamentSessionSumOrderByAggregateInput = {
    currentScore?: SortOrder
    finalScore?: SortOrder
    minute1Score?: SortOrder
    minute2Score?: SortOrder
    minute3Score?: SortOrder
    minute4Score?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
  }

  export type EnumUserTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTournamentStatus | EnumUserTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserTournamentStatus[] | ListEnumUserTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTournamentStatus[] | ListEnumUserTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserTournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumUserTournamentStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type MinuteSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    minuteNumber?: SortOrder
    snapshot?: SortOrder
    createdAt?: SortOrder
  }

  export type MinuteSnapshotAvgOrderByAggregateInput = {
    minuteNumber?: SortOrder
  }

  export type MinuteSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    minuteNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type MinuteSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    minuteNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type MinuteSnapshotSumOrderByAggregateInput = {
    minuteNumber?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SoloSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    bankedPoints?: SortOrder
    finalScore?: SortOrder
    coinPointsEarned?: SortOrder
    isFreeAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    madeMistake?: SortOrder
    quitEarly?: SortOrder
  }

  export type SoloSessionAvgOrderByAggregateInput = {
    currentRound?: SortOrder
    bankedPoints?: SortOrder
    finalScore?: SortOrder
    coinPointsEarned?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
  }

  export type SoloSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    bankedPoints?: SortOrder
    finalScore?: SortOrder
    coinPointsEarned?: SortOrder
    isFreeAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    madeMistake?: SortOrder
    quitEarly?: SortOrder
  }

  export type SoloSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    sessionSeed?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    bankedPoints?: SortOrder
    finalScore?: SortOrder
    coinPointsEarned?: SortOrder
    isFreeAttempt?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    madeMistake?: SortOrder
    quitEarly?: SortOrder
  }

  export type SoloSessionSumOrderByAggregateInput = {
    currentRound?: SortOrder
    bankedPoints?: SortOrder
    finalScore?: SortOrder
    coinPointsEarned?: SortOrder
    currentLevel?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DailyTournamentSessionNullableScalarRelationFilter = {
    is?: DailyTournamentSessionWhereInput | null
    isNot?: DailyTournamentSessionWhereInput | null
  }

  export type SoloSessionNullableScalarRelationFilter = {
    is?: SoloSessionWhereInput | null
    isNot?: SoloSessionWhereInput | null
  }

  export type InstantSessionNullableScalarRelationFilter = {
    is?: InstantSessionWhereInput | null
    isNot?: InstantSessionWhereInput | null
  }

  export type QuestionAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    questionIndex?: SortOrder
    level?: SortOrder
    expression?: SortOrder
    result?: SortOrder
    side?: SortOrder
    kthDigit?: SortOrder
    correctDigit?: SortOrder
    dailySessionId?: SortOrder
    soloSessionId?: SortOrder
    instantSessionId?: SortOrder
  }

  export type QuestionAttemptAvgOrderByAggregateInput = {
    questionIndex?: SortOrder
    level?: SortOrder
    kthDigit?: SortOrder
    correctDigit?: SortOrder
  }

  export type QuestionAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    questionIndex?: SortOrder
    level?: SortOrder
    expression?: SortOrder
    result?: SortOrder
    side?: SortOrder
    kthDigit?: SortOrder
    correctDigit?: SortOrder
    dailySessionId?: SortOrder
    soloSessionId?: SortOrder
    instantSessionId?: SortOrder
  }

  export type QuestionAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    questionIndex?: SortOrder
    level?: SortOrder
    expression?: SortOrder
    result?: SortOrder
    side?: SortOrder
    kthDigit?: SortOrder
    correctDigit?: SortOrder
    dailySessionId?: SortOrder
    soloSessionId?: SortOrder
    instantSessionId?: SortOrder
  }

  export type QuestionAttemptSumOrderByAggregateInput = {
    questionIndex?: SortOrder
    level?: SortOrder
    kthDigit?: SortOrder
    correctDigit?: SortOrder
  }

  export type InstantTournamentCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    maxPlayers?: SortOrder
    playersCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type InstantTournamentAvgOrderByAggregateInput = {
    maxPlayers?: SortOrder
    playersCount?: SortOrder
  }

  export type InstantTournamentMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    maxPlayers?: SortOrder
    playersCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type InstantTournamentMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    maxPlayers?: SortOrder
    playersCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type InstantTournamentSumOrderByAggregateInput = {
    maxPlayers?: SortOrder
    playersCount?: SortOrder
  }

  export type EnumInstantTournamentSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstantTournamentSessionStatus | EnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstantTournamentSessionStatus[] | ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstantTournamentSessionStatus[] | ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstantTournamentSessionStatusFilter<$PrismaModel> | $Enums.InstantTournamentSessionStatus
  }

  export type InstantTournamentScalarRelationFilter = {
    is?: InstantTournamentWhereInput
    isNot?: InstantTournamentWhereInput
  }

  export type InstantSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    tournamentId?: SortOrder
    score?: SortOrder
    finalScore?: SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    endsAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type InstantSessionAvgOrderByAggregateInput = {
    score?: SortOrder
    finalScore?: SortOrder
    bestScore?: SortOrder
  }

  export type InstantSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    tournamentId?: SortOrder
    score?: SortOrder
    finalScore?: SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    endsAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type InstantSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    tournamentId?: SortOrder
    score?: SortOrder
    finalScore?: SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    endsAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type InstantSessionSumOrderByAggregateInput = {
    score?: SortOrder
    finalScore?: SortOrder
    bestScore?: SortOrder
  }

  export type EnumInstantTournamentSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstantTournamentSessionStatus | EnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstantTournamentSessionStatus[] | ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstantTournamentSessionStatus[] | ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstantTournamentSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstantTournamentSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstantTournamentSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumInstantTournamentSessionStatusFilter<$PrismaModel>
  }

  export type InstantParticipantTournamentIdUserIdCompoundUniqueInput = {
    tournamentId: string
    userId: string
  }

  export type InstantParticipantCountOrderByAggregateInput = {
    tournamentId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    joinOrder?: SortOrder
    sessionStarted?: SortOrder
    finalScore?: SortOrder
    submittedAt?: SortOrder
    finalRank?: SortOrder
  }

  export type InstantParticipantAvgOrderByAggregateInput = {
    joinOrder?: SortOrder
    finalScore?: SortOrder
    finalRank?: SortOrder
  }

  export type InstantParticipantMaxOrderByAggregateInput = {
    tournamentId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    joinOrder?: SortOrder
    sessionStarted?: SortOrder
    finalScore?: SortOrder
    submittedAt?: SortOrder
    finalRank?: SortOrder
  }

  export type InstantParticipantMinOrderByAggregateInput = {
    tournamentId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    joinOrder?: SortOrder
    sessionStarted?: SortOrder
    finalScore?: SortOrder
    submittedAt?: SortOrder
    finalRank?: SortOrder
  }

  export type InstantParticipantSumOrderByAggregateInput = {
    joinOrder?: SortOrder
    finalScore?: SortOrder
    finalRank?: SortOrder
  }

  export type DailyLeaderboardDateUserIdCompoundUniqueInput = {
    date: Date | string
    userId: string
  }

  export type DailyLeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyLeaderboardAvgOrderByAggregateInput = {
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
  }

  export type DailyLeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyLeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyLeaderboardSumOrderByAggregateInput = {
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type InstantLeaderboardTournamentIdUserIdCompoundUniqueInput = {
    tournamentId: string
    userId: string
  }

  export type InstantLeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
  }

  export type InstantLeaderboardAvgOrderByAggregateInput = {
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
  }

  export type InstantLeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
  }

  export type InstantLeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    tournamentId?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    date?: SortOrder
  }

  export type InstantLeaderboardSumOrderByAggregateInput = {
    bestScore?: SortOrder
    rank?: SortOrder
    coinPoints?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DailyUserLeaderboardUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type DailyUserLeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    dailyCoinPoints?: SortOrder
    instantCoinPoints?: SortOrder
    totalCoinPoints?: SortOrder
    rank?: SortOrder
    isEligible?: SortOrder
    coinsAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyUserLeaderboardAvgOrderByAggregateInput = {
    dailyCoinPoints?: SortOrder
    instantCoinPoints?: SortOrder
    totalCoinPoints?: SortOrder
    rank?: SortOrder
    coinsAwarded?: SortOrder
  }

  export type DailyUserLeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    dailyCoinPoints?: SortOrder
    instantCoinPoints?: SortOrder
    totalCoinPoints?: SortOrder
    rank?: SortOrder
    isEligible?: SortOrder
    coinsAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyUserLeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    dailyCoinPoints?: SortOrder
    instantCoinPoints?: SortOrder
    totalCoinPoints?: SortOrder
    rank?: SortOrder
    isEligible?: SortOrder
    coinsAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyUserLeaderboardSumOrderByAggregateInput = {
    dailyCoinPoints?: SortOrder
    instantCoinPoints?: SortOrder
    totalCoinPoints?: SortOrder
    rank?: SortOrder
    coinsAwarded?: SortOrder
  }

  export type SoloLeaderboardUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type SoloLeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    percentile?: SortOrder
    coinPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SoloLeaderboardAvgOrderByAggregateInput = {
    score?: SortOrder
    rank?: SortOrder
    percentile?: SortOrder
    coinPoints?: SortOrder
  }

  export type SoloLeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    percentile?: SortOrder
    coinPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SoloLeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    percentile?: SortOrder
    coinPoints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SoloLeaderboardSumOrderByAggregateInput = {
    score?: SortOrder
    rank?: SortOrder
    percentile?: SortOrder
    coinPoints?: SortOrder
  }

  export type EnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type RewardClaimCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinsLocked?: SortOrder
    status?: SortOrder
    voucherCode?: SortOrder
    adminNotes?: SortOrder
    fulfilledBy?: SortOrder
    fulfilledAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardClaimAvgOrderByAggregateInput = {
    coinsLocked?: SortOrder
  }

  export type RewardClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinsLocked?: SortOrder
    status?: SortOrder
    voucherCode?: SortOrder
    adminNotes?: SortOrder
    fulfilledBy?: SortOrder
    fulfilledAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardClaimMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinsLocked?: SortOrder
    status?: SortOrder
    voucherCode?: SortOrder
    adminNotes?: SortOrder
    fulfilledBy?: SortOrder
    fulfilledAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardClaimSumOrderByAggregateInput = {
    coinsLocked?: SortOrder
  }

  export type EnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type EnumReferralStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralStatus | EnumReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralStatusFilter<$PrismaModel> | $Enums.ReferralStatus
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    referralCode?: SortOrder
    status?: SortOrder
    referrerCoins?: SortOrder
    refereeCoins?: SortOrder
    rewardedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    referrerCoins?: SortOrder
    refereeCoins?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    referralCode?: SortOrder
    status?: SortOrder
    referrerCoins?: SortOrder
    refereeCoins?: SortOrder
    rewardedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    referralCode?: SortOrder
    status?: SortOrder
    referrerCoins?: SortOrder
    refereeCoins?: SortOrder
    rewardedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    referrerCoins?: SortOrder
    refereeCoins?: SortOrder
  }

  export type EnumReferralStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralStatus | EnumReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReferralStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferralStatusFilter<$PrismaModel>
    _max?: NestedEnumReferralStatusFilter<$PrismaModel>
  }

  export type EnumCoinLedgerSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.CoinLedgerSource | EnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CoinLedgerSource[] | ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoinLedgerSource[] | ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCoinLedgerSourceFilter<$PrismaModel> | $Enums.CoinLedgerSource
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CoinLedgerUserIdSourceReferenceIdCompoundUniqueInput = {
    userId: string
    source: $Enums.CoinLedgerSource
    referenceId: string
  }

  export type CoinLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    delta?: SortOrder
    source?: SortOrder
    referenceId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type CoinLedgerAvgOrderByAggregateInput = {
    delta?: SortOrder
  }

  export type CoinLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    delta?: SortOrder
    source?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
  }

  export type CoinLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    delta?: SortOrder
    source?: SortOrder
    referenceId?: SortOrder
    createdAt?: SortOrder
  }

  export type CoinLedgerSumOrderByAggregateInput = {
    delta?: SortOrder
  }

  export type EnumCoinLedgerSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoinLedgerSource | EnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CoinLedgerSource[] | ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoinLedgerSource[] | ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCoinLedgerSourceWithAggregatesFilter<$PrismaModel> | $Enums.CoinLedgerSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoinLedgerSourceFilter<$PrismaModel>
    _max?: NestedEnumCoinLedgerSourceFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type GameConfigCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    daily_tournament?: SortOrder
    instant_tournament?: SortOrder
    single_player?: SortOrder
    leveling?: SortOrder
    base_points_by_level?: SortOrder
    scoring?: SortOrder
    points_distribution?: SortOrder
    caps?: SortOrder
    ad_units?: SortOrder
    lifelines?: SortOrder
    top_attempts?: SortOrder
    feature_flags?: SortOrder
    safety?: SortOrder
    referrals?: SortOrder
    rewards?: SortOrder
    cron?: SortOrder
    analytics?: SortOrder
    leaderboard?: SortOrder
    qa?: SortOrder
    updatedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type GameConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    updatedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type GameConfigMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    updatedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DailyTournamentSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutUserInput, DailyTournamentSessionUncheckedCreateWithoutUserInput> | DailyTournamentSessionCreateWithoutUserInput[] | DailyTournamentSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutUserInput | DailyTournamentSessionCreateOrConnectWithoutUserInput[]
    createMany?: DailyTournamentSessionCreateManyUserInputEnvelope
    connect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
  }

  export type SoloSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SoloSessionCreateWithoutUserInput, SoloSessionUncheckedCreateWithoutUserInput> | SoloSessionCreateWithoutUserInput[] | SoloSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoloSessionCreateOrConnectWithoutUserInput | SoloSessionCreateOrConnectWithoutUserInput[]
    createMany?: SoloSessionCreateManyUserInputEnvelope
    connect?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
  }

  export type InstantSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<InstantSessionCreateWithoutUserInput, InstantSessionUncheckedCreateWithoutUserInput> | InstantSessionCreateWithoutUserInput[] | InstantSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantSessionCreateOrConnectWithoutUserInput | InstantSessionCreateOrConnectWithoutUserInput[]
    createMany?: InstantSessionCreateManyUserInputEnvelope
    connect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
  }

  export type InstantParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<InstantParticipantCreateWithoutUserInput, InstantParticipantUncheckedCreateWithoutUserInput> | InstantParticipantCreateWithoutUserInput[] | InstantParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantParticipantCreateOrConnectWithoutUserInput | InstantParticipantCreateOrConnectWithoutUserInput[]
    createMany?: InstantParticipantCreateManyUserInputEnvelope
    connect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
  }

  export type DailyLeaderboardCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyLeaderboardCreateWithoutUserInput, DailyLeaderboardUncheckedCreateWithoutUserInput> | DailyLeaderboardCreateWithoutUserInput[] | DailyLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyLeaderboardCreateOrConnectWithoutUserInput | DailyLeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: DailyLeaderboardCreateManyUserInputEnvelope
    connect?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
  }

  export type InstantLeaderboardCreateNestedManyWithoutUserInput = {
    create?: XOR<InstantLeaderboardCreateWithoutUserInput, InstantLeaderboardUncheckedCreateWithoutUserInput> | InstantLeaderboardCreateWithoutUserInput[] | InstantLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantLeaderboardCreateOrConnectWithoutUserInput | InstantLeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: InstantLeaderboardCreateManyUserInputEnvelope
    connect?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
  }

  export type RewardClaimCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardClaimCreateWithoutUserInput, RewardClaimUncheckedCreateWithoutUserInput> | RewardClaimCreateWithoutUserInput[] | RewardClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardClaimCreateOrConnectWithoutUserInput | RewardClaimCreateOrConnectWithoutUserInput[]
    createMany?: RewardClaimCreateManyUserInputEnvelope
    connect?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput> | ReferralCreateWithoutRefereeInput[] | ReferralUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput | ReferralCreateOrConnectWithoutRefereeInput[]
    createMany?: ReferralCreateManyRefereeInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type CoinLedgerCreateNestedManyWithoutUserInput = {
    create?: XOR<CoinLedgerCreateWithoutUserInput, CoinLedgerUncheckedCreateWithoutUserInput> | CoinLedgerCreateWithoutUserInput[] | CoinLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoinLedgerCreateOrConnectWithoutUserInput | CoinLedgerCreateOrConnectWithoutUserInput[]
    createMany?: CoinLedgerCreateManyUserInputEnvelope
    connect?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
  }

  export type DailyUserLeaderboardCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyUserLeaderboardCreateWithoutUserInput, DailyUserLeaderboardUncheckedCreateWithoutUserInput> | DailyUserLeaderboardCreateWithoutUserInput[] | DailyUserLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyUserLeaderboardCreateOrConnectWithoutUserInput | DailyUserLeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: DailyUserLeaderboardCreateManyUserInputEnvelope
    connect?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutUserInput, DailyTournamentSessionUncheckedCreateWithoutUserInput> | DailyTournamentSessionCreateWithoutUserInput[] | DailyTournamentSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutUserInput | DailyTournamentSessionCreateOrConnectWithoutUserInput[]
    createMany?: DailyTournamentSessionCreateManyUserInputEnvelope
    connect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
  }

  export type SoloSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SoloSessionCreateWithoutUserInput, SoloSessionUncheckedCreateWithoutUserInput> | SoloSessionCreateWithoutUserInput[] | SoloSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoloSessionCreateOrConnectWithoutUserInput | SoloSessionCreateOrConnectWithoutUserInput[]
    createMany?: SoloSessionCreateManyUserInputEnvelope
    connect?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
  }

  export type InstantSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstantSessionCreateWithoutUserInput, InstantSessionUncheckedCreateWithoutUserInput> | InstantSessionCreateWithoutUserInput[] | InstantSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantSessionCreateOrConnectWithoutUserInput | InstantSessionCreateOrConnectWithoutUserInput[]
    createMany?: InstantSessionCreateManyUserInputEnvelope
    connect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
  }

  export type InstantParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstantParticipantCreateWithoutUserInput, InstantParticipantUncheckedCreateWithoutUserInput> | InstantParticipantCreateWithoutUserInput[] | InstantParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantParticipantCreateOrConnectWithoutUserInput | InstantParticipantCreateOrConnectWithoutUserInput[]
    createMany?: InstantParticipantCreateManyUserInputEnvelope
    connect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
  }

  export type DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyLeaderboardCreateWithoutUserInput, DailyLeaderboardUncheckedCreateWithoutUserInput> | DailyLeaderboardCreateWithoutUserInput[] | DailyLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyLeaderboardCreateOrConnectWithoutUserInput | DailyLeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: DailyLeaderboardCreateManyUserInputEnvelope
    connect?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
  }

  export type InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstantLeaderboardCreateWithoutUserInput, InstantLeaderboardUncheckedCreateWithoutUserInput> | InstantLeaderboardCreateWithoutUserInput[] | InstantLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantLeaderboardCreateOrConnectWithoutUserInput | InstantLeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: InstantLeaderboardCreateManyUserInputEnvelope
    connect?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
  }

  export type RewardClaimUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardClaimCreateWithoutUserInput, RewardClaimUncheckedCreateWithoutUserInput> | RewardClaimCreateWithoutUserInput[] | RewardClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardClaimCreateOrConnectWithoutUserInput | RewardClaimCreateOrConnectWithoutUserInput[]
    createMany?: RewardClaimCreateManyUserInputEnvelope
    connect?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput> | ReferralCreateWithoutRefereeInput[] | ReferralUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput | ReferralCreateOrConnectWithoutRefereeInput[]
    createMany?: ReferralCreateManyRefereeInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type CoinLedgerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CoinLedgerCreateWithoutUserInput, CoinLedgerUncheckedCreateWithoutUserInput> | CoinLedgerCreateWithoutUserInput[] | CoinLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoinLedgerCreateOrConnectWithoutUserInput | CoinLedgerCreateOrConnectWithoutUserInput[]
    createMany?: CoinLedgerCreateManyUserInputEnvelope
    connect?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
  }

  export type DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyUserLeaderboardCreateWithoutUserInput, DailyUserLeaderboardUncheckedCreateWithoutUserInput> | DailyUserLeaderboardCreateWithoutUserInput[] | DailyUserLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyUserLeaderboardCreateOrConnectWithoutUserInput | DailyUserLeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: DailyUserLeaderboardCreateManyUserInputEnvelope
    connect?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumAvatarTypeFieldUpdateOperationsInput = {
    set?: $Enums.AvatarType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumThemeFieldUpdateOperationsInput = {
    set?: $Enums.Theme
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type UserUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferredByInput | UserUpsertWithWhereUniqueWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferredByInput | UserUpdateWithWhereUniqueWithoutReferredByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferredByInput | UserUpdateManyWithWhereWithoutReferredByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DailyTournamentSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutUserInput, DailyTournamentSessionUncheckedCreateWithoutUserInput> | DailyTournamentSessionCreateWithoutUserInput[] | DailyTournamentSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutUserInput | DailyTournamentSessionCreateOrConnectWithoutUserInput[]
    upsert?: DailyTournamentSessionUpsertWithWhereUniqueWithoutUserInput | DailyTournamentSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyTournamentSessionCreateManyUserInputEnvelope
    set?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    disconnect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    delete?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    connect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    update?: DailyTournamentSessionUpdateWithWhereUniqueWithoutUserInput | DailyTournamentSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyTournamentSessionUpdateManyWithWhereWithoutUserInput | DailyTournamentSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyTournamentSessionScalarWhereInput | DailyTournamentSessionScalarWhereInput[]
  }

  export type SoloSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SoloSessionCreateWithoutUserInput, SoloSessionUncheckedCreateWithoutUserInput> | SoloSessionCreateWithoutUserInput[] | SoloSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoloSessionCreateOrConnectWithoutUserInput | SoloSessionCreateOrConnectWithoutUserInput[]
    upsert?: SoloSessionUpsertWithWhereUniqueWithoutUserInput | SoloSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SoloSessionCreateManyUserInputEnvelope
    set?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
    disconnect?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
    delete?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
    connect?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
    update?: SoloSessionUpdateWithWhereUniqueWithoutUserInput | SoloSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SoloSessionUpdateManyWithWhereWithoutUserInput | SoloSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SoloSessionScalarWhereInput | SoloSessionScalarWhereInput[]
  }

  export type InstantSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstantSessionCreateWithoutUserInput, InstantSessionUncheckedCreateWithoutUserInput> | InstantSessionCreateWithoutUserInput[] | InstantSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantSessionCreateOrConnectWithoutUserInput | InstantSessionCreateOrConnectWithoutUserInput[]
    upsert?: InstantSessionUpsertWithWhereUniqueWithoutUserInput | InstantSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstantSessionCreateManyUserInputEnvelope
    set?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    disconnect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    delete?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    connect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    update?: InstantSessionUpdateWithWhereUniqueWithoutUserInput | InstantSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstantSessionUpdateManyWithWhereWithoutUserInput | InstantSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstantSessionScalarWhereInput | InstantSessionScalarWhereInput[]
  }

  export type InstantParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstantParticipantCreateWithoutUserInput, InstantParticipantUncheckedCreateWithoutUserInput> | InstantParticipantCreateWithoutUserInput[] | InstantParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantParticipantCreateOrConnectWithoutUserInput | InstantParticipantCreateOrConnectWithoutUserInput[]
    upsert?: InstantParticipantUpsertWithWhereUniqueWithoutUserInput | InstantParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstantParticipantCreateManyUserInputEnvelope
    set?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    disconnect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    delete?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    connect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    update?: InstantParticipantUpdateWithWhereUniqueWithoutUserInput | InstantParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstantParticipantUpdateManyWithWhereWithoutUserInput | InstantParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstantParticipantScalarWhereInput | InstantParticipantScalarWhereInput[]
  }

  export type DailyLeaderboardUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyLeaderboardCreateWithoutUserInput, DailyLeaderboardUncheckedCreateWithoutUserInput> | DailyLeaderboardCreateWithoutUserInput[] | DailyLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyLeaderboardCreateOrConnectWithoutUserInput | DailyLeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: DailyLeaderboardUpsertWithWhereUniqueWithoutUserInput | DailyLeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyLeaderboardCreateManyUserInputEnvelope
    set?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
    disconnect?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
    delete?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
    connect?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
    update?: DailyLeaderboardUpdateWithWhereUniqueWithoutUserInput | DailyLeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyLeaderboardUpdateManyWithWhereWithoutUserInput | DailyLeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyLeaderboardScalarWhereInput | DailyLeaderboardScalarWhereInput[]
  }

  export type InstantLeaderboardUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstantLeaderboardCreateWithoutUserInput, InstantLeaderboardUncheckedCreateWithoutUserInput> | InstantLeaderboardCreateWithoutUserInput[] | InstantLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantLeaderboardCreateOrConnectWithoutUserInput | InstantLeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: InstantLeaderboardUpsertWithWhereUniqueWithoutUserInput | InstantLeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstantLeaderboardCreateManyUserInputEnvelope
    set?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
    disconnect?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
    delete?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
    connect?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
    update?: InstantLeaderboardUpdateWithWhereUniqueWithoutUserInput | InstantLeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstantLeaderboardUpdateManyWithWhereWithoutUserInput | InstantLeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstantLeaderboardScalarWhereInput | InstantLeaderboardScalarWhereInput[]
  }

  export type RewardClaimUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardClaimCreateWithoutUserInput, RewardClaimUncheckedCreateWithoutUserInput> | RewardClaimCreateWithoutUserInput[] | RewardClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardClaimCreateOrConnectWithoutUserInput | RewardClaimCreateOrConnectWithoutUserInput[]
    upsert?: RewardClaimUpsertWithWhereUniqueWithoutUserInput | RewardClaimUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardClaimCreateManyUserInputEnvelope
    set?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
    disconnect?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
    delete?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
    connect?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
    update?: RewardClaimUpdateWithWhereUniqueWithoutUserInput | RewardClaimUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardClaimUpdateManyWithWhereWithoutUserInput | RewardClaimUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardClaimScalarWhereInput | RewardClaimScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput> | ReferralCreateWithoutRefereeInput[] | ReferralUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput | ReferralCreateOrConnectWithoutRefereeInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutRefereeInput | ReferralUpsertWithWhereUniqueWithoutRefereeInput[]
    createMany?: ReferralCreateManyRefereeInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutRefereeInput | ReferralUpdateWithWhereUniqueWithoutRefereeInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutRefereeInput | ReferralUpdateManyWithWhereWithoutRefereeInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type CoinLedgerUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoinLedgerCreateWithoutUserInput, CoinLedgerUncheckedCreateWithoutUserInput> | CoinLedgerCreateWithoutUserInput[] | CoinLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoinLedgerCreateOrConnectWithoutUserInput | CoinLedgerCreateOrConnectWithoutUserInput[]
    upsert?: CoinLedgerUpsertWithWhereUniqueWithoutUserInput | CoinLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoinLedgerCreateManyUserInputEnvelope
    set?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
    disconnect?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
    delete?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
    connect?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
    update?: CoinLedgerUpdateWithWhereUniqueWithoutUserInput | CoinLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoinLedgerUpdateManyWithWhereWithoutUserInput | CoinLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoinLedgerScalarWhereInput | CoinLedgerScalarWhereInput[]
  }

  export type DailyUserLeaderboardUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyUserLeaderboardCreateWithoutUserInput, DailyUserLeaderboardUncheckedCreateWithoutUserInput> | DailyUserLeaderboardCreateWithoutUserInput[] | DailyUserLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyUserLeaderboardCreateOrConnectWithoutUserInput | DailyUserLeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: DailyUserLeaderboardUpsertWithWhereUniqueWithoutUserInput | DailyUserLeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyUserLeaderboardCreateManyUserInputEnvelope
    set?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
    disconnect?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
    delete?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
    connect?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
    update?: DailyUserLeaderboardUpdateWithWhereUniqueWithoutUserInput | DailyUserLeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyUserLeaderboardUpdateManyWithWhereWithoutUserInput | DailyUserLeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyUserLeaderboardScalarWhereInput | DailyUserLeaderboardScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput> | UserCreateWithoutReferredByInput[] | UserUncheckedCreateWithoutReferredByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput | UserCreateOrConnectWithoutReferredByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferredByInput | UserUpsertWithWhereUniqueWithoutReferredByInput[]
    createMany?: UserCreateManyReferredByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferredByInput | UserUpdateWithWhereUniqueWithoutReferredByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferredByInput | UserUpdateManyWithWhereWithoutReferredByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutUserInput, DailyTournamentSessionUncheckedCreateWithoutUserInput> | DailyTournamentSessionCreateWithoutUserInput[] | DailyTournamentSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutUserInput | DailyTournamentSessionCreateOrConnectWithoutUserInput[]
    upsert?: DailyTournamentSessionUpsertWithWhereUniqueWithoutUserInput | DailyTournamentSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyTournamentSessionCreateManyUserInputEnvelope
    set?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    disconnect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    delete?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    connect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    update?: DailyTournamentSessionUpdateWithWhereUniqueWithoutUserInput | DailyTournamentSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyTournamentSessionUpdateManyWithWhereWithoutUserInput | DailyTournamentSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyTournamentSessionScalarWhereInput | DailyTournamentSessionScalarWhereInput[]
  }

  export type SoloSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SoloSessionCreateWithoutUserInput, SoloSessionUncheckedCreateWithoutUserInput> | SoloSessionCreateWithoutUserInput[] | SoloSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SoloSessionCreateOrConnectWithoutUserInput | SoloSessionCreateOrConnectWithoutUserInput[]
    upsert?: SoloSessionUpsertWithWhereUniqueWithoutUserInput | SoloSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SoloSessionCreateManyUserInputEnvelope
    set?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
    disconnect?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
    delete?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
    connect?: SoloSessionWhereUniqueInput | SoloSessionWhereUniqueInput[]
    update?: SoloSessionUpdateWithWhereUniqueWithoutUserInput | SoloSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SoloSessionUpdateManyWithWhereWithoutUserInput | SoloSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SoloSessionScalarWhereInput | SoloSessionScalarWhereInput[]
  }

  export type InstantSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstantSessionCreateWithoutUserInput, InstantSessionUncheckedCreateWithoutUserInput> | InstantSessionCreateWithoutUserInput[] | InstantSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantSessionCreateOrConnectWithoutUserInput | InstantSessionCreateOrConnectWithoutUserInput[]
    upsert?: InstantSessionUpsertWithWhereUniqueWithoutUserInput | InstantSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstantSessionCreateManyUserInputEnvelope
    set?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    disconnect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    delete?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    connect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    update?: InstantSessionUpdateWithWhereUniqueWithoutUserInput | InstantSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstantSessionUpdateManyWithWhereWithoutUserInput | InstantSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstantSessionScalarWhereInput | InstantSessionScalarWhereInput[]
  }

  export type InstantParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstantParticipantCreateWithoutUserInput, InstantParticipantUncheckedCreateWithoutUserInput> | InstantParticipantCreateWithoutUserInput[] | InstantParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantParticipantCreateOrConnectWithoutUserInput | InstantParticipantCreateOrConnectWithoutUserInput[]
    upsert?: InstantParticipantUpsertWithWhereUniqueWithoutUserInput | InstantParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstantParticipantCreateManyUserInputEnvelope
    set?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    disconnect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    delete?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    connect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    update?: InstantParticipantUpdateWithWhereUniqueWithoutUserInput | InstantParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstantParticipantUpdateManyWithWhereWithoutUserInput | InstantParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstantParticipantScalarWhereInput | InstantParticipantScalarWhereInput[]
  }

  export type DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyLeaderboardCreateWithoutUserInput, DailyLeaderboardUncheckedCreateWithoutUserInput> | DailyLeaderboardCreateWithoutUserInput[] | DailyLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyLeaderboardCreateOrConnectWithoutUserInput | DailyLeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: DailyLeaderboardUpsertWithWhereUniqueWithoutUserInput | DailyLeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyLeaderboardCreateManyUserInputEnvelope
    set?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
    disconnect?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
    delete?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
    connect?: DailyLeaderboardWhereUniqueInput | DailyLeaderboardWhereUniqueInput[]
    update?: DailyLeaderboardUpdateWithWhereUniqueWithoutUserInput | DailyLeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyLeaderboardUpdateManyWithWhereWithoutUserInput | DailyLeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyLeaderboardScalarWhereInput | DailyLeaderboardScalarWhereInput[]
  }

  export type InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstantLeaderboardCreateWithoutUserInput, InstantLeaderboardUncheckedCreateWithoutUserInput> | InstantLeaderboardCreateWithoutUserInput[] | InstantLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstantLeaderboardCreateOrConnectWithoutUserInput | InstantLeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: InstantLeaderboardUpsertWithWhereUniqueWithoutUserInput | InstantLeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstantLeaderboardCreateManyUserInputEnvelope
    set?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
    disconnect?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
    delete?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
    connect?: InstantLeaderboardWhereUniqueInput | InstantLeaderboardWhereUniqueInput[]
    update?: InstantLeaderboardUpdateWithWhereUniqueWithoutUserInput | InstantLeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstantLeaderboardUpdateManyWithWhereWithoutUserInput | InstantLeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstantLeaderboardScalarWhereInput | InstantLeaderboardScalarWhereInput[]
  }

  export type RewardClaimUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardClaimCreateWithoutUserInput, RewardClaimUncheckedCreateWithoutUserInput> | RewardClaimCreateWithoutUserInput[] | RewardClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardClaimCreateOrConnectWithoutUserInput | RewardClaimCreateOrConnectWithoutUserInput[]
    upsert?: RewardClaimUpsertWithWhereUniqueWithoutUserInput | RewardClaimUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardClaimCreateManyUserInputEnvelope
    set?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
    disconnect?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
    delete?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
    connect?: RewardClaimWhereUniqueInput | RewardClaimWhereUniqueInput[]
    update?: RewardClaimUpdateWithWhereUniqueWithoutUserInput | RewardClaimUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardClaimUpdateManyWithWhereWithoutUserInput | RewardClaimUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardClaimScalarWhereInput | RewardClaimScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput> | ReferralCreateWithoutRefereeInput[] | ReferralUncheckedCreateWithoutRefereeInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput | ReferralCreateOrConnectWithoutRefereeInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutRefereeInput | ReferralUpsertWithWhereUniqueWithoutRefereeInput[]
    createMany?: ReferralCreateManyRefereeInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutRefereeInput | ReferralUpdateWithWhereUniqueWithoutRefereeInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutRefereeInput | ReferralUpdateManyWithWhereWithoutRefereeInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type CoinLedgerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoinLedgerCreateWithoutUserInput, CoinLedgerUncheckedCreateWithoutUserInput> | CoinLedgerCreateWithoutUserInput[] | CoinLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoinLedgerCreateOrConnectWithoutUserInput | CoinLedgerCreateOrConnectWithoutUserInput[]
    upsert?: CoinLedgerUpsertWithWhereUniqueWithoutUserInput | CoinLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoinLedgerCreateManyUserInputEnvelope
    set?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
    disconnect?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
    delete?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
    connect?: CoinLedgerWhereUniqueInput | CoinLedgerWhereUniqueInput[]
    update?: CoinLedgerUpdateWithWhereUniqueWithoutUserInput | CoinLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoinLedgerUpdateManyWithWhereWithoutUserInput | CoinLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoinLedgerScalarWhereInput | CoinLedgerScalarWhereInput[]
  }

  export type DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyUserLeaderboardCreateWithoutUserInput, DailyUserLeaderboardUncheckedCreateWithoutUserInput> | DailyUserLeaderboardCreateWithoutUserInput[] | DailyUserLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyUserLeaderboardCreateOrConnectWithoutUserInput | DailyUserLeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: DailyUserLeaderboardUpsertWithWhereUniqueWithoutUserInput | DailyUserLeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyUserLeaderboardCreateManyUserInputEnvelope
    set?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
    disconnect?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
    delete?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
    connect?: DailyUserLeaderboardWhereUniqueInput | DailyUserLeaderboardWhereUniqueInput[]
    update?: DailyUserLeaderboardUpdateWithWhereUniqueWithoutUserInput | DailyUserLeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyUserLeaderboardUpdateManyWithWhereWithoutUserInput | DailyUserLeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyUserLeaderboardScalarWhereInput | DailyUserLeaderboardScalarWhereInput[]
  }

  export type MinuteSnapshotCreateNestedManyWithoutTournamentInput = {
    create?: XOR<MinuteSnapshotCreateWithoutTournamentInput, MinuteSnapshotUncheckedCreateWithoutTournamentInput> | MinuteSnapshotCreateWithoutTournamentInput[] | MinuteSnapshotUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: MinuteSnapshotCreateOrConnectWithoutTournamentInput | MinuteSnapshotCreateOrConnectWithoutTournamentInput[]
    createMany?: MinuteSnapshotCreateManyTournamentInputEnvelope
    connect?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
  }

  export type DailyTournamentSessionCreateNestedManyWithoutTournamentInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutTournamentInput, DailyTournamentSessionUncheckedCreateWithoutTournamentInput> | DailyTournamentSessionCreateWithoutTournamentInput[] | DailyTournamentSessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutTournamentInput | DailyTournamentSessionCreateOrConnectWithoutTournamentInput[]
    createMany?: DailyTournamentSessionCreateManyTournamentInputEnvelope
    connect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
  }

  export type MinuteSnapshotUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<MinuteSnapshotCreateWithoutTournamentInput, MinuteSnapshotUncheckedCreateWithoutTournamentInput> | MinuteSnapshotCreateWithoutTournamentInput[] | MinuteSnapshotUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: MinuteSnapshotCreateOrConnectWithoutTournamentInput | MinuteSnapshotCreateOrConnectWithoutTournamentInput[]
    createMany?: MinuteSnapshotCreateManyTournamentInputEnvelope
    connect?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
  }

  export type DailyTournamentSessionUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutTournamentInput, DailyTournamentSessionUncheckedCreateWithoutTournamentInput> | DailyTournamentSessionCreateWithoutTournamentInput[] | DailyTournamentSessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutTournamentInput | DailyTournamentSessionCreateOrConnectWithoutTournamentInput[]
    createMany?: DailyTournamentSessionCreateManyTournamentInputEnvelope
    connect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
  }

  export type EnumTournamentStatusFieldUpdateOperationsInput = {
    set?: $Enums.TournamentStatus
  }

  export type MinuteSnapshotUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<MinuteSnapshotCreateWithoutTournamentInput, MinuteSnapshotUncheckedCreateWithoutTournamentInput> | MinuteSnapshotCreateWithoutTournamentInput[] | MinuteSnapshotUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: MinuteSnapshotCreateOrConnectWithoutTournamentInput | MinuteSnapshotCreateOrConnectWithoutTournamentInput[]
    upsert?: MinuteSnapshotUpsertWithWhereUniqueWithoutTournamentInput | MinuteSnapshotUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: MinuteSnapshotCreateManyTournamentInputEnvelope
    set?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
    disconnect?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
    delete?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
    connect?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
    update?: MinuteSnapshotUpdateWithWhereUniqueWithoutTournamentInput | MinuteSnapshotUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: MinuteSnapshotUpdateManyWithWhereWithoutTournamentInput | MinuteSnapshotUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: MinuteSnapshotScalarWhereInput | MinuteSnapshotScalarWhereInput[]
  }

  export type DailyTournamentSessionUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutTournamentInput, DailyTournamentSessionUncheckedCreateWithoutTournamentInput> | DailyTournamentSessionCreateWithoutTournamentInput[] | DailyTournamentSessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutTournamentInput | DailyTournamentSessionCreateOrConnectWithoutTournamentInput[]
    upsert?: DailyTournamentSessionUpsertWithWhereUniqueWithoutTournamentInput | DailyTournamentSessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: DailyTournamentSessionCreateManyTournamentInputEnvelope
    set?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    disconnect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    delete?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    connect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    update?: DailyTournamentSessionUpdateWithWhereUniqueWithoutTournamentInput | DailyTournamentSessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: DailyTournamentSessionUpdateManyWithWhereWithoutTournamentInput | DailyTournamentSessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: DailyTournamentSessionScalarWhereInput | DailyTournamentSessionScalarWhereInput[]
  }

  export type MinuteSnapshotUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<MinuteSnapshotCreateWithoutTournamentInput, MinuteSnapshotUncheckedCreateWithoutTournamentInput> | MinuteSnapshotCreateWithoutTournamentInput[] | MinuteSnapshotUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: MinuteSnapshotCreateOrConnectWithoutTournamentInput | MinuteSnapshotCreateOrConnectWithoutTournamentInput[]
    upsert?: MinuteSnapshotUpsertWithWhereUniqueWithoutTournamentInput | MinuteSnapshotUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: MinuteSnapshotCreateManyTournamentInputEnvelope
    set?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
    disconnect?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
    delete?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
    connect?: MinuteSnapshotWhereUniqueInput | MinuteSnapshotWhereUniqueInput[]
    update?: MinuteSnapshotUpdateWithWhereUniqueWithoutTournamentInput | MinuteSnapshotUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: MinuteSnapshotUpdateManyWithWhereWithoutTournamentInput | MinuteSnapshotUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: MinuteSnapshotScalarWhereInput | MinuteSnapshotScalarWhereInput[]
  }

  export type DailyTournamentSessionUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutTournamentInput, DailyTournamentSessionUncheckedCreateWithoutTournamentInput> | DailyTournamentSessionCreateWithoutTournamentInput[] | DailyTournamentSessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutTournamentInput | DailyTournamentSessionCreateOrConnectWithoutTournamentInput[]
    upsert?: DailyTournamentSessionUpsertWithWhereUniqueWithoutTournamentInput | DailyTournamentSessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: DailyTournamentSessionCreateManyTournamentInputEnvelope
    set?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    disconnect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    delete?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    connect?: DailyTournamentSessionWhereUniqueInput | DailyTournamentSessionWhereUniqueInput[]
    update?: DailyTournamentSessionUpdateWithWhereUniqueWithoutTournamentInput | DailyTournamentSessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: DailyTournamentSessionUpdateManyWithWhereWithoutTournamentInput | DailyTournamentSessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: DailyTournamentSessionScalarWhereInput | DailyTournamentSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDailySessionsInput = {
    create?: XOR<UserCreateWithoutDailySessionsInput, UserUncheckedCreateWithoutDailySessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailySessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DailyTournamentCreateNestedOneWithoutSessionsInput = {
    create?: XOR<DailyTournamentCreateWithoutSessionsInput, DailyTournamentUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: DailyTournamentCreateOrConnectWithoutSessionsInput
    connect?: DailyTournamentWhereUniqueInput
  }

  export type QuestionAttemptCreateNestedManyWithoutDailySessionInput = {
    create?: XOR<QuestionAttemptCreateWithoutDailySessionInput, QuestionAttemptUncheckedCreateWithoutDailySessionInput> | QuestionAttemptCreateWithoutDailySessionInput[] | QuestionAttemptUncheckedCreateWithoutDailySessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutDailySessionInput | QuestionAttemptCreateOrConnectWithoutDailySessionInput[]
    createMany?: QuestionAttemptCreateManyDailySessionInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type QuestionAttemptUncheckedCreateNestedManyWithoutDailySessionInput = {
    create?: XOR<QuestionAttemptCreateWithoutDailySessionInput, QuestionAttemptUncheckedCreateWithoutDailySessionInput> | QuestionAttemptCreateWithoutDailySessionInput[] | QuestionAttemptUncheckedCreateWithoutDailySessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutDailySessionInput | QuestionAttemptCreateOrConnectWithoutDailySessionInput[]
    createMany?: QuestionAttemptCreateManyDailySessionInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type EnumUserTournamentStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserTournamentStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDailySessionsNestedInput = {
    create?: XOR<UserCreateWithoutDailySessionsInput, UserUncheckedCreateWithoutDailySessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailySessionsInput
    upsert?: UserUpsertWithoutDailySessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailySessionsInput, UserUpdateWithoutDailySessionsInput>, UserUncheckedUpdateWithoutDailySessionsInput>
  }

  export type DailyTournamentUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<DailyTournamentCreateWithoutSessionsInput, DailyTournamentUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: DailyTournamentCreateOrConnectWithoutSessionsInput
    upsert?: DailyTournamentUpsertWithoutSessionsInput
    connect?: DailyTournamentWhereUniqueInput
    update?: XOR<XOR<DailyTournamentUpdateToOneWithWhereWithoutSessionsInput, DailyTournamentUpdateWithoutSessionsInput>, DailyTournamentUncheckedUpdateWithoutSessionsInput>
  }

  export type QuestionAttemptUpdateManyWithoutDailySessionNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutDailySessionInput, QuestionAttemptUncheckedCreateWithoutDailySessionInput> | QuestionAttemptCreateWithoutDailySessionInput[] | QuestionAttemptUncheckedCreateWithoutDailySessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutDailySessionInput | QuestionAttemptCreateOrConnectWithoutDailySessionInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutDailySessionInput | QuestionAttemptUpsertWithWhereUniqueWithoutDailySessionInput[]
    createMany?: QuestionAttemptCreateManyDailySessionInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutDailySessionInput | QuestionAttemptUpdateWithWhereUniqueWithoutDailySessionInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutDailySessionInput | QuestionAttemptUpdateManyWithWhereWithoutDailySessionInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutDailySessionNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutDailySessionInput, QuestionAttemptUncheckedCreateWithoutDailySessionInput> | QuestionAttemptCreateWithoutDailySessionInput[] | QuestionAttemptUncheckedCreateWithoutDailySessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutDailySessionInput | QuestionAttemptCreateOrConnectWithoutDailySessionInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutDailySessionInput | QuestionAttemptUpsertWithWhereUniqueWithoutDailySessionInput[]
    createMany?: QuestionAttemptCreateManyDailySessionInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutDailySessionInput | QuestionAttemptUpdateWithWhereUniqueWithoutDailySessionInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutDailySessionInput | QuestionAttemptUpdateManyWithWhereWithoutDailySessionInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type DailyTournamentCreateNestedOneWithoutMinuteSnapshotInput = {
    create?: XOR<DailyTournamentCreateWithoutMinuteSnapshotInput, DailyTournamentUncheckedCreateWithoutMinuteSnapshotInput>
    connectOrCreate?: DailyTournamentCreateOrConnectWithoutMinuteSnapshotInput
    connect?: DailyTournamentWhereUniqueInput
  }

  export type DailyTournamentUpdateOneRequiredWithoutMinuteSnapshotNestedInput = {
    create?: XOR<DailyTournamentCreateWithoutMinuteSnapshotInput, DailyTournamentUncheckedCreateWithoutMinuteSnapshotInput>
    connectOrCreate?: DailyTournamentCreateOrConnectWithoutMinuteSnapshotInput
    upsert?: DailyTournamentUpsertWithoutMinuteSnapshotInput
    connect?: DailyTournamentWhereUniqueInput
    update?: XOR<XOR<DailyTournamentUpdateToOneWithWhereWithoutMinuteSnapshotInput, DailyTournamentUpdateWithoutMinuteSnapshotInput>, DailyTournamentUncheckedUpdateWithoutMinuteSnapshotInput>
  }

  export type UserCreateNestedOneWithoutSoloSessionsInput = {
    create?: XOR<UserCreateWithoutSoloSessionsInput, UserUncheckedCreateWithoutSoloSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoloSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionAttemptCreateNestedManyWithoutSoloSessionInput = {
    create?: XOR<QuestionAttemptCreateWithoutSoloSessionInput, QuestionAttemptUncheckedCreateWithoutSoloSessionInput> | QuestionAttemptCreateWithoutSoloSessionInput[] | QuestionAttemptUncheckedCreateWithoutSoloSessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutSoloSessionInput | QuestionAttemptCreateOrConnectWithoutSoloSessionInput[]
    createMany?: QuestionAttemptCreateManySoloSessionInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type QuestionAttemptUncheckedCreateNestedManyWithoutSoloSessionInput = {
    create?: XOR<QuestionAttemptCreateWithoutSoloSessionInput, QuestionAttemptUncheckedCreateWithoutSoloSessionInput> | QuestionAttemptCreateWithoutSoloSessionInput[] | QuestionAttemptUncheckedCreateWithoutSoloSessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutSoloSessionInput | QuestionAttemptCreateOrConnectWithoutSoloSessionInput[]
    createMany?: QuestionAttemptCreateManySoloSessionInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSoloSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSoloSessionsInput, UserUncheckedCreateWithoutSoloSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSoloSessionsInput
    upsert?: UserUpsertWithoutSoloSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSoloSessionsInput, UserUpdateWithoutSoloSessionsInput>, UserUncheckedUpdateWithoutSoloSessionsInput>
  }

  export type QuestionAttemptUpdateManyWithoutSoloSessionNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutSoloSessionInput, QuestionAttemptUncheckedCreateWithoutSoloSessionInput> | QuestionAttemptCreateWithoutSoloSessionInput[] | QuestionAttemptUncheckedCreateWithoutSoloSessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutSoloSessionInput | QuestionAttemptCreateOrConnectWithoutSoloSessionInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutSoloSessionInput | QuestionAttemptUpsertWithWhereUniqueWithoutSoloSessionInput[]
    createMany?: QuestionAttemptCreateManySoloSessionInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutSoloSessionInput | QuestionAttemptUpdateWithWhereUniqueWithoutSoloSessionInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutSoloSessionInput | QuestionAttemptUpdateManyWithWhereWithoutSoloSessionInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutSoloSessionNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutSoloSessionInput, QuestionAttemptUncheckedCreateWithoutSoloSessionInput> | QuestionAttemptCreateWithoutSoloSessionInput[] | QuestionAttemptUncheckedCreateWithoutSoloSessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutSoloSessionInput | QuestionAttemptCreateOrConnectWithoutSoloSessionInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutSoloSessionInput | QuestionAttemptUpsertWithWhereUniqueWithoutSoloSessionInput[]
    createMany?: QuestionAttemptCreateManySoloSessionInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutSoloSessionInput | QuestionAttemptUpdateWithWhereUniqueWithoutSoloSessionInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutSoloSessionInput | QuestionAttemptUpdateManyWithWhereWithoutSoloSessionInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type DailyTournamentSessionCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutQuestionsInput, DailyTournamentSessionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutQuestionsInput
    connect?: DailyTournamentSessionWhereUniqueInput
  }

  export type SoloSessionCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<SoloSessionCreateWithoutQuestionsInput, SoloSessionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: SoloSessionCreateOrConnectWithoutQuestionsInput
    connect?: SoloSessionWhereUniqueInput
  }

  export type InstantSessionCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<InstantSessionCreateWithoutQuestionsInput, InstantSessionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: InstantSessionCreateOrConnectWithoutQuestionsInput
    connect?: InstantSessionWhereUniqueInput
  }

  export type DailyTournamentSessionUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<DailyTournamentSessionCreateWithoutQuestionsInput, DailyTournamentSessionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: DailyTournamentSessionCreateOrConnectWithoutQuestionsInput
    upsert?: DailyTournamentSessionUpsertWithoutQuestionsInput
    disconnect?: DailyTournamentSessionWhereInput | boolean
    delete?: DailyTournamentSessionWhereInput | boolean
    connect?: DailyTournamentSessionWhereUniqueInput
    update?: XOR<XOR<DailyTournamentSessionUpdateToOneWithWhereWithoutQuestionsInput, DailyTournamentSessionUpdateWithoutQuestionsInput>, DailyTournamentSessionUncheckedUpdateWithoutQuestionsInput>
  }

  export type SoloSessionUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<SoloSessionCreateWithoutQuestionsInput, SoloSessionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: SoloSessionCreateOrConnectWithoutQuestionsInput
    upsert?: SoloSessionUpsertWithoutQuestionsInput
    disconnect?: SoloSessionWhereInput | boolean
    delete?: SoloSessionWhereInput | boolean
    connect?: SoloSessionWhereUniqueInput
    update?: XOR<XOR<SoloSessionUpdateToOneWithWhereWithoutQuestionsInput, SoloSessionUpdateWithoutQuestionsInput>, SoloSessionUncheckedUpdateWithoutQuestionsInput>
  }

  export type InstantSessionUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<InstantSessionCreateWithoutQuestionsInput, InstantSessionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: InstantSessionCreateOrConnectWithoutQuestionsInput
    upsert?: InstantSessionUpsertWithoutQuestionsInput
    disconnect?: InstantSessionWhereInput | boolean
    delete?: InstantSessionWhereInput | boolean
    connect?: InstantSessionWhereUniqueInput
    update?: XOR<XOR<InstantSessionUpdateToOneWithWhereWithoutQuestionsInput, InstantSessionUpdateWithoutQuestionsInput>, InstantSessionUncheckedUpdateWithoutQuestionsInput>
  }

  export type InstantSessionCreateNestedManyWithoutTournamentInput = {
    create?: XOR<InstantSessionCreateWithoutTournamentInput, InstantSessionUncheckedCreateWithoutTournamentInput> | InstantSessionCreateWithoutTournamentInput[] | InstantSessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: InstantSessionCreateOrConnectWithoutTournamentInput | InstantSessionCreateOrConnectWithoutTournamentInput[]
    createMany?: InstantSessionCreateManyTournamentInputEnvelope
    connect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
  }

  export type InstantParticipantCreateNestedManyWithoutTournamentInput = {
    create?: XOR<InstantParticipantCreateWithoutTournamentInput, InstantParticipantUncheckedCreateWithoutTournamentInput> | InstantParticipantCreateWithoutTournamentInput[] | InstantParticipantUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: InstantParticipantCreateOrConnectWithoutTournamentInput | InstantParticipantCreateOrConnectWithoutTournamentInput[]
    createMany?: InstantParticipantCreateManyTournamentInputEnvelope
    connect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
  }

  export type InstantSessionUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<InstantSessionCreateWithoutTournamentInput, InstantSessionUncheckedCreateWithoutTournamentInput> | InstantSessionCreateWithoutTournamentInput[] | InstantSessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: InstantSessionCreateOrConnectWithoutTournamentInput | InstantSessionCreateOrConnectWithoutTournamentInput[]
    createMany?: InstantSessionCreateManyTournamentInputEnvelope
    connect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
  }

  export type InstantParticipantUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<InstantParticipantCreateWithoutTournamentInput, InstantParticipantUncheckedCreateWithoutTournamentInput> | InstantParticipantCreateWithoutTournamentInput[] | InstantParticipantUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: InstantParticipantCreateOrConnectWithoutTournamentInput | InstantParticipantCreateOrConnectWithoutTournamentInput[]
    createMany?: InstantParticipantCreateManyTournamentInputEnvelope
    connect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
  }

  export type InstantSessionUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<InstantSessionCreateWithoutTournamentInput, InstantSessionUncheckedCreateWithoutTournamentInput> | InstantSessionCreateWithoutTournamentInput[] | InstantSessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: InstantSessionCreateOrConnectWithoutTournamentInput | InstantSessionCreateOrConnectWithoutTournamentInput[]
    upsert?: InstantSessionUpsertWithWhereUniqueWithoutTournamentInput | InstantSessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: InstantSessionCreateManyTournamentInputEnvelope
    set?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    disconnect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    delete?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    connect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    update?: InstantSessionUpdateWithWhereUniqueWithoutTournamentInput | InstantSessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: InstantSessionUpdateManyWithWhereWithoutTournamentInput | InstantSessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: InstantSessionScalarWhereInput | InstantSessionScalarWhereInput[]
  }

  export type InstantParticipantUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<InstantParticipantCreateWithoutTournamentInput, InstantParticipantUncheckedCreateWithoutTournamentInput> | InstantParticipantCreateWithoutTournamentInput[] | InstantParticipantUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: InstantParticipantCreateOrConnectWithoutTournamentInput | InstantParticipantCreateOrConnectWithoutTournamentInput[]
    upsert?: InstantParticipantUpsertWithWhereUniqueWithoutTournamentInput | InstantParticipantUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: InstantParticipantCreateManyTournamentInputEnvelope
    set?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    disconnect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    delete?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    connect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    update?: InstantParticipantUpdateWithWhereUniqueWithoutTournamentInput | InstantParticipantUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: InstantParticipantUpdateManyWithWhereWithoutTournamentInput | InstantParticipantUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: InstantParticipantScalarWhereInput | InstantParticipantScalarWhereInput[]
  }

  export type InstantSessionUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<InstantSessionCreateWithoutTournamentInput, InstantSessionUncheckedCreateWithoutTournamentInput> | InstantSessionCreateWithoutTournamentInput[] | InstantSessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: InstantSessionCreateOrConnectWithoutTournamentInput | InstantSessionCreateOrConnectWithoutTournamentInput[]
    upsert?: InstantSessionUpsertWithWhereUniqueWithoutTournamentInput | InstantSessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: InstantSessionCreateManyTournamentInputEnvelope
    set?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    disconnect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    delete?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    connect?: InstantSessionWhereUniqueInput | InstantSessionWhereUniqueInput[]
    update?: InstantSessionUpdateWithWhereUniqueWithoutTournamentInput | InstantSessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: InstantSessionUpdateManyWithWhereWithoutTournamentInput | InstantSessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: InstantSessionScalarWhereInput | InstantSessionScalarWhereInput[]
  }

  export type InstantParticipantUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<InstantParticipantCreateWithoutTournamentInput, InstantParticipantUncheckedCreateWithoutTournamentInput> | InstantParticipantCreateWithoutTournamentInput[] | InstantParticipantUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: InstantParticipantCreateOrConnectWithoutTournamentInput | InstantParticipantCreateOrConnectWithoutTournamentInput[]
    upsert?: InstantParticipantUpsertWithWhereUniqueWithoutTournamentInput | InstantParticipantUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: InstantParticipantCreateManyTournamentInputEnvelope
    set?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    disconnect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    delete?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    connect?: InstantParticipantWhereUniqueInput | InstantParticipantWhereUniqueInput[]
    update?: InstantParticipantUpdateWithWhereUniqueWithoutTournamentInput | InstantParticipantUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: InstantParticipantUpdateManyWithWhereWithoutTournamentInput | InstantParticipantUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: InstantParticipantScalarWhereInput | InstantParticipantScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInstantSessionsInput = {
    create?: XOR<UserCreateWithoutInstantSessionsInput, UserUncheckedCreateWithoutInstantSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstantSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type InstantTournamentCreateNestedOneWithoutSessionsInput = {
    create?: XOR<InstantTournamentCreateWithoutSessionsInput, InstantTournamentUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: InstantTournamentCreateOrConnectWithoutSessionsInput
    connect?: InstantTournamentWhereUniqueInput
  }

  export type QuestionAttemptCreateNestedManyWithoutInstantSessionInput = {
    create?: XOR<QuestionAttemptCreateWithoutInstantSessionInput, QuestionAttemptUncheckedCreateWithoutInstantSessionInput> | QuestionAttemptCreateWithoutInstantSessionInput[] | QuestionAttemptUncheckedCreateWithoutInstantSessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutInstantSessionInput | QuestionAttemptCreateOrConnectWithoutInstantSessionInput[]
    createMany?: QuestionAttemptCreateManyInstantSessionInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type QuestionAttemptUncheckedCreateNestedManyWithoutInstantSessionInput = {
    create?: XOR<QuestionAttemptCreateWithoutInstantSessionInput, QuestionAttemptUncheckedCreateWithoutInstantSessionInput> | QuestionAttemptCreateWithoutInstantSessionInput[] | QuestionAttemptUncheckedCreateWithoutInstantSessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutInstantSessionInput | QuestionAttemptCreateOrConnectWithoutInstantSessionInput[]
    createMany?: QuestionAttemptCreateManyInstantSessionInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type EnumInstantTournamentSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.InstantTournamentSessionStatus
  }

  export type UserUpdateOneRequiredWithoutInstantSessionsNestedInput = {
    create?: XOR<UserCreateWithoutInstantSessionsInput, UserUncheckedCreateWithoutInstantSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstantSessionsInput
    upsert?: UserUpsertWithoutInstantSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstantSessionsInput, UserUpdateWithoutInstantSessionsInput>, UserUncheckedUpdateWithoutInstantSessionsInput>
  }

  export type InstantTournamentUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<InstantTournamentCreateWithoutSessionsInput, InstantTournamentUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: InstantTournamentCreateOrConnectWithoutSessionsInput
    upsert?: InstantTournamentUpsertWithoutSessionsInput
    connect?: InstantTournamentWhereUniqueInput
    update?: XOR<XOR<InstantTournamentUpdateToOneWithWhereWithoutSessionsInput, InstantTournamentUpdateWithoutSessionsInput>, InstantTournamentUncheckedUpdateWithoutSessionsInput>
  }

  export type QuestionAttemptUpdateManyWithoutInstantSessionNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutInstantSessionInput, QuestionAttemptUncheckedCreateWithoutInstantSessionInput> | QuestionAttemptCreateWithoutInstantSessionInput[] | QuestionAttemptUncheckedCreateWithoutInstantSessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutInstantSessionInput | QuestionAttemptCreateOrConnectWithoutInstantSessionInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutInstantSessionInput | QuestionAttemptUpsertWithWhereUniqueWithoutInstantSessionInput[]
    createMany?: QuestionAttemptCreateManyInstantSessionInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutInstantSessionInput | QuestionAttemptUpdateWithWhereUniqueWithoutInstantSessionInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutInstantSessionInput | QuestionAttemptUpdateManyWithWhereWithoutInstantSessionInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutInstantSessionNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutInstantSessionInput, QuestionAttemptUncheckedCreateWithoutInstantSessionInput> | QuestionAttemptCreateWithoutInstantSessionInput[] | QuestionAttemptUncheckedCreateWithoutInstantSessionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutInstantSessionInput | QuestionAttemptCreateOrConnectWithoutInstantSessionInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutInstantSessionInput | QuestionAttemptUpsertWithWhereUniqueWithoutInstantSessionInput[]
    createMany?: QuestionAttemptCreateManyInstantSessionInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutInstantSessionInput | QuestionAttemptUpdateWithWhereUniqueWithoutInstantSessionInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutInstantSessionInput | QuestionAttemptUpdateManyWithWhereWithoutInstantSessionInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type InstantTournamentCreateNestedOneWithoutInstantParticipantInput = {
    create?: XOR<InstantTournamentCreateWithoutInstantParticipantInput, InstantTournamentUncheckedCreateWithoutInstantParticipantInput>
    connectOrCreate?: InstantTournamentCreateOrConnectWithoutInstantParticipantInput
    connect?: InstantTournamentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInstantParticipantInput = {
    create?: XOR<UserCreateWithoutInstantParticipantInput, UserUncheckedCreateWithoutInstantParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstantParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type InstantTournamentUpdateOneRequiredWithoutInstantParticipantNestedInput = {
    create?: XOR<InstantTournamentCreateWithoutInstantParticipantInput, InstantTournamentUncheckedCreateWithoutInstantParticipantInput>
    connectOrCreate?: InstantTournamentCreateOrConnectWithoutInstantParticipantInput
    upsert?: InstantTournamentUpsertWithoutInstantParticipantInput
    connect?: InstantTournamentWhereUniqueInput
    update?: XOR<XOR<InstantTournamentUpdateToOneWithWhereWithoutInstantParticipantInput, InstantTournamentUpdateWithoutInstantParticipantInput>, InstantTournamentUncheckedUpdateWithoutInstantParticipantInput>
  }

  export type UserUpdateOneRequiredWithoutInstantParticipantNestedInput = {
    create?: XOR<UserCreateWithoutInstantParticipantInput, UserUncheckedCreateWithoutInstantParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstantParticipantInput
    upsert?: UserUpsertWithoutInstantParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstantParticipantInput, UserUpdateWithoutInstantParticipantInput>, UserUncheckedUpdateWithoutInstantParticipantInput>
  }

  export type UserCreateNestedOneWithoutDailyLeaderBoardsInput = {
    create?: XOR<UserCreateWithoutDailyLeaderBoardsInput, UserUncheckedCreateWithoutDailyLeaderBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyLeaderBoardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyLeaderBoardsNestedInput = {
    create?: XOR<UserCreateWithoutDailyLeaderBoardsInput, UserUncheckedCreateWithoutDailyLeaderBoardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyLeaderBoardsInput
    upsert?: UserUpsertWithoutDailyLeaderBoardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyLeaderBoardsInput, UserUpdateWithoutDailyLeaderBoardsInput>, UserUncheckedUpdateWithoutDailyLeaderBoardsInput>
  }

  export type UserCreateNestedOneWithoutInstantLeaderboardInput = {
    create?: XOR<UserCreateWithoutInstantLeaderboardInput, UserUncheckedCreateWithoutInstantLeaderboardInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstantLeaderboardInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutInstantLeaderboardNestedInput = {
    create?: XOR<UserCreateWithoutInstantLeaderboardInput, UserUncheckedCreateWithoutInstantLeaderboardInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstantLeaderboardInput
    upsert?: UserUpsertWithoutInstantLeaderboardInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstantLeaderboardInput, UserUpdateWithoutInstantLeaderboardInput>, UserUncheckedUpdateWithoutInstantLeaderboardInput>
  }

  export type UserCreateNestedOneWithoutDailyUserLeaderboardInput = {
    create?: XOR<UserCreateWithoutDailyUserLeaderboardInput, UserUncheckedCreateWithoutDailyUserLeaderboardInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyUserLeaderboardInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyUserLeaderboardNestedInput = {
    create?: XOR<UserCreateWithoutDailyUserLeaderboardInput, UserUncheckedCreateWithoutDailyUserLeaderboardInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyUserLeaderboardInput
    upsert?: UserUpsertWithoutDailyUserLeaderboardInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyUserLeaderboardInput, UserUpdateWithoutDailyUserLeaderboardInput>, UserUncheckedUpdateWithoutDailyUserLeaderboardInput>
  }

  export type UserCreateNestedOneWithoutRewardClaimInput = {
    create?: XOR<UserCreateWithoutRewardClaimInput, UserUncheckedCreateWithoutRewardClaimInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardClaimInput
    connect?: UserWhereUniqueInput
  }

  export type EnumClaimStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClaimStatus
  }

  export type UserUpdateOneRequiredWithoutRewardClaimNestedInput = {
    create?: XOR<UserCreateWithoutRewardClaimInput, UserUncheckedCreateWithoutRewardClaimInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardClaimInput
    upsert?: UserUpsertWithoutRewardClaimInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRewardClaimInput, UserUpdateWithoutRewardClaimInput>, UserUncheckedUpdateWithoutRewardClaimInput>
  }

  export type UserCreateNestedOneWithoutReferralsGivenInput = {
    create?: XOR<UserCreateWithoutReferralsGivenInput, UserUncheckedCreateWithoutReferralsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralsReceivedInput = {
    create?: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReferralStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReferralStatus
  }

  export type UserUpdateOneRequiredWithoutReferralsGivenNestedInput = {
    create?: XOR<UserCreateWithoutReferralsGivenInput, UserUncheckedCreateWithoutReferralsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsGivenInput
    upsert?: UserUpsertWithoutReferralsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsGivenInput, UserUpdateWithoutReferralsGivenInput>, UserUncheckedUpdateWithoutReferralsGivenInput>
  }

  export type UserUpdateOneWithoutReferralsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsReceivedInput
    upsert?: UserUpsertWithoutReferralsReceivedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsReceivedInput, UserUpdateWithoutReferralsReceivedInput>, UserUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type UserCreateNestedOneWithoutCoinLedgerInput = {
    create?: XOR<UserCreateWithoutCoinLedgerInput, UserUncheckedCreateWithoutCoinLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoinLedgerInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCoinLedgerSourceFieldUpdateOperationsInput = {
    set?: $Enums.CoinLedgerSource
  }

  export type UserUpdateOneRequiredWithoutCoinLedgerNestedInput = {
    create?: XOR<UserCreateWithoutCoinLedgerInput, UserUncheckedCreateWithoutCoinLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoinLedgerInput
    upsert?: UserUpsertWithoutCoinLedgerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoinLedgerInput, UserUpdateWithoutCoinLedgerInput>, UserUncheckedUpdateWithoutCoinLedgerInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumAvatarTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AvatarType | EnumAvatarTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvatarType[] | ListEnumAvatarTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvatarType[] | ListEnumAvatarTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvatarTypeFilter<$PrismaModel> | $Enums.AvatarType
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumThemeFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeFilter<$PrismaModel> | $Enums.Theme
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAvatarTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvatarType | EnumAvatarTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvatarType[] | ListEnumAvatarTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvatarType[] | ListEnumAvatarTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvatarTypeWithAggregatesFilter<$PrismaModel> | $Enums.AvatarType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvatarTypeFilter<$PrismaModel>
    _max?: NestedEnumAvatarTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumThemeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Theme | EnumThemeFieldRefInput<$PrismaModel>
    in?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Theme[] | ListEnumThemeFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeWithAggregatesFilter<$PrismaModel> | $Enums.Theme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThemeFilter<$PrismaModel>
    _max?: NestedEnumThemeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusFilter<$PrismaModel> | $Enums.TournamentStatus
  }

  export type NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TournamentStatus | EnumTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TournamentStatus[] | ListEnumTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.TournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumTournamentStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserTournamentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTournamentStatus | EnumUserTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserTournamentStatus[] | ListEnumUserTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTournamentStatus[] | ListEnumUserTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTournamentStatusFilter<$PrismaModel> | $Enums.UserTournamentStatus
  }

  export type NestedEnumUserTournamentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserTournamentStatus | EnumUserTournamentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserTournamentStatus[] | ListEnumUserTournamentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserTournamentStatus[] | ListEnumUserTournamentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTournamentStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserTournamentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTournamentStatusFilter<$PrismaModel>
    _max?: NestedEnumUserTournamentStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumInstantTournamentSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstantTournamentSessionStatus | EnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstantTournamentSessionStatus[] | ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstantTournamentSessionStatus[] | ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstantTournamentSessionStatusFilter<$PrismaModel> | $Enums.InstantTournamentSessionStatus
  }

  export type NestedEnumInstantTournamentSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstantTournamentSessionStatus | EnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstantTournamentSessionStatus[] | ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstantTournamentSessionStatus[] | ListEnumInstantTournamentSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstantTournamentSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstantTournamentSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstantTournamentSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumInstantTournamentSessionStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type NestedEnumReferralStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralStatus | EnumReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralStatusFilter<$PrismaModel> | $Enums.ReferralStatus
  }

  export type NestedEnumReferralStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReferralStatus | EnumReferralStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReferralStatus[] | ListEnumReferralStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReferralStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReferralStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReferralStatusFilter<$PrismaModel>
    _max?: NestedEnumReferralStatusFilter<$PrismaModel>
  }

  export type NestedEnumCoinLedgerSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.CoinLedgerSource | EnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CoinLedgerSource[] | ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoinLedgerSource[] | ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCoinLedgerSourceFilter<$PrismaModel> | $Enums.CoinLedgerSource
  }

  export type NestedEnumCoinLedgerSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoinLedgerSource | EnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CoinLedgerSource[] | ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoinLedgerSource[] | ListEnumCoinLedgerSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCoinLedgerSourceWithAggregatesFilter<$PrismaModel> | $Enums.CoinLedgerSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoinLedgerSourceFilter<$PrismaModel>
    _max?: NestedEnumCoinLedgerSourceFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserCreateManyReferredByInputEnvelope = {
    data: UserCreateManyReferredByInput | UserCreateManyReferredByInput[]
    skipDuplicates?: boolean
  }

  export type DailyTournamentSessionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
    tournament: DailyTournamentCreateNestedOneWithoutSessionsInput
    questions?: QuestionAttemptCreateNestedManyWithoutDailySessionInput
  }

  export type DailyTournamentSessionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentId: string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
    questions?: QuestionAttemptUncheckedCreateNestedManyWithoutDailySessionInput
  }

  export type DailyTournamentSessionCreateOrConnectWithoutUserInput = {
    where: DailyTournamentSessionWhereUniqueInput
    create: XOR<DailyTournamentSessionCreateWithoutUserInput, DailyTournamentSessionUncheckedCreateWithoutUserInput>
  }

  export type DailyTournamentSessionCreateManyUserInputEnvelope = {
    data: DailyTournamentSessionCreateManyUserInput | DailyTournamentSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SoloSessionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentRound?: number
    bankedPoints?: number
    finalScore?: number | null
    coinPointsEarned?: number
    isFreeAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    madeMistake?: boolean
    quitEarly?: boolean
    questions?: QuestionAttemptCreateNestedManyWithoutSoloSessionInput
  }

  export type SoloSessionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentRound?: number
    bankedPoints?: number
    finalScore?: number | null
    coinPointsEarned?: number
    isFreeAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    madeMistake?: boolean
    quitEarly?: boolean
    questions?: QuestionAttemptUncheckedCreateNestedManyWithoutSoloSessionInput
  }

  export type SoloSessionCreateOrConnectWithoutUserInput = {
    where: SoloSessionWhereUniqueInput
    create: XOR<SoloSessionCreateWithoutUserInput, SoloSessionUncheckedCreateWithoutUserInput>
  }

  export type SoloSessionCreateManyUserInputEnvelope = {
    data: SoloSessionCreateManyUserInput | SoloSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InstantSessionCreateWithoutUserInput = {
    id?: string
    status?: $Enums.InstantTournamentSessionStatus
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
    tournament: InstantTournamentCreateNestedOneWithoutSessionsInput
    questions?: QuestionAttemptCreateNestedManyWithoutInstantSessionInput
  }

  export type InstantSessionUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.InstantTournamentSessionStatus
    tournamentId: string
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
    questions?: QuestionAttemptUncheckedCreateNestedManyWithoutInstantSessionInput
  }

  export type InstantSessionCreateOrConnectWithoutUserInput = {
    where: InstantSessionWhereUniqueInput
    create: XOR<InstantSessionCreateWithoutUserInput, InstantSessionUncheckedCreateWithoutUserInput>
  }

  export type InstantSessionCreateManyUserInputEnvelope = {
    data: InstantSessionCreateManyUserInput | InstantSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InstantParticipantCreateWithoutUserInput = {
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
    tournament: InstantTournamentCreateNestedOneWithoutInstantParticipantInput
  }

  export type InstantParticipantUncheckedCreateWithoutUserInput = {
    tournamentId: string
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
  }

  export type InstantParticipantCreateOrConnectWithoutUserInput = {
    where: InstantParticipantWhereUniqueInput
    create: XOR<InstantParticipantCreateWithoutUserInput, InstantParticipantUncheckedCreateWithoutUserInput>
  }

  export type InstantParticipantCreateManyUserInputEnvelope = {
    data: InstantParticipantCreateManyUserInput | InstantParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyLeaderboardCreateWithoutUserInput = {
    id?: string
    date: Date | string
    bestScore?: number
    rank?: number
    coinPoints?: number
    updatedAt?: Date | string
  }

  export type DailyLeaderboardUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    bestScore?: number
    rank?: number
    coinPoints?: number
    updatedAt?: Date | string
  }

  export type DailyLeaderboardCreateOrConnectWithoutUserInput = {
    where: DailyLeaderboardWhereUniqueInput
    create: XOR<DailyLeaderboardCreateWithoutUserInput, DailyLeaderboardUncheckedCreateWithoutUserInput>
  }

  export type DailyLeaderboardCreateManyUserInputEnvelope = {
    data: DailyLeaderboardCreateManyUserInput | DailyLeaderboardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InstantLeaderboardCreateWithoutUserInput = {
    id?: string
    tournamentId: string
    bestScore?: number
    rank?: number
    coinPoints: Decimal | DecimalJsLike | number | string
    submittedAt: Date | string
    updatedAt?: Date | string
    date?: Date | string
  }

  export type InstantLeaderboardUncheckedCreateWithoutUserInput = {
    id?: string
    tournamentId: string
    bestScore?: number
    rank?: number
    coinPoints: Decimal | DecimalJsLike | number | string
    submittedAt: Date | string
    updatedAt?: Date | string
    date?: Date | string
  }

  export type InstantLeaderboardCreateOrConnectWithoutUserInput = {
    where: InstantLeaderboardWhereUniqueInput
    create: XOR<InstantLeaderboardCreateWithoutUserInput, InstantLeaderboardUncheckedCreateWithoutUserInput>
  }

  export type InstantLeaderboardCreateManyUserInputEnvelope = {
    data: InstantLeaderboardCreateManyUserInput | InstantLeaderboardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RewardClaimCreateWithoutUserInput = {
    id?: string
    coinsLocked: number
    status?: $Enums.ClaimStatus
    voucherCode?: string | null
    adminNotes?: string | null
    fulfilledBy?: string | null
    fulfilledAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardClaimUncheckedCreateWithoutUserInput = {
    id?: string
    coinsLocked: number
    status?: $Enums.ClaimStatus
    voucherCode?: string | null
    adminNotes?: string | null
    fulfilledBy?: string | null
    fulfilledAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RewardClaimCreateOrConnectWithoutUserInput = {
    where: RewardClaimWhereUniqueInput
    create: XOR<RewardClaimCreateWithoutUserInput, RewardClaimUncheckedCreateWithoutUserInput>
  }

  export type RewardClaimCreateManyUserInputEnvelope = {
    data: RewardClaimCreateManyUserInput | RewardClaimCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referee?: UserCreateNestedOneWithoutReferralsReceivedInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    refereeId?: string | null
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutRefereeInput = {
    id?: string
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsGivenInput
  }

  export type ReferralUncheckedCreateWithoutRefereeInput = {
    id?: string
    referrerId: string
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralCreateManyRefereeInputEnvelope = {
    data: ReferralCreateManyRefereeInput | ReferralCreateManyRefereeInput[]
    skipDuplicates?: boolean
  }

  export type CoinLedgerCreateWithoutUserInput = {
    id?: string
    date: Date | string
    delta: number
    source: $Enums.CoinLedgerSource
    referenceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CoinLedgerUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    delta: number
    source: $Enums.CoinLedgerSource
    referenceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CoinLedgerCreateOrConnectWithoutUserInput = {
    where: CoinLedgerWhereUniqueInput
    create: XOR<CoinLedgerCreateWithoutUserInput, CoinLedgerUncheckedCreateWithoutUserInput>
  }

  export type CoinLedgerCreateManyUserInputEnvelope = {
    data: CoinLedgerCreateManyUserInput | CoinLedgerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyUserLeaderboardCreateWithoutUserInput = {
    id?: string
    date: Date | string
    dailyCoinPoints?: number
    instantCoinPoints?: Decimal | DecimalJsLike | number | string
    totalCoinPoints?: Decimal | DecimalJsLike | number | string
    rank?: number
    isEligible?: boolean
    coinsAwarded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyUserLeaderboardUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    dailyCoinPoints?: number
    instantCoinPoints?: Decimal | DecimalJsLike | number | string
    totalCoinPoints?: Decimal | DecimalJsLike | number | string
    rank?: number
    isEligible?: boolean
    coinsAwarded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyUserLeaderboardCreateOrConnectWithoutUserInput = {
    where: DailyUserLeaderboardWhereUniqueInput
    create: XOR<DailyUserLeaderboardCreateWithoutUserInput, DailyUserLeaderboardUncheckedCreateWithoutUserInput>
  }

  export type DailyUserLeaderboardCreateManyUserInputEnvelope = {
    data: DailyUserLeaderboardCreateManyUserInput | DailyUserLeaderboardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferredByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserUpdateManyWithWhereWithoutReferredByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferredByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    googleId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    deviceHash?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    usernameReservedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    avatarType?: EnumAvatarTypeFilter<"User"> | $Enums.AvatarType
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    coins?: IntFilter<"User"> | number
    lifetimeCoins?: IntFilter<"User"> | number
    lifetimeCoinPoints?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    theme?: EnumThemeFilter<"User"> | $Enums.Theme
    soundEnabled?: BoolFilter<"User"> | boolean
    hapticsEnabled?: BoolFilter<"User"> | boolean
    language?: StringFilter<"User"> | string
    referralCode?: StringNullableFilter<"User"> | string | null
    referredById?: StringNullableFilter<"User"> | string | null
    referralRewarded?: BoolFilter<"User"> | boolean
    role?: EnumRoleFilter<"User"> | $Enums.Role
    soloAttemptCount?: IntFilter<"User"> | number
    instantAttemptCount?: IntFilter<"User"> | number
    dailyAttemptCount?: IntFilter<"User"> | number
    currentLoginStreak?: IntFilter<"User"> | number
    longestLoginStreak?: IntFilter<"User"> | number
    lastLoginRewardDate?: DateTimeNullableFilter<"User"> | Date | string | null
    totalLoginDays?: IntFilter<"User"> | number
  }

  export type DailyTournamentSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyTournamentSessionWhereUniqueInput
    update: XOR<DailyTournamentSessionUpdateWithoutUserInput, DailyTournamentSessionUncheckedUpdateWithoutUserInput>
    create: XOR<DailyTournamentSessionCreateWithoutUserInput, DailyTournamentSessionUncheckedCreateWithoutUserInput>
  }

  export type DailyTournamentSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyTournamentSessionWhereUniqueInput
    data: XOR<DailyTournamentSessionUpdateWithoutUserInput, DailyTournamentSessionUncheckedUpdateWithoutUserInput>
  }

  export type DailyTournamentSessionUpdateManyWithWhereWithoutUserInput = {
    where: DailyTournamentSessionScalarWhereInput
    data: XOR<DailyTournamentSessionUpdateManyMutationInput, DailyTournamentSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyTournamentSessionScalarWhereInput = {
    AND?: DailyTournamentSessionScalarWhereInput | DailyTournamentSessionScalarWhereInput[]
    OR?: DailyTournamentSessionScalarWhereInput[]
    NOT?: DailyTournamentSessionScalarWhereInput | DailyTournamentSessionScalarWhereInput[]
    id?: StringFilter<"DailyTournamentSession"> | string
    createdAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    updatedAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    userId?: StringFilter<"DailyTournamentSession"> | string
    tournamentId?: StringFilter<"DailyTournamentSession"> | string
    sessionSeed?: StringFilter<"DailyTournamentSession"> | string
    startedAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"DailyTournamentSession"> | Date | string | null
    status?: EnumUserTournamentStatusFilter<"DailyTournamentSession"> | $Enums.UserTournamentStatus
    currentScore?: IntFilter<"DailyTournamentSession"> | number
    finalScore?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute1Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute2Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute3Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    minute4Score?: IntNullableFilter<"DailyTournamentSession"> | number | null
    isFreeAttempt?: BoolFilter<"DailyTournamentSession"> | boolean
    isRewardedAttempt?: BoolFilter<"DailyTournamentSession"> | boolean
    currentLevel?: IntFilter<"DailyTournamentSession"> | number
    questionsAnswered?: IntFilter<"DailyTournamentSession"> | number
    correctAnswers?: IntFilter<"DailyTournamentSession"> | number
    endsAt?: DateTimeFilter<"DailyTournamentSession"> | Date | string
  }

  export type SoloSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SoloSessionWhereUniqueInput
    update: XOR<SoloSessionUpdateWithoutUserInput, SoloSessionUncheckedUpdateWithoutUserInput>
    create: XOR<SoloSessionCreateWithoutUserInput, SoloSessionUncheckedCreateWithoutUserInput>
  }

  export type SoloSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SoloSessionWhereUniqueInput
    data: XOR<SoloSessionUpdateWithoutUserInput, SoloSessionUncheckedUpdateWithoutUserInput>
  }

  export type SoloSessionUpdateManyWithWhereWithoutUserInput = {
    where: SoloSessionScalarWhereInput
    data: XOR<SoloSessionUpdateManyMutationInput, SoloSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SoloSessionScalarWhereInput = {
    AND?: SoloSessionScalarWhereInput | SoloSessionScalarWhereInput[]
    OR?: SoloSessionScalarWhereInput[]
    NOT?: SoloSessionScalarWhereInput | SoloSessionScalarWhereInput[]
    id?: StringFilter<"SoloSession"> | string
    createdAt?: DateTimeFilter<"SoloSession"> | Date | string
    updatedAt?: DateTimeFilter<"SoloSession"> | Date | string
    userId?: StringFilter<"SoloSession"> | string
    date?: DateTimeFilter<"SoloSession"> | Date | string
    sessionSeed?: StringFilter<"SoloSession"> | string
    startedAt?: DateTimeFilter<"SoloSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"SoloSession"> | Date | string | null
    status?: EnumUserTournamentStatusFilter<"SoloSession"> | $Enums.UserTournamentStatus
    currentRound?: IntFilter<"SoloSession"> | number
    bankedPoints?: FloatFilter<"SoloSession"> | number
    finalScore?: FloatNullableFilter<"SoloSession"> | number | null
    coinPointsEarned?: IntFilter<"SoloSession"> | number
    isFreeAttempt?: BoolFilter<"SoloSession"> | boolean
    currentLevel?: IntFilter<"SoloSession"> | number
    questionsAnswered?: IntFilter<"SoloSession"> | number
    correctAnswers?: IntFilter<"SoloSession"> | number
    madeMistake?: BoolFilter<"SoloSession"> | boolean
    quitEarly?: BoolFilter<"SoloSession"> | boolean
  }

  export type InstantSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: InstantSessionWhereUniqueInput
    update: XOR<InstantSessionUpdateWithoutUserInput, InstantSessionUncheckedUpdateWithoutUserInput>
    create: XOR<InstantSessionCreateWithoutUserInput, InstantSessionUncheckedCreateWithoutUserInput>
  }

  export type InstantSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: InstantSessionWhereUniqueInput
    data: XOR<InstantSessionUpdateWithoutUserInput, InstantSessionUncheckedUpdateWithoutUserInput>
  }

  export type InstantSessionUpdateManyWithWhereWithoutUserInput = {
    where: InstantSessionScalarWhereInput
    data: XOR<InstantSessionUpdateManyMutationInput, InstantSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type InstantSessionScalarWhereInput = {
    AND?: InstantSessionScalarWhereInput | InstantSessionScalarWhereInput[]
    OR?: InstantSessionScalarWhereInput[]
    NOT?: InstantSessionScalarWhereInput | InstantSessionScalarWhereInput[]
    id?: StringFilter<"InstantSession"> | string
    userId?: StringFilter<"InstantSession"> | string
    status?: EnumInstantTournamentSessionStatusFilter<"InstantSession"> | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringFilter<"InstantSession"> | string
    score?: IntFilter<"InstantSession"> | number
    finalScore?: IntNullableFilter<"InstantSession"> | number | null
    bestScore?: IntFilter<"InstantSession"> | number
    startedAt?: DateTimeFilter<"InstantSession"> | Date | string
    endsAt?: DateTimeNullableFilter<"InstantSession"> | Date | string | null
    submittedAt?: DateTimeNullableFilter<"InstantSession"> | Date | string | null
  }

  export type InstantParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: InstantParticipantWhereUniqueInput
    update: XOR<InstantParticipantUpdateWithoutUserInput, InstantParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<InstantParticipantCreateWithoutUserInput, InstantParticipantUncheckedCreateWithoutUserInput>
  }

  export type InstantParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: InstantParticipantWhereUniqueInput
    data: XOR<InstantParticipantUpdateWithoutUserInput, InstantParticipantUncheckedUpdateWithoutUserInput>
  }

  export type InstantParticipantUpdateManyWithWhereWithoutUserInput = {
    where: InstantParticipantScalarWhereInput
    data: XOR<InstantParticipantUpdateManyMutationInput, InstantParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type InstantParticipantScalarWhereInput = {
    AND?: InstantParticipantScalarWhereInput | InstantParticipantScalarWhereInput[]
    OR?: InstantParticipantScalarWhereInput[]
    NOT?: InstantParticipantScalarWhereInput | InstantParticipantScalarWhereInput[]
    tournamentId?: StringFilter<"InstantParticipant"> | string
    userId?: StringFilter<"InstantParticipant"> | string
    joinedAt?: DateTimeFilter<"InstantParticipant"> | Date | string
    joinOrder?: IntFilter<"InstantParticipant"> | number
    sessionStarted?: BoolFilter<"InstantParticipant"> | boolean
    finalScore?: IntNullableFilter<"InstantParticipant"> | number | null
    submittedAt?: DateTimeNullableFilter<"InstantParticipant"> | Date | string | null
    finalRank?: IntNullableFilter<"InstantParticipant"> | number | null
  }

  export type DailyLeaderboardUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyLeaderboardWhereUniqueInput
    update: XOR<DailyLeaderboardUpdateWithoutUserInput, DailyLeaderboardUncheckedUpdateWithoutUserInput>
    create: XOR<DailyLeaderboardCreateWithoutUserInput, DailyLeaderboardUncheckedCreateWithoutUserInput>
  }

  export type DailyLeaderboardUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyLeaderboardWhereUniqueInput
    data: XOR<DailyLeaderboardUpdateWithoutUserInput, DailyLeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type DailyLeaderboardUpdateManyWithWhereWithoutUserInput = {
    where: DailyLeaderboardScalarWhereInput
    data: XOR<DailyLeaderboardUpdateManyMutationInput, DailyLeaderboardUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyLeaderboardScalarWhereInput = {
    AND?: DailyLeaderboardScalarWhereInput | DailyLeaderboardScalarWhereInput[]
    OR?: DailyLeaderboardScalarWhereInput[]
    NOT?: DailyLeaderboardScalarWhereInput | DailyLeaderboardScalarWhereInput[]
    id?: StringFilter<"DailyLeaderboard"> | string
    date?: DateTimeFilter<"DailyLeaderboard"> | Date | string
    userId?: StringFilter<"DailyLeaderboard"> | string
    bestScore?: IntFilter<"DailyLeaderboard"> | number
    rank?: IntFilter<"DailyLeaderboard"> | number
    coinPoints?: IntFilter<"DailyLeaderboard"> | number
    updatedAt?: DateTimeFilter<"DailyLeaderboard"> | Date | string
  }

  export type InstantLeaderboardUpsertWithWhereUniqueWithoutUserInput = {
    where: InstantLeaderboardWhereUniqueInput
    update: XOR<InstantLeaderboardUpdateWithoutUserInput, InstantLeaderboardUncheckedUpdateWithoutUserInput>
    create: XOR<InstantLeaderboardCreateWithoutUserInput, InstantLeaderboardUncheckedCreateWithoutUserInput>
  }

  export type InstantLeaderboardUpdateWithWhereUniqueWithoutUserInput = {
    where: InstantLeaderboardWhereUniqueInput
    data: XOR<InstantLeaderboardUpdateWithoutUserInput, InstantLeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type InstantLeaderboardUpdateManyWithWhereWithoutUserInput = {
    where: InstantLeaderboardScalarWhereInput
    data: XOR<InstantLeaderboardUpdateManyMutationInput, InstantLeaderboardUncheckedUpdateManyWithoutUserInput>
  }

  export type InstantLeaderboardScalarWhereInput = {
    AND?: InstantLeaderboardScalarWhereInput | InstantLeaderboardScalarWhereInput[]
    OR?: InstantLeaderboardScalarWhereInput[]
    NOT?: InstantLeaderboardScalarWhereInput | InstantLeaderboardScalarWhereInput[]
    id?: StringFilter<"InstantLeaderboard"> | string
    tournamentId?: StringFilter<"InstantLeaderboard"> | string
    userId?: StringFilter<"InstantLeaderboard"> | string
    bestScore?: IntFilter<"InstantLeaderboard"> | number
    rank?: IntFilter<"InstantLeaderboard"> | number
    coinPoints?: DecimalFilter<"InstantLeaderboard"> | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFilter<"InstantLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"InstantLeaderboard"> | Date | string
    date?: DateTimeFilter<"InstantLeaderboard"> | Date | string
  }

  export type RewardClaimUpsertWithWhereUniqueWithoutUserInput = {
    where: RewardClaimWhereUniqueInput
    update: XOR<RewardClaimUpdateWithoutUserInput, RewardClaimUncheckedUpdateWithoutUserInput>
    create: XOR<RewardClaimCreateWithoutUserInput, RewardClaimUncheckedCreateWithoutUserInput>
  }

  export type RewardClaimUpdateWithWhereUniqueWithoutUserInput = {
    where: RewardClaimWhereUniqueInput
    data: XOR<RewardClaimUpdateWithoutUserInput, RewardClaimUncheckedUpdateWithoutUserInput>
  }

  export type RewardClaimUpdateManyWithWhereWithoutUserInput = {
    where: RewardClaimScalarWhereInput
    data: XOR<RewardClaimUpdateManyMutationInput, RewardClaimUncheckedUpdateManyWithoutUserInput>
  }

  export type RewardClaimScalarWhereInput = {
    AND?: RewardClaimScalarWhereInput | RewardClaimScalarWhereInput[]
    OR?: RewardClaimScalarWhereInput[]
    NOT?: RewardClaimScalarWhereInput | RewardClaimScalarWhereInput[]
    id?: StringFilter<"RewardClaim"> | string
    userId?: StringFilter<"RewardClaim"> | string
    coinsLocked?: IntFilter<"RewardClaim"> | number
    status?: EnumClaimStatusFilter<"RewardClaim"> | $Enums.ClaimStatus
    voucherCode?: StringNullableFilter<"RewardClaim"> | string | null
    adminNotes?: StringNullableFilter<"RewardClaim"> | string | null
    fulfilledBy?: StringNullableFilter<"RewardClaim"> | string | null
    fulfilledAt?: DateTimeNullableFilter<"RewardClaim"> | Date | string | null
    rejectionReason?: StringNullableFilter<"RewardClaim"> | string | null
    createdAt?: DateTimeFilter<"RewardClaim"> | Date | string
    updatedAt?: DateTimeFilter<"RewardClaim"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringNullableFilter<"Referral"> | string | null
    referralCode?: StringFilter<"Referral"> | string
    status?: EnumReferralStatusFilter<"Referral"> | $Enums.ReferralStatus
    referrerCoins?: IntFilter<"Referral"> | number
    refereeCoins?: IntFilter<"Referral"> | number
    rewardedAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    updatedAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralUpdateManyWithWhereWithoutRefereeInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutRefereeInput>
  }

  export type CoinLedgerUpsertWithWhereUniqueWithoutUserInput = {
    where: CoinLedgerWhereUniqueInput
    update: XOR<CoinLedgerUpdateWithoutUserInput, CoinLedgerUncheckedUpdateWithoutUserInput>
    create: XOR<CoinLedgerCreateWithoutUserInput, CoinLedgerUncheckedCreateWithoutUserInput>
  }

  export type CoinLedgerUpdateWithWhereUniqueWithoutUserInput = {
    where: CoinLedgerWhereUniqueInput
    data: XOR<CoinLedgerUpdateWithoutUserInput, CoinLedgerUncheckedUpdateWithoutUserInput>
  }

  export type CoinLedgerUpdateManyWithWhereWithoutUserInput = {
    where: CoinLedgerScalarWhereInput
    data: XOR<CoinLedgerUpdateManyMutationInput, CoinLedgerUncheckedUpdateManyWithoutUserInput>
  }

  export type CoinLedgerScalarWhereInput = {
    AND?: CoinLedgerScalarWhereInput | CoinLedgerScalarWhereInput[]
    OR?: CoinLedgerScalarWhereInput[]
    NOT?: CoinLedgerScalarWhereInput | CoinLedgerScalarWhereInput[]
    id?: StringFilter<"CoinLedger"> | string
    userId?: StringFilter<"CoinLedger"> | string
    date?: DateTimeFilter<"CoinLedger"> | Date | string
    delta?: IntFilter<"CoinLedger"> | number
    source?: EnumCoinLedgerSourceFilter<"CoinLedger"> | $Enums.CoinLedgerSource
    referenceId?: StringFilter<"CoinLedger"> | string
    metadata?: JsonNullableFilter<"CoinLedger">
    createdAt?: DateTimeFilter<"CoinLedger"> | Date | string
  }

  export type DailyUserLeaderboardUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyUserLeaderboardWhereUniqueInput
    update: XOR<DailyUserLeaderboardUpdateWithoutUserInput, DailyUserLeaderboardUncheckedUpdateWithoutUserInput>
    create: XOR<DailyUserLeaderboardCreateWithoutUserInput, DailyUserLeaderboardUncheckedCreateWithoutUserInput>
  }

  export type DailyUserLeaderboardUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyUserLeaderboardWhereUniqueInput
    data: XOR<DailyUserLeaderboardUpdateWithoutUserInput, DailyUserLeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type DailyUserLeaderboardUpdateManyWithWhereWithoutUserInput = {
    where: DailyUserLeaderboardScalarWhereInput
    data: XOR<DailyUserLeaderboardUpdateManyMutationInput, DailyUserLeaderboardUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyUserLeaderboardScalarWhereInput = {
    AND?: DailyUserLeaderboardScalarWhereInput | DailyUserLeaderboardScalarWhereInput[]
    OR?: DailyUserLeaderboardScalarWhereInput[]
    NOT?: DailyUserLeaderboardScalarWhereInput | DailyUserLeaderboardScalarWhereInput[]
    id?: StringFilter<"DailyUserLeaderboard"> | string
    userId?: StringFilter<"DailyUserLeaderboard"> | string
    date?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
    dailyCoinPoints?: IntFilter<"DailyUserLeaderboard"> | number
    instantCoinPoints?: DecimalFilter<"DailyUserLeaderboard"> | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFilter<"DailyUserLeaderboard"> | Decimal | DecimalJsLike | number | string
    rank?: IntFilter<"DailyUserLeaderboard"> | number
    isEligible?: BoolFilter<"DailyUserLeaderboard"> | boolean
    coinsAwarded?: FloatFilter<"DailyUserLeaderboard"> | number
    createdAt?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
    updatedAt?: DateTimeFilter<"DailyUserLeaderboard"> | Date | string
  }

  export type MinuteSnapshotCreateWithoutTournamentInput = {
    id?: string
    minuteNumber: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MinuteSnapshotUncheckedCreateWithoutTournamentInput = {
    id?: string
    minuteNumber: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MinuteSnapshotCreateOrConnectWithoutTournamentInput = {
    where: MinuteSnapshotWhereUniqueInput
    create: XOR<MinuteSnapshotCreateWithoutTournamentInput, MinuteSnapshotUncheckedCreateWithoutTournamentInput>
  }

  export type MinuteSnapshotCreateManyTournamentInputEnvelope = {
    data: MinuteSnapshotCreateManyTournamentInput | MinuteSnapshotCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type DailyTournamentSessionCreateWithoutTournamentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
    user: UserCreateNestedOneWithoutDailySessionsInput
    questions?: QuestionAttemptCreateNestedManyWithoutDailySessionInput
  }

  export type DailyTournamentSessionUncheckedCreateWithoutTournamentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
    questions?: QuestionAttemptUncheckedCreateNestedManyWithoutDailySessionInput
  }

  export type DailyTournamentSessionCreateOrConnectWithoutTournamentInput = {
    where: DailyTournamentSessionWhereUniqueInput
    create: XOR<DailyTournamentSessionCreateWithoutTournamentInput, DailyTournamentSessionUncheckedCreateWithoutTournamentInput>
  }

  export type DailyTournamentSessionCreateManyTournamentInputEnvelope = {
    data: DailyTournamentSessionCreateManyTournamentInput | DailyTournamentSessionCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type MinuteSnapshotUpsertWithWhereUniqueWithoutTournamentInput = {
    where: MinuteSnapshotWhereUniqueInput
    update: XOR<MinuteSnapshotUpdateWithoutTournamentInput, MinuteSnapshotUncheckedUpdateWithoutTournamentInput>
    create: XOR<MinuteSnapshotCreateWithoutTournamentInput, MinuteSnapshotUncheckedCreateWithoutTournamentInput>
  }

  export type MinuteSnapshotUpdateWithWhereUniqueWithoutTournamentInput = {
    where: MinuteSnapshotWhereUniqueInput
    data: XOR<MinuteSnapshotUpdateWithoutTournamentInput, MinuteSnapshotUncheckedUpdateWithoutTournamentInput>
  }

  export type MinuteSnapshotUpdateManyWithWhereWithoutTournamentInput = {
    where: MinuteSnapshotScalarWhereInput
    data: XOR<MinuteSnapshotUpdateManyMutationInput, MinuteSnapshotUncheckedUpdateManyWithoutTournamentInput>
  }

  export type MinuteSnapshotScalarWhereInput = {
    AND?: MinuteSnapshotScalarWhereInput | MinuteSnapshotScalarWhereInput[]
    OR?: MinuteSnapshotScalarWhereInput[]
    NOT?: MinuteSnapshotScalarWhereInput | MinuteSnapshotScalarWhereInput[]
    id?: StringFilter<"MinuteSnapshot"> | string
    tournamentId?: StringFilter<"MinuteSnapshot"> | string
    minuteNumber?: IntFilter<"MinuteSnapshot"> | number
    snapshot?: JsonFilter<"MinuteSnapshot">
    createdAt?: DateTimeFilter<"MinuteSnapshot"> | Date | string
  }

  export type DailyTournamentSessionUpsertWithWhereUniqueWithoutTournamentInput = {
    where: DailyTournamentSessionWhereUniqueInput
    update: XOR<DailyTournamentSessionUpdateWithoutTournamentInput, DailyTournamentSessionUncheckedUpdateWithoutTournamentInput>
    create: XOR<DailyTournamentSessionCreateWithoutTournamentInput, DailyTournamentSessionUncheckedCreateWithoutTournamentInput>
  }

  export type DailyTournamentSessionUpdateWithWhereUniqueWithoutTournamentInput = {
    where: DailyTournamentSessionWhereUniqueInput
    data: XOR<DailyTournamentSessionUpdateWithoutTournamentInput, DailyTournamentSessionUncheckedUpdateWithoutTournamentInput>
  }

  export type DailyTournamentSessionUpdateManyWithWhereWithoutTournamentInput = {
    where: DailyTournamentSessionScalarWhereInput
    data: XOR<DailyTournamentSessionUpdateManyMutationInput, DailyTournamentSessionUncheckedUpdateManyWithoutTournamentInput>
  }

  export type UserCreateWithoutDailySessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailySessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailySessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailySessionsInput, UserUncheckedCreateWithoutDailySessionsInput>
  }

  export type DailyTournamentCreateWithoutSessionsInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    status?: $Enums.TournamentStatus
    configVersion?: string | null
    final?: JsonNullValueInput | InputJsonValue
    minuteSnapshot?: MinuteSnapshotCreateNestedManyWithoutTournamentInput
  }

  export type DailyTournamentUncheckedCreateWithoutSessionsInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    status?: $Enums.TournamentStatus
    configVersion?: string | null
    final?: JsonNullValueInput | InputJsonValue
    minuteSnapshot?: MinuteSnapshotUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type DailyTournamentCreateOrConnectWithoutSessionsInput = {
    where: DailyTournamentWhereUniqueInput
    create: XOR<DailyTournamentCreateWithoutSessionsInput, DailyTournamentUncheckedCreateWithoutSessionsInput>
  }

  export type QuestionAttemptCreateWithoutDailySessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    soloSession?: SoloSessionCreateNestedOneWithoutQuestionsInput
    instantSession?: InstantSessionCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionAttemptUncheckedCreateWithoutDailySessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    soloSessionId?: string | null
    instantSessionId?: string | null
  }

  export type QuestionAttemptCreateOrConnectWithoutDailySessionInput = {
    where: QuestionAttemptWhereUniqueInput
    create: XOR<QuestionAttemptCreateWithoutDailySessionInput, QuestionAttemptUncheckedCreateWithoutDailySessionInput>
  }

  export type QuestionAttemptCreateManyDailySessionInputEnvelope = {
    data: QuestionAttemptCreateManyDailySessionInput | QuestionAttemptCreateManyDailySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDailySessionsInput = {
    update: XOR<UserUpdateWithoutDailySessionsInput, UserUncheckedUpdateWithoutDailySessionsInput>
    create: XOR<UserCreateWithoutDailySessionsInput, UserUncheckedCreateWithoutDailySessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailySessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailySessionsInput, UserUncheckedUpdateWithoutDailySessionsInput>
  }

  export type UserUpdateWithoutDailySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DailyTournamentUpsertWithoutSessionsInput = {
    update: XOR<DailyTournamentUpdateWithoutSessionsInput, DailyTournamentUncheckedUpdateWithoutSessionsInput>
    create: XOR<DailyTournamentCreateWithoutSessionsInput, DailyTournamentUncheckedCreateWithoutSessionsInput>
    where?: DailyTournamentWhereInput
  }

  export type DailyTournamentUpdateToOneWithWhereWithoutSessionsInput = {
    where?: DailyTournamentWhereInput
    data: XOR<DailyTournamentUpdateWithoutSessionsInput, DailyTournamentUncheckedUpdateWithoutSessionsInput>
  }

  export type DailyTournamentUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    configVersion?: NullableStringFieldUpdateOperationsInput | string | null
    final?: JsonNullValueInput | InputJsonValue
    minuteSnapshot?: MinuteSnapshotUpdateManyWithoutTournamentNestedInput
  }

  export type DailyTournamentUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    configVersion?: NullableStringFieldUpdateOperationsInput | string | null
    final?: JsonNullValueInput | InputJsonValue
    minuteSnapshot?: MinuteSnapshotUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type QuestionAttemptUpsertWithWhereUniqueWithoutDailySessionInput = {
    where: QuestionAttemptWhereUniqueInput
    update: XOR<QuestionAttemptUpdateWithoutDailySessionInput, QuestionAttemptUncheckedUpdateWithoutDailySessionInput>
    create: XOR<QuestionAttemptCreateWithoutDailySessionInput, QuestionAttemptUncheckedCreateWithoutDailySessionInput>
  }

  export type QuestionAttemptUpdateWithWhereUniqueWithoutDailySessionInput = {
    where: QuestionAttemptWhereUniqueInput
    data: XOR<QuestionAttemptUpdateWithoutDailySessionInput, QuestionAttemptUncheckedUpdateWithoutDailySessionInput>
  }

  export type QuestionAttemptUpdateManyWithWhereWithoutDailySessionInput = {
    where: QuestionAttemptScalarWhereInput
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyWithoutDailySessionInput>
  }

  export type QuestionAttemptScalarWhereInput = {
    AND?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
    OR?: QuestionAttemptScalarWhereInput[]
    NOT?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
    id?: StringFilter<"QuestionAttempt"> | string
    createdAt?: DateTimeFilter<"QuestionAttempt"> | Date | string
    questionIndex?: IntFilter<"QuestionAttempt"> | number
    level?: IntFilter<"QuestionAttempt"> | number
    expression?: StringFilter<"QuestionAttempt"> | string
    result?: StringFilter<"QuestionAttempt"> | string
    side?: StringFilter<"QuestionAttempt"> | string
    kthDigit?: IntFilter<"QuestionAttempt"> | number
    correctDigit?: IntFilter<"QuestionAttempt"> | number
    dailySessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
    soloSessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
    instantSessionId?: StringNullableFilter<"QuestionAttempt"> | string | null
  }

  export type DailyTournamentCreateWithoutMinuteSnapshotInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    status?: $Enums.TournamentStatus
    configVersion?: string | null
    final?: JsonNullValueInput | InputJsonValue
    sessions?: DailyTournamentSessionCreateNestedManyWithoutTournamentInput
  }

  export type DailyTournamentUncheckedCreateWithoutMinuteSnapshotInput = {
    id?: string
    date: Date | string
    createdAt?: Date | string
    status?: $Enums.TournamentStatus
    configVersion?: string | null
    final?: JsonNullValueInput | InputJsonValue
    sessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type DailyTournamentCreateOrConnectWithoutMinuteSnapshotInput = {
    where: DailyTournamentWhereUniqueInput
    create: XOR<DailyTournamentCreateWithoutMinuteSnapshotInput, DailyTournamentUncheckedCreateWithoutMinuteSnapshotInput>
  }

  export type DailyTournamentUpsertWithoutMinuteSnapshotInput = {
    update: XOR<DailyTournamentUpdateWithoutMinuteSnapshotInput, DailyTournamentUncheckedUpdateWithoutMinuteSnapshotInput>
    create: XOR<DailyTournamentCreateWithoutMinuteSnapshotInput, DailyTournamentUncheckedCreateWithoutMinuteSnapshotInput>
    where?: DailyTournamentWhereInput
  }

  export type DailyTournamentUpdateToOneWithWhereWithoutMinuteSnapshotInput = {
    where?: DailyTournamentWhereInput
    data: XOR<DailyTournamentUpdateWithoutMinuteSnapshotInput, DailyTournamentUncheckedUpdateWithoutMinuteSnapshotInput>
  }

  export type DailyTournamentUpdateWithoutMinuteSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    configVersion?: NullableStringFieldUpdateOperationsInput | string | null
    final?: JsonNullValueInput | InputJsonValue
    sessions?: DailyTournamentSessionUpdateManyWithoutTournamentNestedInput
  }

  export type DailyTournamentUncheckedUpdateWithoutMinuteSnapshotInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    configVersion?: NullableStringFieldUpdateOperationsInput | string | null
    final?: JsonNullValueInput | InputJsonValue
    sessions?: DailyTournamentSessionUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type UserCreateWithoutSoloSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSoloSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSoloSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSoloSessionsInput, UserUncheckedCreateWithoutSoloSessionsInput>
  }

  export type QuestionAttemptCreateWithoutSoloSessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySession?: DailyTournamentSessionCreateNestedOneWithoutQuestionsInput
    instantSession?: InstantSessionCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionAttemptUncheckedCreateWithoutSoloSessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySessionId?: string | null
    instantSessionId?: string | null
  }

  export type QuestionAttemptCreateOrConnectWithoutSoloSessionInput = {
    where: QuestionAttemptWhereUniqueInput
    create: XOR<QuestionAttemptCreateWithoutSoloSessionInput, QuestionAttemptUncheckedCreateWithoutSoloSessionInput>
  }

  export type QuestionAttemptCreateManySoloSessionInputEnvelope = {
    data: QuestionAttemptCreateManySoloSessionInput | QuestionAttemptCreateManySoloSessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSoloSessionsInput = {
    update: XOR<UserUpdateWithoutSoloSessionsInput, UserUncheckedUpdateWithoutSoloSessionsInput>
    create: XOR<UserCreateWithoutSoloSessionsInput, UserUncheckedCreateWithoutSoloSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSoloSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSoloSessionsInput, UserUncheckedUpdateWithoutSoloSessionsInput>
  }

  export type UserUpdateWithoutSoloSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSoloSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuestionAttemptUpsertWithWhereUniqueWithoutSoloSessionInput = {
    where: QuestionAttemptWhereUniqueInput
    update: XOR<QuestionAttemptUpdateWithoutSoloSessionInput, QuestionAttemptUncheckedUpdateWithoutSoloSessionInput>
    create: XOR<QuestionAttemptCreateWithoutSoloSessionInput, QuestionAttemptUncheckedCreateWithoutSoloSessionInput>
  }

  export type QuestionAttemptUpdateWithWhereUniqueWithoutSoloSessionInput = {
    where: QuestionAttemptWhereUniqueInput
    data: XOR<QuestionAttemptUpdateWithoutSoloSessionInput, QuestionAttemptUncheckedUpdateWithoutSoloSessionInput>
  }

  export type QuestionAttemptUpdateManyWithWhereWithoutSoloSessionInput = {
    where: QuestionAttemptScalarWhereInput
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyWithoutSoloSessionInput>
  }

  export type DailyTournamentSessionCreateWithoutQuestionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
    user: UserCreateNestedOneWithoutDailySessionsInput
    tournament: DailyTournamentCreateNestedOneWithoutSessionsInput
  }

  export type DailyTournamentSessionUncheckedCreateWithoutQuestionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    tournamentId: string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
  }

  export type DailyTournamentSessionCreateOrConnectWithoutQuestionsInput = {
    where: DailyTournamentSessionWhereUniqueInput
    create: XOR<DailyTournamentSessionCreateWithoutQuestionsInput, DailyTournamentSessionUncheckedCreateWithoutQuestionsInput>
  }

  export type SoloSessionCreateWithoutQuestionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentRound?: number
    bankedPoints?: number
    finalScore?: number | null
    coinPointsEarned?: number
    isFreeAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    madeMistake?: boolean
    quitEarly?: boolean
    user: UserCreateNestedOneWithoutSoloSessionsInput
  }

  export type SoloSessionUncheckedCreateWithoutQuestionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    date: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentRound?: number
    bankedPoints?: number
    finalScore?: number | null
    coinPointsEarned?: number
    isFreeAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    madeMistake?: boolean
    quitEarly?: boolean
  }

  export type SoloSessionCreateOrConnectWithoutQuestionsInput = {
    where: SoloSessionWhereUniqueInput
    create: XOR<SoloSessionCreateWithoutQuestionsInput, SoloSessionUncheckedCreateWithoutQuestionsInput>
  }

  export type InstantSessionCreateWithoutQuestionsInput = {
    id?: string
    status?: $Enums.InstantTournamentSessionStatus
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
    user: UserCreateNestedOneWithoutInstantSessionsInput
    tournament: InstantTournamentCreateNestedOneWithoutSessionsInput
  }

  export type InstantSessionUncheckedCreateWithoutQuestionsInput = {
    id?: string
    userId: string
    status?: $Enums.InstantTournamentSessionStatus
    tournamentId: string
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
  }

  export type InstantSessionCreateOrConnectWithoutQuestionsInput = {
    where: InstantSessionWhereUniqueInput
    create: XOR<InstantSessionCreateWithoutQuestionsInput, InstantSessionUncheckedCreateWithoutQuestionsInput>
  }

  export type DailyTournamentSessionUpsertWithoutQuestionsInput = {
    update: XOR<DailyTournamentSessionUpdateWithoutQuestionsInput, DailyTournamentSessionUncheckedUpdateWithoutQuestionsInput>
    create: XOR<DailyTournamentSessionCreateWithoutQuestionsInput, DailyTournamentSessionUncheckedCreateWithoutQuestionsInput>
    where?: DailyTournamentSessionWhereInput
  }

  export type DailyTournamentSessionUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: DailyTournamentSessionWhereInput
    data: XOR<DailyTournamentSessionUpdateWithoutQuestionsInput, DailyTournamentSessionUncheckedUpdateWithoutQuestionsInput>
  }

  export type DailyTournamentSessionUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailySessionsNestedInput
    tournament?: DailyTournamentUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type DailyTournamentSessionUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoloSessionUpsertWithoutQuestionsInput = {
    update: XOR<SoloSessionUpdateWithoutQuestionsInput, SoloSessionUncheckedUpdateWithoutQuestionsInput>
    create: XOR<SoloSessionCreateWithoutQuestionsInput, SoloSessionUncheckedCreateWithoutQuestionsInput>
    where?: SoloSessionWhereInput
  }

  export type SoloSessionUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: SoloSessionWhereInput
    data: XOR<SoloSessionUpdateWithoutQuestionsInput, SoloSessionUncheckedUpdateWithoutQuestionsInput>
  }

  export type SoloSessionUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSoloSessionsNestedInput
  }

  export type SoloSessionUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InstantSessionUpsertWithoutQuestionsInput = {
    update: XOR<InstantSessionUpdateWithoutQuestionsInput, InstantSessionUncheckedUpdateWithoutQuestionsInput>
    create: XOR<InstantSessionCreateWithoutQuestionsInput, InstantSessionUncheckedCreateWithoutQuestionsInput>
    where?: InstantSessionWhereInput
  }

  export type InstantSessionUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: InstantSessionWhereInput
    data: XOR<InstantSessionUpdateWithoutQuestionsInput, InstantSessionUncheckedUpdateWithoutQuestionsInput>
  }

  export type InstantSessionUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInstantSessionsNestedInput
    tournament?: InstantTournamentUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type InstantSessionUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstantSessionCreateWithoutTournamentInput = {
    id?: string
    status?: $Enums.InstantTournamentSessionStatus
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
    user: UserCreateNestedOneWithoutInstantSessionsInput
    questions?: QuestionAttemptCreateNestedManyWithoutInstantSessionInput
  }

  export type InstantSessionUncheckedCreateWithoutTournamentInput = {
    id?: string
    userId: string
    status?: $Enums.InstantTournamentSessionStatus
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
    questions?: QuestionAttemptUncheckedCreateNestedManyWithoutInstantSessionInput
  }

  export type InstantSessionCreateOrConnectWithoutTournamentInput = {
    where: InstantSessionWhereUniqueInput
    create: XOR<InstantSessionCreateWithoutTournamentInput, InstantSessionUncheckedCreateWithoutTournamentInput>
  }

  export type InstantSessionCreateManyTournamentInputEnvelope = {
    data: InstantSessionCreateManyTournamentInput | InstantSessionCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type InstantParticipantCreateWithoutTournamentInput = {
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
    user: UserCreateNestedOneWithoutInstantParticipantInput
  }

  export type InstantParticipantUncheckedCreateWithoutTournamentInput = {
    userId: string
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
  }

  export type InstantParticipantCreateOrConnectWithoutTournamentInput = {
    where: InstantParticipantWhereUniqueInput
    create: XOR<InstantParticipantCreateWithoutTournamentInput, InstantParticipantUncheckedCreateWithoutTournamentInput>
  }

  export type InstantParticipantCreateManyTournamentInputEnvelope = {
    data: InstantParticipantCreateManyTournamentInput | InstantParticipantCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type InstantSessionUpsertWithWhereUniqueWithoutTournamentInput = {
    where: InstantSessionWhereUniqueInput
    update: XOR<InstantSessionUpdateWithoutTournamentInput, InstantSessionUncheckedUpdateWithoutTournamentInput>
    create: XOR<InstantSessionCreateWithoutTournamentInput, InstantSessionUncheckedCreateWithoutTournamentInput>
  }

  export type InstantSessionUpdateWithWhereUniqueWithoutTournamentInput = {
    where: InstantSessionWhereUniqueInput
    data: XOR<InstantSessionUpdateWithoutTournamentInput, InstantSessionUncheckedUpdateWithoutTournamentInput>
  }

  export type InstantSessionUpdateManyWithWhereWithoutTournamentInput = {
    where: InstantSessionScalarWhereInput
    data: XOR<InstantSessionUpdateManyMutationInput, InstantSessionUncheckedUpdateManyWithoutTournamentInput>
  }

  export type InstantParticipantUpsertWithWhereUniqueWithoutTournamentInput = {
    where: InstantParticipantWhereUniqueInput
    update: XOR<InstantParticipantUpdateWithoutTournamentInput, InstantParticipantUncheckedUpdateWithoutTournamentInput>
    create: XOR<InstantParticipantCreateWithoutTournamentInput, InstantParticipantUncheckedCreateWithoutTournamentInput>
  }

  export type InstantParticipantUpdateWithWhereUniqueWithoutTournamentInput = {
    where: InstantParticipantWhereUniqueInput
    data: XOR<InstantParticipantUpdateWithoutTournamentInput, InstantParticipantUncheckedUpdateWithoutTournamentInput>
  }

  export type InstantParticipantUpdateManyWithWhereWithoutTournamentInput = {
    where: InstantParticipantScalarWhereInput
    data: XOR<InstantParticipantUpdateManyMutationInput, InstantParticipantUncheckedUpdateManyWithoutTournamentInput>
  }

  export type UserCreateWithoutInstantSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstantSessionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstantSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstantSessionsInput, UserUncheckedCreateWithoutInstantSessionsInput>
  }

  export type InstantTournamentCreateWithoutSessionsInput = {
    id?: string
    status?: $Enums.TournamentStatus
    maxPlayers?: number
    playersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    instantParticipant?: InstantParticipantCreateNestedManyWithoutTournamentInput
  }

  export type InstantTournamentUncheckedCreateWithoutSessionsInput = {
    id?: string
    status?: $Enums.TournamentStatus
    maxPlayers?: number
    playersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type InstantTournamentCreateOrConnectWithoutSessionsInput = {
    where: InstantTournamentWhereUniqueInput
    create: XOR<InstantTournamentCreateWithoutSessionsInput, InstantTournamentUncheckedCreateWithoutSessionsInput>
  }

  export type QuestionAttemptCreateWithoutInstantSessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySession?: DailyTournamentSessionCreateNestedOneWithoutQuestionsInput
    soloSession?: SoloSessionCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionAttemptUncheckedCreateWithoutInstantSessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySessionId?: string | null
    soloSessionId?: string | null
  }

  export type QuestionAttemptCreateOrConnectWithoutInstantSessionInput = {
    where: QuestionAttemptWhereUniqueInput
    create: XOR<QuestionAttemptCreateWithoutInstantSessionInput, QuestionAttemptUncheckedCreateWithoutInstantSessionInput>
  }

  export type QuestionAttemptCreateManyInstantSessionInputEnvelope = {
    data: QuestionAttemptCreateManyInstantSessionInput | QuestionAttemptCreateManyInstantSessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInstantSessionsInput = {
    update: XOR<UserUpdateWithoutInstantSessionsInput, UserUncheckedUpdateWithoutInstantSessionsInput>
    create: XOR<UserCreateWithoutInstantSessionsInput, UserUncheckedCreateWithoutInstantSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstantSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstantSessionsInput, UserUncheckedUpdateWithoutInstantSessionsInput>
  }

  export type UserUpdateWithoutInstantSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstantSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstantTournamentUpsertWithoutSessionsInput = {
    update: XOR<InstantTournamentUpdateWithoutSessionsInput, InstantTournamentUncheckedUpdateWithoutSessionsInput>
    create: XOR<InstantTournamentCreateWithoutSessionsInput, InstantTournamentUncheckedCreateWithoutSessionsInput>
    where?: InstantTournamentWhereInput
  }

  export type InstantTournamentUpdateToOneWithWhereWithoutSessionsInput = {
    where?: InstantTournamentWhereInput
    data: XOR<InstantTournamentUpdateWithoutSessionsInput, InstantTournamentUncheckedUpdateWithoutSessionsInput>
  }

  export type InstantTournamentUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    maxPlayers?: IntFieldUpdateOperationsInput | number
    playersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instantParticipant?: InstantParticipantUpdateManyWithoutTournamentNestedInput
  }

  export type InstantTournamentUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    maxPlayers?: IntFieldUpdateOperationsInput | number
    playersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type QuestionAttemptUpsertWithWhereUniqueWithoutInstantSessionInput = {
    where: QuestionAttemptWhereUniqueInput
    update: XOR<QuestionAttemptUpdateWithoutInstantSessionInput, QuestionAttemptUncheckedUpdateWithoutInstantSessionInput>
    create: XOR<QuestionAttemptCreateWithoutInstantSessionInput, QuestionAttemptUncheckedCreateWithoutInstantSessionInput>
  }

  export type QuestionAttemptUpdateWithWhereUniqueWithoutInstantSessionInput = {
    where: QuestionAttemptWhereUniqueInput
    data: XOR<QuestionAttemptUpdateWithoutInstantSessionInput, QuestionAttemptUncheckedUpdateWithoutInstantSessionInput>
  }

  export type QuestionAttemptUpdateManyWithWhereWithoutInstantSessionInput = {
    where: QuestionAttemptScalarWhereInput
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyWithoutInstantSessionInput>
  }

  export type InstantTournamentCreateWithoutInstantParticipantInput = {
    id?: string
    status?: $Enums.TournamentStatus
    maxPlayers?: number
    playersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    sessions?: InstantSessionCreateNestedManyWithoutTournamentInput
  }

  export type InstantTournamentUncheckedCreateWithoutInstantParticipantInput = {
    id?: string
    status?: $Enums.TournamentStatus
    maxPlayers?: number
    playersCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    sessions?: InstantSessionUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type InstantTournamentCreateOrConnectWithoutInstantParticipantInput = {
    where: InstantTournamentWhereUniqueInput
    create: XOR<InstantTournamentCreateWithoutInstantParticipantInput, InstantTournamentUncheckedCreateWithoutInstantParticipantInput>
  }

  export type UserCreateWithoutInstantParticipantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstantParticipantInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstantParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstantParticipantInput, UserUncheckedCreateWithoutInstantParticipantInput>
  }

  export type InstantTournamentUpsertWithoutInstantParticipantInput = {
    update: XOR<InstantTournamentUpdateWithoutInstantParticipantInput, InstantTournamentUncheckedUpdateWithoutInstantParticipantInput>
    create: XOR<InstantTournamentCreateWithoutInstantParticipantInput, InstantTournamentUncheckedCreateWithoutInstantParticipantInput>
    where?: InstantTournamentWhereInput
  }

  export type InstantTournamentUpdateToOneWithWhereWithoutInstantParticipantInput = {
    where?: InstantTournamentWhereInput
    data: XOR<InstantTournamentUpdateWithoutInstantParticipantInput, InstantTournamentUncheckedUpdateWithoutInstantParticipantInput>
  }

  export type InstantTournamentUpdateWithoutInstantParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    maxPlayers?: IntFieldUpdateOperationsInput | number
    playersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: InstantSessionUpdateManyWithoutTournamentNestedInput
  }

  export type InstantTournamentUncheckedUpdateWithoutInstantParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTournamentStatusFieldUpdateOperationsInput | $Enums.TournamentStatus
    maxPlayers?: IntFieldUpdateOperationsInput | number
    playersCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: InstantSessionUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type UserUpsertWithoutInstantParticipantInput = {
    update: XOR<UserUpdateWithoutInstantParticipantInput, UserUncheckedUpdateWithoutInstantParticipantInput>
    create: XOR<UserCreateWithoutInstantParticipantInput, UserUncheckedCreateWithoutInstantParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstantParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstantParticipantInput, UserUncheckedUpdateWithoutInstantParticipantInput>
  }

  export type UserUpdateWithoutInstantParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstantParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDailyLeaderBoardsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyLeaderBoardsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyLeaderBoardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyLeaderBoardsInput, UserUncheckedCreateWithoutDailyLeaderBoardsInput>
  }

  export type UserUpsertWithoutDailyLeaderBoardsInput = {
    update: XOR<UserUpdateWithoutDailyLeaderBoardsInput, UserUncheckedUpdateWithoutDailyLeaderBoardsInput>
    create: XOR<UserCreateWithoutDailyLeaderBoardsInput, UserUncheckedCreateWithoutDailyLeaderBoardsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyLeaderBoardsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyLeaderBoardsInput, UserUncheckedUpdateWithoutDailyLeaderBoardsInput>
  }

  export type UserUpdateWithoutDailyLeaderBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyLeaderBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInstantLeaderboardInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInstantLeaderboardInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInstantLeaderboardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstantLeaderboardInput, UserUncheckedCreateWithoutInstantLeaderboardInput>
  }

  export type UserUpsertWithoutInstantLeaderboardInput = {
    update: XOR<UserUpdateWithoutInstantLeaderboardInput, UserUncheckedUpdateWithoutInstantLeaderboardInput>
    create: XOR<UserCreateWithoutInstantLeaderboardInput, UserUncheckedCreateWithoutInstantLeaderboardInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstantLeaderboardInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstantLeaderboardInput, UserUncheckedUpdateWithoutInstantLeaderboardInput>
  }

  export type UserUpdateWithoutInstantLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstantLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDailyUserLeaderboardInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyUserLeaderboardInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyUserLeaderboardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyUserLeaderboardInput, UserUncheckedCreateWithoutDailyUserLeaderboardInput>
  }

  export type UserUpsertWithoutDailyUserLeaderboardInput = {
    update: XOR<UserUpdateWithoutDailyUserLeaderboardInput, UserUncheckedUpdateWithoutDailyUserLeaderboardInput>
    create: XOR<UserCreateWithoutDailyUserLeaderboardInput, UserUncheckedCreateWithoutDailyUserLeaderboardInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyUserLeaderboardInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyUserLeaderboardInput, UserUncheckedUpdateWithoutDailyUserLeaderboardInput>
  }

  export type UserUpdateWithoutDailyUserLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyUserLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRewardClaimInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRewardClaimInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRewardClaimInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardClaimInput, UserUncheckedCreateWithoutRewardClaimInput>
  }

  export type UserUpsertWithoutRewardClaimInput = {
    update: XOR<UserUpdateWithoutRewardClaimInput, UserUncheckedUpdateWithoutRewardClaimInput>
    create: XOR<UserCreateWithoutRewardClaimInput, UserUncheckedCreateWithoutRewardClaimInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRewardClaimInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRewardClaimInput, UserUncheckedUpdateWithoutRewardClaimInput>
  }

  export type UserUpdateWithoutRewardClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReferralsGivenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsGivenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsGivenInput, UserUncheckedCreateWithoutReferralsGivenInput>
  }

  export type UserCreateWithoutReferralsReceivedInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    coinLedger?: CoinLedgerCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsReceivedInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    coinLedger?: CoinLedgerUncheckedCreateNestedManyWithoutUserInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
  }

  export type UserUpsertWithoutReferralsGivenInput = {
    update: XOR<UserUpdateWithoutReferralsGivenInput, UserUncheckedUpdateWithoutReferralsGivenInput>
    create: XOR<UserCreateWithoutReferralsGivenInput, UserUncheckedCreateWithoutReferralsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsGivenInput, UserUncheckedUpdateWithoutReferralsGivenInput>
  }

  export type UserUpdateWithoutReferralsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferralsReceivedInput = {
    update: XOR<UserUpdateWithoutReferralsReceivedInput, UserUncheckedUpdateWithoutReferralsReceivedInput>
    create: XOR<UserCreateWithoutReferralsReceivedInput, UserUncheckedCreateWithoutReferralsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsReceivedInput, UserUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type UserUpdateWithoutReferralsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCoinLedgerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referredBy?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralCreateNestedManyWithoutRefereeInput
    dailyUserLeaderboard?: DailyUserLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoinLedgerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referredById?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
    referrals?: UserUncheckedCreateNestedManyWithoutReferredByInput
    dailySessions?: DailyTournamentSessionUncheckedCreateNestedManyWithoutUserInput
    soloSessions?: SoloSessionUncheckedCreateNestedManyWithoutUserInput
    instantSessions?: InstantSessionUncheckedCreateNestedManyWithoutUserInput
    instantParticipant?: InstantParticipantUncheckedCreateNestedManyWithoutUserInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedCreateNestedManyWithoutUserInput
    instantLeaderboard?: InstantLeaderboardUncheckedCreateNestedManyWithoutUserInput
    rewardClaim?: RewardClaimUncheckedCreateNestedManyWithoutUserInput
    referralsGiven?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutRefereeInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoinLedgerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoinLedgerInput, UserUncheckedCreateWithoutCoinLedgerInput>
  }

  export type UserUpsertWithoutCoinLedgerInput = {
    update: XOR<UserUpdateWithoutCoinLedgerInput, UserUncheckedUpdateWithoutCoinLedgerInput>
    create: XOR<UserCreateWithoutCoinLedgerInput, UserUncheckedCreateWithoutCoinLedgerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoinLedgerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoinLedgerInput, UserUncheckedUpdateWithoutCoinLedgerInput>
  }

  export type UserUpdateWithoutCoinLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referredBy?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoinLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyReferredByInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    phoneNumber?: string | null
    googleId?: string | null
    email?: string | null
    deviceHash?: string | null
    username: string
    usernameReservedAt?: Date | string | null
    avatarType?: $Enums.AvatarType
    profilePictureUrl?: string | null
    coins?: number
    lifetimeCoins?: number
    lifetimeCoinPoints?: number
    level?: number
    theme?: $Enums.Theme
    soundEnabled?: boolean
    hapticsEnabled?: boolean
    language?: string
    referralCode?: string | null
    referralRewarded?: boolean
    role?: $Enums.Role
    soloAttemptCount?: number
    instantAttemptCount?: number
    dailyAttemptCount?: number
    currentLoginStreak?: number
    longestLoginStreak?: number
    lastLoginRewardDate?: Date | string | null
    totalLoginDays?: number
  }

  export type DailyTournamentSessionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tournamentId: string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
  }

  export type SoloSessionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    date: Date | string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentRound?: number
    bankedPoints?: number
    finalScore?: number | null
    coinPointsEarned?: number
    isFreeAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    madeMistake?: boolean
    quitEarly?: boolean
  }

  export type InstantSessionCreateManyUserInput = {
    id?: string
    status?: $Enums.InstantTournamentSessionStatus
    tournamentId: string
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
  }

  export type InstantParticipantCreateManyUserInput = {
    tournamentId: string
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
  }

  export type DailyLeaderboardCreateManyUserInput = {
    id?: string
    date: Date | string
    bestScore?: number
    rank?: number
    coinPoints?: number
    updatedAt?: Date | string
  }

  export type InstantLeaderboardCreateManyUserInput = {
    id?: string
    tournamentId: string
    bestScore?: number
    rank?: number
    coinPoints: Decimal | DecimalJsLike | number | string
    submittedAt: Date | string
    updatedAt?: Date | string
    date?: Date | string
  }

  export type RewardClaimCreateManyUserInput = {
    id?: string
    coinsLocked: number
    status?: $Enums.ClaimStatus
    voucherCode?: string | null
    adminNotes?: string | null
    fulfilledBy?: string | null
    fulfilledAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    refereeId?: string | null
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyRefereeInput = {
    id?: string
    referrerId: string
    referralCode: string
    status?: $Enums.ReferralStatus
    referrerCoins?: number
    refereeCoins?: number
    rewardedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoinLedgerCreateManyUserInput = {
    id?: string
    date: Date | string
    delta: number
    source: $Enums.CoinLedgerSource
    referenceId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DailyUserLeaderboardCreateManyUserInput = {
    id?: string
    date: Date | string
    dailyCoinPoints?: number
    instantCoinPoints?: Decimal | DecimalJsLike | number | string
    totalCoinPoints?: Decimal | DecimalJsLike | number | string
    rank?: number
    isEligible?: boolean
    coinsAwarded?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
    referrals?: UserUncheckedUpdateManyWithoutReferredByNestedInput
    dailySessions?: DailyTournamentSessionUncheckedUpdateManyWithoutUserNestedInput
    soloSessions?: SoloSessionUncheckedUpdateManyWithoutUserNestedInput
    instantSessions?: InstantSessionUncheckedUpdateManyWithoutUserNestedInput
    instantParticipant?: InstantParticipantUncheckedUpdateManyWithoutUserNestedInput
    dailyLeaderBoards?: DailyLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    instantLeaderboard?: InstantLeaderboardUncheckedUpdateManyWithoutUserNestedInput
    rewardClaim?: RewardClaimUncheckedUpdateManyWithoutUserNestedInput
    referralsGiven?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutRefereeNestedInput
    coinLedger?: CoinLedgerUncheckedUpdateManyWithoutUserNestedInput
    dailyUserLeaderboard?: DailyUserLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    deviceHash?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    usernameReservedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarType?: EnumAvatarTypeFieldUpdateOperationsInput | $Enums.AvatarType
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coins?: IntFieldUpdateOperationsInput | number
    lifetimeCoins?: IntFieldUpdateOperationsInput | number
    lifetimeCoinPoints?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    theme?: EnumThemeFieldUpdateOperationsInput | $Enums.Theme
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    hapticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referralRewarded?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    soloAttemptCount?: IntFieldUpdateOperationsInput | number
    instantAttemptCount?: IntFieldUpdateOperationsInput | number
    dailyAttemptCount?: IntFieldUpdateOperationsInput | number
    currentLoginStreak?: IntFieldUpdateOperationsInput | number
    longestLoginStreak?: IntFieldUpdateOperationsInput | number
    lastLoginRewardDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalLoginDays?: IntFieldUpdateOperationsInput | number
  }

  export type DailyTournamentSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: DailyTournamentUpdateOneRequiredWithoutSessionsNestedInput
    questions?: QuestionAttemptUpdateManyWithoutDailySessionNestedInput
  }

  export type DailyTournamentSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionAttemptUncheckedUpdateManyWithoutDailySessionNestedInput
  }

  export type DailyTournamentSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SoloSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionAttemptUpdateManyWithoutSoloSessionNestedInput
  }

  export type SoloSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
    questions?: QuestionAttemptUncheckedUpdateManyWithoutSoloSessionNestedInput
  }

  export type SoloSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    bankedPoints?: FloatFieldUpdateOperationsInput | number
    finalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    coinPointsEarned?: IntFieldUpdateOperationsInput | number
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    madeMistake?: BoolFieldUpdateOperationsInput | boolean
    quitEarly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InstantSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tournament?: InstantTournamentUpdateOneRequiredWithoutSessionsNestedInput
    questions?: QuestionAttemptUpdateManyWithoutInstantSessionNestedInput
  }

  export type InstantSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuestionAttemptUncheckedUpdateManyWithoutInstantSessionNestedInput
  }

  export type InstantSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    tournamentId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstantParticipantUpdateWithoutUserInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    tournament?: InstantTournamentUpdateOneRequiredWithoutInstantParticipantNestedInput
  }

  export type InstantParticipantUncheckedUpdateWithoutUserInput = {
    tournamentId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InstantParticipantUncheckedUpdateManyWithoutUserInput = {
    tournamentId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DailyLeaderboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyLeaderboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyLeaderboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstantLeaderboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstantLeaderboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstantLeaderboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    coinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinsLocked?: IntFieldUpdateOperationsInput | number
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    voucherCode?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledBy?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinsLocked?: IntFieldUpdateOperationsInput | number
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    voucherCode?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledBy?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinsLocked?: IntFieldUpdateOperationsInput | number
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    voucherCode?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledBy?: NullableStringFieldUpdateOperationsInput | string | null
    fulfilledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referee?: UserUpdateOneWithoutReferralsReceivedNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsGivenNestedInput
  }

  export type ReferralUncheckedUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    status?: EnumReferralStatusFieldUpdateOperationsInput | $Enums.ReferralStatus
    referrerCoins?: IntFieldUpdateOperationsInput | number
    refereeCoins?: IntFieldUpdateOperationsInput | number
    rewardedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinLedgerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    delta?: IntFieldUpdateOperationsInput | number
    source?: EnumCoinLedgerSourceFieldUpdateOperationsInput | $Enums.CoinLedgerSource
    referenceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinLedgerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    delta?: IntFieldUpdateOperationsInput | number
    source?: EnumCoinLedgerSourceFieldUpdateOperationsInput | $Enums.CoinLedgerSource
    referenceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinLedgerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    delta?: IntFieldUpdateOperationsInput | number
    source?: EnumCoinLedgerSourceFieldUpdateOperationsInput | $Enums.CoinLedgerSource
    referenceId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyUserLeaderboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyCoinPoints?: IntFieldUpdateOperationsInput | number
    instantCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    isEligible?: BoolFieldUpdateOperationsInput | boolean
    coinsAwarded?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyUserLeaderboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyCoinPoints?: IntFieldUpdateOperationsInput | number
    instantCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    isEligible?: BoolFieldUpdateOperationsInput | boolean
    coinsAwarded?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyUserLeaderboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyCoinPoints?: IntFieldUpdateOperationsInput | number
    instantCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalCoinPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    isEligible?: BoolFieldUpdateOperationsInput | boolean
    coinsAwarded?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinuteSnapshotCreateManyTournamentInput = {
    id?: string
    minuteNumber: number
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DailyTournamentSessionCreateManyTournamentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    sessionSeed: string
    startedAt?: Date | string
    endedAt?: Date | string | null
    status?: $Enums.UserTournamentStatus
    currentScore?: number
    finalScore?: number | null
    minute1Score?: number | null
    minute2Score?: number | null
    minute3Score?: number | null
    minute4Score?: number | null
    isFreeAttempt?: boolean
    isRewardedAttempt?: boolean
    currentLevel?: number
    questionsAnswered?: number
    correctAnswers?: number
    endsAt: Date | string
  }

  export type MinuteSnapshotUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    minuteNumber?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinuteSnapshotUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    minuteNumber?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinuteSnapshotUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    minuteNumber?: IntFieldUpdateOperationsInput | number
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyTournamentSessionUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailySessionsNestedInput
    questions?: QuestionAttemptUpdateManyWithoutDailySessionNestedInput
  }

  export type DailyTournamentSessionUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionAttemptUncheckedUpdateManyWithoutDailySessionNestedInput
  }

  export type DailyTournamentSessionUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionSeed?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumUserTournamentStatusFieldUpdateOperationsInput | $Enums.UserTournamentStatus
    currentScore?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    minute1Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute2Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute3Score?: NullableIntFieldUpdateOperationsInput | number | null
    minute4Score?: NullableIntFieldUpdateOperationsInput | number | null
    isFreeAttempt?: BoolFieldUpdateOperationsInput | boolean
    isRewardedAttempt?: BoolFieldUpdateOperationsInput | boolean
    currentLevel?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAttemptCreateManyDailySessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    soloSessionId?: string | null
    instantSessionId?: string | null
  }

  export type QuestionAttemptUpdateWithoutDailySessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    soloSession?: SoloSessionUpdateOneWithoutQuestionsNestedInput
    instantSession?: InstantSessionUpdateOneWithoutQuestionsNestedInput
  }

  export type QuestionAttemptUncheckedUpdateWithoutDailySessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    soloSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    instantSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutDailySessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    soloSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    instantSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionAttemptCreateManySoloSessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySessionId?: string | null
    instantSessionId?: string | null
  }

  export type QuestionAttemptUpdateWithoutSoloSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySession?: DailyTournamentSessionUpdateOneWithoutQuestionsNestedInput
    instantSession?: InstantSessionUpdateOneWithoutQuestionsNestedInput
  }

  export type QuestionAttemptUncheckedUpdateWithoutSoloSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySessionId?: NullableStringFieldUpdateOperationsInput | string | null
    instantSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutSoloSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySessionId?: NullableStringFieldUpdateOperationsInput | string | null
    instantSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InstantSessionCreateManyTournamentInput = {
    id?: string
    userId: string
    status?: $Enums.InstantTournamentSessionStatus
    score?: number
    finalScore?: number | null
    bestScore?: number
    startedAt?: Date | string
    endsAt?: Date | string | null
    submittedAt?: Date | string | null
  }

  export type InstantParticipantCreateManyTournamentInput = {
    userId: string
    joinedAt?: Date | string
    joinOrder: number
    sessionStarted?: boolean
    finalScore?: number | null
    submittedAt?: Date | string | null
    finalRank?: number | null
  }

  export type InstantSessionUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInstantSessionsNestedInput
    questions?: QuestionAttemptUpdateManyWithoutInstantSessionNestedInput
  }

  export type InstantSessionUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuestionAttemptUncheckedUpdateManyWithoutInstantSessionNestedInput
  }

  export type InstantSessionUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInstantTournamentSessionStatusFieldUpdateOperationsInput | $Enums.InstantTournamentSessionStatus
    score?: IntFieldUpdateOperationsInput | number
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstantParticipantUpdateWithoutTournamentInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutInstantParticipantNestedInput
  }

  export type InstantParticipantUncheckedUpdateWithoutTournamentInput = {
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InstantParticipantUncheckedUpdateManyWithoutTournamentInput = {
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinOrder?: IntFieldUpdateOperationsInput | number
    sessionStarted?: BoolFieldUpdateOperationsInput | boolean
    finalScore?: NullableIntFieldUpdateOperationsInput | number | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalRank?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAttemptCreateManyInstantSessionInput = {
    id?: string
    createdAt?: Date | string
    questionIndex?: number
    level: number
    expression: string
    result: string
    side: string
    kthDigit: number
    correctDigit: number
    dailySessionId?: string | null
    soloSessionId?: string | null
  }

  export type QuestionAttemptUpdateWithoutInstantSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySession?: DailyTournamentSessionUpdateOneWithoutQuestionsNestedInput
    soloSession?: SoloSessionUpdateOneWithoutQuestionsNestedInput
  }

  export type QuestionAttemptUncheckedUpdateWithoutInstantSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySessionId?: NullableStringFieldUpdateOperationsInput | string | null
    soloSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutInstantSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionIndex?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    expression?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    kthDigit?: IntFieldUpdateOperationsInput | number
    correctDigit?: IntFieldUpdateOperationsInput | number
    dailySessionId?: NullableStringFieldUpdateOperationsInput | string | null
    soloSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}